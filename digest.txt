Directory structure:
└── 25-AdventureX-SUPCON-Hackathon/
    ├── README.md
    ├── pyproject.toml
    ├── run_multi_line_simulation.py
    ├── uv.lock
    ├── .python-version
    ├── config/
    │   ├── factory_layout.yml
    │   ├── factory_layout_multi.yml
    │   ├── path_timing.py
    │   ├── schemas.py
    │   ├── settings.py
    │   ├── topics.py
    │   └── __pycache__/
    ├── docs/
    ├── src/
    │   ├── main.py
    │   ├── user_input.py
    │   ├── user_input_multi.py
    │   ├── __pycache__/
    │   ├── agent_interface/
    │   │   ├── command_handler.py
    │   │   ├── multi_line_command_handler.py
    │   │   └── __pycache__/
    │   ├── game_logic/
    │   │   ├── fault_system.py
    │   │   ├── kpi_calculator.py
    │   │   ├── order_generator.py
    │   │   └── __pycache__/
    │   ├── simulation/
    │   │   ├── factory.py
    │   │   ├── factory_multi.py
    │   │   ├── line.py
    │   │   ├── __pycache__/
    │   │   └── entities/
    │   │       ├── agv.py
    │   │       ├── base.py
    │   │       ├── conveyor.py
    │   │       ├── product.py
    │   │       ├── quality_checker.py
    │   │       ├── station.py
    │   │       ├── warehouse.py
    │   │       └── __pycache__/
    │   └── utils/
    │       ├── config_loader.py
    │       ├── mqtt_client.py
    │       ├── safe_output.py
    │       ├── topic_manager.py
    │       └── __pycache__/
    └── unity/
        ├── index.html
        ├── Build/
        │   ├── SimPy.data.unityweb
        │   ├── SimPy.framework.js.unityweb
        │   ├── SimPy.loader.js
        │   └── SimPy.wasm.unityweb
        ├── StreamingAssets/
        │   └── MQTTBroker.json
        └── TemplateData/
            └── style.css

================================================
File: README.md
================================================
# SUPCON NLDF (Natual Language Driven Factory) Simulator

## Quick Start

### 1. Environment Setup

- Download [uv](https://docs.astral.sh/uv/getting-started/installation/)

```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

- Clone project

```bash
git clone https://github.com/supcon-international/25-AdventureX-SUPCON-Hackathon.git
cd 25-AdventureX-SUPCON-Hackathon
```

- Install dependencies

```bash
uv sync
```

### 2. Run Simulation

设置环境变量`TOPIC_ROOT`作为仿真系统 mqtt 的 client id 和 topic root 来分隔不同选手，默认值获取顺序为`TOPIC_ROOT`, `USERNAME`, `USER`的环境变量，否则默认"NLDF_TEST"

- add `--menu` arg to enable interactive input thread for test only
- add `--no-mqtt` arg to disable mqtt communication for debug offline

```bash
uv run run_multi_line_simulation.py (--menu) (--no-mqtt)
```

### 3. Unity Run

1. 设置 `StreamingAssets/MQTTBroker.json`中的 Root_Topic_Head 字段与上述的 topic root 一致，并修改 wss.client_id 字段防止 client 冲突。
2. 使用 VScode Live Server 插件，选中到 index.html 文件后 go live 初始化给予 WebGL 的 Unity 前端界面

   "wss":{
   "port": 8084,
   "host": "supos-ce-instance4.supos.app",
   "client*id": "\*\*\_NLDF2_mqtt_wss_test*\*\*",
   ......
   },

   "common*topic":{
   "Root_Topic_Head": "\*\*\_NLDF1*\*\*"},

## Background

Agent 成了每个领域绕不开的革命火种，在工业领域亦是如此。作为国内工业自动化的龙头企业，我们正在积极尝试将最前沿的 agent 技术引入真实产线，推动传统工厂向自适应、自组织、自优化系统演进。
我们进一步畅想：能否构建一个像人类一样通过语言决策的智能体系统？可以想象机器之间对话：“我这边快满了，暂停投料。”
“收到，我先缓一轮。”用语言做到理解彼此、协作应变、自主决策，实现工厂收益最大化的同时稳定运行。为此，我们搭建了一个可控的模拟工厂，等待你来赋予它思维与行动，探索 agent 与工业协作的新可能。

## 场景解释

工厂内部包含 3 条产线，一个原料仓库以及一个最终产品仓库，3 条产线配置有一样的 A，B，C 工站以及一个质检站，AB，BC，CQ 三条中间连接的自动传送带和 AGV_1，AGV_2 两个 AGV。选手需要对 3 条产线的一共 6 个 AGV 进行操作（包括移动，装货卸货等），选手需要在有限的时间内操作 agv 协调生产，同时应对随机故障，获得尽可能高的 KPI 得分。（KPI 定义见下文）

为了简单起见，每个 AGV 的可移动路径点都使用 P1-P10 来表示，他们表示当前 AGV 路径上的相对可停顿点，如果希望 AGV1 或 2 前往某点例如原料仓库，都需要移动到 P0 点。AGV 路径互不干扰，不考虑碰撞等因素，路径上的点 ID 如图。
![Factory Agent Logo](/docs/path_point.png)

| point_id | device_id    | 备注      |
| :------- | :----------- | :-------- |
| P0       | RawMaterial  | 原料仓库  |
| P1       | StationA     | 工站 A    |
| P2       | Conveyor_AB  | 传送带 AB |
| P3       | StationB     | 工站 B    |
| P4       | Conveyor_BC  | 传送带 BC |
| P5       | StationC     | 工站 C    |
| P6       | Conveyor_CQ  | 传送带 CQ |
| P7       | QualityCheck | 质检站    |
| P8       | QualityCheck | 质检站    |
| P9       | Warehouse    | 成品仓库  |

## 游戏机制

游戏使用 simpy 实现离散工厂的仿真

1. Order Generactor: 游戏有一个全局的订单生成器，每个订单中可能有一个或多个产品等待加工，一旦生成对应待加工的 product 会在原料仓库中出现
2. 产品说明： 游戏定义 P1，P2，P3 三种产品，产品 id:prod_1_XXXXXX 中包含 3 部分 prod,type 数字和 UUID，产品有自己对应的工艺流程：

- 产品 P1 / P2

```
RawMaterial → [AGV] → StationA → Conveyor_AB → StationB → Conveyor_BC → StationC → Conveyor_CQ → QualityCheck → [AGV] → Warehouse
```

- 产品 P3

```
RawMaterial → [AGV] → StationA → Conveyor_AB → StationB → Conveyor_BC → StationC → Conveyor_CQ[upper/lower buffer] → [AGV] → StationB → Conveyor_BC → StationC → Conveyor_CQ → QualityCheck → [AGV] → Warehousse
```

3. AGV 动作操控时会消耗电量，在移动前检查如果当前电量不足以完成动作，AGV 会自动返回充电站充电。
4. KPI 指标

| 类别         | 指标         | 计算公式                                      |
| :----------- | :----------- | :-------------------------------------------- |
| **生产效率** | 订单完成率   | `按时完成订单数 / 总订单数 × 100%`            |
|              | 生产周期效率 | `实际生产时间 / 理论生产时间`（含完成率权重） |
|              | 设备利用率   | `设备工作时间 / 总时间 × 100%`                |
| **质量成本** | 一次通过率   | `一次通过质检数 / 总产品数 × 100%`            |
|              | 生产成本     | `Σ(物料+能源+维修+报废成本)`                  |
| **AGV 效率** | 充电策略     | `主动充电次数 / 总充电次数 × 100%`            |
|              | 能源效率     | `完成任务数 / 总充电时间`                     |
|              | AGV 利用率   | `运输时间 / (总时间-故障-充电) × 100%`        |

5. 竞赛评分系统（100 分制）

- **生产效率**（40 分）：订单完成率 16 分 + 周期效率 16 分 + 设备利用率 8 分
- **质量成本**（30 分）：一次通过率 12 分 + 成本控制 18 分
- **AGV 效率**（30 分）：充电策略 9 分 + 能效比 12 分 + 利用率 9 分

## 3. 功能与架构

### 3.1 核心工作流：外部 JSON 接口，内部自然语言驱动

仿真环境与选手 Agent 之间通过结构化的 JSON 消息进行通信，我们要求选手在自己的 Agent 内部构建自然语言处理能力，形成 `JSON -> NL -> JSON` 的完整决策链路。

```mermaid
sequenceDiagram
    participant D as Device (SimPy)
    participant M as MQTT Broker
    participant A as AI Agent (选手代码)

    D->>M: PUBLISH (NLDF/station/StationA/status)<br>{"status":"IDLE", ...}
    M->>A: SUBSCRIBE
    A->>A: **内部实现: JSON -> 自然语言 -> 决策 -> JSON**
    A->>M: PUBLISH (agent/commands)<br>{"action": "unload_to_station", ...}
    M->>D: **执行仿真动作**
```

### 3.2 MQTT 通信层

#### Topic 架构 (`NLDF_DEFAULT` will be replaced by use environment variable `TOPIC_ROOT`)

| Topic                                         | Agent 权限    | 描述                            | 消息格式 (Payload) |
| :-------------------------------------------- | :------------ | :------------------------------ | :----------------- |
| `NLDF_DEFAULT/{line_id}/station/{id}/status`  | **Subscribe** | 订阅所有工站的状态              | JSON (结构化)      |
| `NLDF_DEFAULT/{line_id}/agv/{id}/status`      | **Subscribe** | 订阅所有 AGV 的状态             | JSON (结构化)      |
| `NLDF_DEFAULT/{line_id}/conveyor/{id}/status` | **Subscribe** | 订阅所有传送带的状态            | JSON (结构化)      |
| `NLDF_DEFAULT/warehouse/{id}/status`          | **Subscribe** | 订阅所有仓库的状态              | JSON (结构化)      |
| :---                                          | :---          | :---                            | :---               |
| `NLDF_DEFAULT/{line_id}/alerts`               | **Subscribe** | 订阅所有设备故障警报            | JSON (结构化)      |
| `NLDF_DEFAULT/orders/status`                  | **Subscribe** | 接收新订单信息                  | JSON (结构化)      |
| `NLDF_DEFAULT/kpi/status`                     | **Subscribe** | 订阅 KPI 更新                   | JSON (结构化)      |
| `NLDF_DEFAULT/result/status`                  | **Subscribe** | 订阅结果更新                    | JSON (结构化)      |
| :---                                          | :---          | :---                            | :---               |
| `NLDF_DEFAULT/command/{line_id}`              | **Publish**   | 发布选手 Agent 生成的结构化指令 | JSON (结构见下文)  |
| `NLDF_DEFAULT/response/{line_id}`             | **Subscribe** | 接收选手 Agent 的响应           | JSON（结构见下文） |

选手发往 `NLDF_DEFAULT/command/{line_id}` 的消息**必须**是以下格式的 JSON 字符串：

```json
{
  "command_id": "str (可选字段，用于记录决策过程)",
  "action": "str (必须是支持的动作之一)",
  "target": "str (动作的目标设备ID，可选)",
  "params": {
    "key1": "value1", ...
  }
}
```

系统反馈 `response/{line_id}` 的消息如下：

```json
{
  "timestamp": "float (仿真时间戳)",
  "command_id": "str (来自于选手的command_id)",
  "response": "str (反馈信息)"
}
```

支持的指令 `action` 和所需 `params`，command_id is optional, can be ignored.

| Action       | 描述                                                                               | Target | 示例                                                                                                                                                                                |
| :----------- | :--------------------------------------------------------------------------------- | :----- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `move`       | 命令 AGV 移动到指定路径点                                                          | AGV ID | `{'command_id': 'move_688777', 'action': 'move', 'target': 'AGV_1', 'params': {'target_point': 'P1'}}`                                                                              |
| `charge`     | 命令 AGV 主动充电                                                                  | AGV ID | `{'command_id': 'charge_688777', 'action': 'charge', 'target': 'AGV_1', 'params': {'target_level': 70.0}}`(default: 80.0)                                                           |
| `unload`     | 命令 AGV 卸载产品到指定工站                                                        | AGV ID | `{'command_id': 'unload_688777', 'action': 'unload', 'target': 'AGV_2', 'params': {}}`                                                                                              |
| `load`       | 命令 AGV 从指定工站装载产品                                                        | AGV ID | `{'command_id': 'load_688777', 'action': 'load', 'target': 'AGV_1', 'params': {'product_id': 'prod_1_1ee7ce46'}}`(Product ID only can be used in RawMaterial, else will be ignored) |
| 全局 action  | topic 中的 line_id 和 payload 中的 target 字段内容可以忽略，仅为过 schema 格式审核 | 全局   | :---                                                                                                                                                                                |
| `get_result` | 获取当前整个工厂的 KPI 结果                                                        | any    | `{'command_id': 'get_result_688777', 'action': 'get_result', 'target': my factoty', 'params': {}}`                                                                                  |

## 4.评价维度

除了 ADVX 的统一评价维度外，我们将从以下四个方面对你的项目进行等权重评价：

1. **KPI 得分**

   - 这是最直接且客观的评价标准。我们将根据你搭建的 Agent 在预定义 KPI 指标上的表现进行评分。
   - _注意：如果你对虚拟工厂进行了修改，我们会综合考虑这些改动对 KPI 得分的影响。_

2. **LLM Agent 工程能力**

   - 你需要设计或使用一个框架，使 LLM 能够通过 MQTT + JSON 与虚拟工厂高效交互。
   - 我们将重点考察你在上下文管理、状态管理、错误处理等关键机制上的实现。
   - 优雅、健壮的 Agent 工程设计将获得额外加分。

3. **虚拟工厂的改进**

   - 虚拟工厂基于 Simpy 实现，模拟了真实世界的高级排程（Advanced Scheduling）问题。
   - 如果你发现工厂存在不合理之处，可以直接修改或扩展其运行机制，使其更贴近真实工厂。
   - _如对虚拟工厂有任何修改，请务必在项目 README 中显著注明。_

4. **supOS-CE 开源框架的应用**

   - 成功部署 supOS-CE，并使用其自带的 MQTT Broker 作为虚拟工厂与 Agent 的通信接口，将获得加分。
   - 如果你进一步集成了 supOS-CE 的其他组件（如 NodeRED、Portainer 等），或发现并反馈了其问题/bug，也会获得额外加分。

   - > [supos 选手使用方法](https://ofra65wfwe.feishu.cn/wiki/SRgrwj9LWimsTikRFdzcVvlDnEU)

---



================================================
File: pyproject.toml
================================================
[project]
name = "supcon-adventurex-factory-sim"
version = "1.0.0"
description = "Backend simulation environment for the SUPCON Hackathon"
authors = [{ name = "SUPCON R&D Team" }]
dependencies = [
    "simpy",
    "paho-mqtt",
    "pydantic",
    "pyyaml",
    "numpy",
    "psutil",
]
requires-python = ">=3.9"

# Add package configuration for proper import resolution
[tool.setuptools]
packages = ["src"]

[tool.setuptools.package-dir]
"" = "."

[build-system]
requires = ["setuptools", "wheel"]
build-backend = "setuptools.build_meta"

[tool.uv]
dev-dependencies = [
    "pytest",
]

[tool.pyright]
include = ["src"]
exclude = ["**/__pycache__"]
typeCheckingMode = "basic"

[tool.ruff]
line-length = 88
select = ["E", "F", "W", "I"]
ignore = []

[tool.ruff.format]
quote-style = "double"



================================================
File: run_multi_line_simulation.py
================================================
# run_multi_line_simulation.py
import os
import sys
import argparse
import threading

# Add the project root to Python path
project_root = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, project_root)

from src.utils.mqtt_client import MQTTClient
from src.simulation.factory_multi import Factory
from src.utils.config_loader import load_factory_config
from config.settings import MQTT_BROKER_HOST, MQTT_BROKER_PORT
import logging
from config.settings import LOG_LEVEL
from src.agent_interface.multi_line_command_handler import MultiLineCommandHandler
from src.user_input_multi import menu_input_thread
from typing import Optional
import time

logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class MultiLineFactorySimulation:
    """
    Main orchestrator class that combines all components of the factory simulation.
    """
    
    def __init__(self):
        self.factory: Optional[Factory] = None
        self.mqtt_client: Optional[MQTTClient] = None
        self.command_handler: Optional[MultiLineCommandHandler] = None
        self.running = False

    def initialize(self, no_faults=False, no_mqtt=False):
        """Initialize all simulation components."""
        logger.info("🏭 Initializing Multi-Line Factory Simulation...")
        # 优先使用 CLIENT_ID，其次 USERNAME/USER，最后默认值，确保 client_name 一定为 str
        client_name = (
            os.getenv("TOPIC_ROOT")
            or os.getenv("USERNAME")
            or os.getenv("USER")
            or "NLDF_TEST"
        )
        self.mqtt_client = MQTTClient(MQTT_BROKER_HOST, MQTT_BROKER_PORT, client_name)
        
        # Connect to MQTT
        logger.info(f"📡 Connecting to MQTT broker at {MQTT_BROKER_HOST}:{MQTT_BROKER_PORT}, client_name: {client_name}")

        if not no_mqtt:
            self.mqtt_client.connect()
            # Wait for MQTT client to be fully connected
            max_retries = 20
            retry_interval = 0.5
            for i in range(max_retries):
                if self.mqtt_client.is_connected():
                    logger.info("✅ MQTT client is fully connected.")
                    break
                logger.info(f"Waiting for MQTT connection... ({i+1}/{max_retries})")
                time.sleep(retry_interval)
            else:
                logger.error("❌ Failed to connect to MQTT broker within the given time. Exiting simulation.")
                raise ConnectionError("MQTT connection failed.")

        try:
            layout_config = load_factory_config('factory_layout_multi.yml')
            print(f"✅ Successfully loaded multi-line factory configuration from layout_config")
        except Exception as e:
            print(f"❌ Failed to load multi-line factory configuration: {e}")
            raise e
        
        self.factory = Factory(layout_config, self.mqtt_client, no_faults=no_faults) # no_faults for cleaner testing
        logger.info(f"✅ Factory created with {len(self.factory.lines)} lines")
        
        # Create command handler (this will start listening for commands)
        self.command_handler = MultiLineCommandHandler(self.factory, self.mqtt_client, self.factory.topic_manager)
        logger.info("🎯 Command handler initialized and listening for agent commands")
    
    def run(self, duration: Optional[int] = None):
        """Run the simulation."""
        if self.factory is None:
            logger.error("❌ Factory is not initialized. Call initialize() first.")
            return

        logger.info("🚀 Starting Factory Simulation...")
        self.running = True
        
        try:
            if duration:
                logger.info(f"⏱️  Running simulation for {duration} seconds")
                self.factory.run(until=duration)
                # For fixed duration, print scores after normal completion
                # self.factory.print_final_scores()
            else:
                logger.info("🔄 Running simulation indefinitely (Ctrl+C to stop)")
                while self.running:
                    # Run simulation for 1 second at a time
                    self.factory.run(until=int(self.factory.env.now) + 1)
                    time.sleep(1)  # Small delay to prevent busy waiting
                    
        except KeyboardInterrupt:
            logger.info("🛑 Simulation interrupted by user")
            # Scores will be printed in shutdown()
        except Exception as e:
            logger.error(f"❌ Simulation error: {e}")
        finally:
            # For indefinite runs or errors, print scores during shutdown
            if not duration:
                self.shutdown()
            else:
                # For fixed duration runs, just clean up without printing scores again
                logger.info("🧹 Cleaning up resources...")
                self.running = False
                if self.mqtt_client:
                    self.mqtt_client.disconnect()
                logger.info("👋 Factory Simulation stopped")

    def shutdown(self):
        """Clean up resources."""
        logger.info("🧹 Shutting down Factory Simulation...")
        self.running = False
        
        # # Print final scores when shutting down
        # if self.factory:
        #     self.factory.print_final_scores()
        
        if self.mqtt_client:
            self.mqtt_client.disconnect()
            
        logger.info("👋 Factory Simulation stopped")

def run_simulation_multi():
    """Runs the multi-line factory simulation."""
    parser = argparse.ArgumentParser(description="SUPCON Multi-Line Factory Simulation Launcher")
    parser.add_argument(
        "--menu",
        action="store_true",
        help="Enable the interactive menu for manual control."
    )
    parser.add_argument(
        "--no-mqtt",
        action="store_true",
        help="Ignore mqtt connection for offline test"
    )
    parser.add_argument(
        "--no-fault",
        action="store_true",
        help="Disable random fault injection in the simulation."
    )
    args = parser.parse_args()

    simulation = MultiLineFactorySimulation()
    simulation.initialize(no_faults=args.no_fault, no_mqtt=args.no_mqtt)
    
    if args.menu and simulation.factory and simulation.factory.topic_manager:
        threading.Thread(target=menu_input_thread, args=(simulation.mqtt_client, simulation.factory, simulation.factory.topic_manager), daemon=True).start()
        logger.info("Interactive menu enabled. Type commands in the console.")

    simulation.run()  # Run indefinitely

if __name__ == '__main__':
    run_simulation_multi()



================================================
File: uv.lock
================================================
version = 1
revision = 1
requires-python = ">=3.9"
resolution-markers = [
    "python_full_version >= '3.11'",
    "python_full_version == '3.10.*'",
    "python_full_version < '3.10'",
]

[[package]]
name = "annotated-types"
version = "0.7.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ee/67/531ea369ba64dcff5ec9c3402f9f51bf748cec26dde048a2f973a4eea7f5/annotated_types-0.7.0.tar.gz", hash = "sha256:aff07c09a53a08bc8cfccb9c85b05f1aa9a2a6f23728d790723543408344ce89", size = 16081 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/78/b6/6307fbef88d9b5ee7421e68d78a9f162e0da4900bc5f5793f6d3d0e34fb8/annotated_types-0.7.0-py3-none-any.whl", hash = "sha256:1f02e8b43a8fbbc3f3e0d4f0f4bfc8131bcb4eebe8849b8e5c773f3a1c582a53", size = 13643 },
]

[[package]]
name = "colorama"
version = "0.4.6"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d8/53/6f443c9a4a8358a93a6792e2acffb9d9d5cb0a5cfd8802644b7b1c9a02e4/colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44", size = 27697 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/d1/d6/3965ed04c63042e047cb6a3e6ed1a63a35087b6a609aa3a15ed8ac56c221/colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6", size = 25335 },
]

[[package]]
name = "exceptiongroup"
version = "1.3.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions", marker = "python_full_version < '3.11'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/0b/9f/a65090624ecf468cdca03533906e7c69ed7588582240cfe7cc9e770b50eb/exceptiongroup-1.3.0.tar.gz", hash = "sha256:b241f5885f560bc56a59ee63ca4c6a8bfa46ae4ad651af316d4e81817bb9fd88", size = 29749 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/36/f4/c6e662dade71f56cd2f3735141b265c3c79293c109549c1e6933b0651ffc/exceptiongroup-1.3.0-py3-none-any.whl", hash = "sha256:4d111e6e0c13d0644cad6ddaa7ed0261a0b36971f6d23e7ec9b4b9097da78a10", size = 16674 },
]

[[package]]
name = "iniconfig"
version = "2.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f2/97/ebf4da567aa6827c909642694d71c9fcf53e5b504f2d96afea02718862f3/iniconfig-2.1.0.tar.gz", hash = "sha256:3abbd2e30b36733fee78f9c7f7308f2d0050e88f0087fd25c2645f63c773e1c7", size = 4793 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2c/e1/e6716421ea10d38022b952c159d5161ca1193197fb744506875fbb87ea7b/iniconfig-2.1.0-py3-none-any.whl", hash = "sha256:9deba5723312380e77435581c6bf4935c94cbfab9b1ed33ef8d238ea168eb760", size = 6050 },
]

[[package]]
name = "numpy"
version = "2.0.2"
source = { registry = "https://pypi.org/simple" }
resolution-markers = [
    "python_full_version < '3.10'",
]
sdist = { url = "https://files.pythonhosted.org/packages/a9/75/10dd1f8116a8b796cb2c737b674e02d02e80454bda953fa7e65d8c12b016/numpy-2.0.2.tar.gz", hash = "sha256:883c987dee1880e2a864ab0dc9892292582510604156762362d9326444636e78", size = 18902015 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/21/91/3495b3237510f79f5d81f2508f9f13fea78ebfdf07538fc7444badda173d/numpy-2.0.2-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:51129a29dbe56f9ca83438b706e2e69a39892b5eda6cedcb6b0c9fdc9b0d3ece", size = 21165245 },
    { url = "https://files.pythonhosted.org/packages/05/33/26178c7d437a87082d11019292dce6d3fe6f0e9026b7b2309cbf3e489b1d/numpy-2.0.2-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:f15975dfec0cf2239224d80e32c3170b1d168335eaedee69da84fbe9f1f9cd04", size = 13738540 },
    { url = "https://files.pythonhosted.org/packages/ec/31/cc46e13bf07644efc7a4bf68df2df5fb2a1a88d0cd0da9ddc84dc0033e51/numpy-2.0.2-cp310-cp310-macosx_14_0_arm64.whl", hash = "sha256:8c5713284ce4e282544c68d1c3b2c7161d38c256d2eefc93c1d683cf47683e66", size = 5300623 },
    { url = "https://files.pythonhosted.org/packages/6e/16/7bfcebf27bb4f9d7ec67332ffebee4d1bf085c84246552d52dbb548600e7/numpy-2.0.2-cp310-cp310-macosx_14_0_x86_64.whl", hash = "sha256:becfae3ddd30736fe1889a37f1f580e245ba79a5855bff5f2a29cb3ccc22dd7b", size = 6901774 },
    { url = "https://files.pythonhosted.org/packages/f9/a3/561c531c0e8bf082c5bef509d00d56f82e0ea7e1e3e3a7fc8fa78742a6e5/numpy-2.0.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:2da5960c3cf0df7eafefd806d4e612c5e19358de82cb3c343631188991566ccd", size = 13907081 },
    { url = "https://files.pythonhosted.org/packages/fa/66/f7177ab331876200ac7563a580140643d1179c8b4b6a6b0fc9838de2a9b8/numpy-2.0.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:496f71341824ed9f3d2fd36cf3ac57ae2e0165c143b55c3a035ee219413f3318", size = 19523451 },
    { url = "https://files.pythonhosted.org/packages/25/7f/0b209498009ad6453e4efc2c65bcdf0ae08a182b2b7877d7ab38a92dc542/numpy-2.0.2-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:a61ec659f68ae254e4d237816e33171497e978140353c0c2038d46e63282d0c8", size = 19927572 },
    { url = "https://files.pythonhosted.org/packages/3e/df/2619393b1e1b565cd2d4c4403bdd979621e2c4dea1f8532754b2598ed63b/numpy-2.0.2-cp310-cp310-musllinux_1_2_aarch64.whl", hash = "sha256:d731a1c6116ba289c1e9ee714b08a8ff882944d4ad631fd411106a30f083c326", size = 14400722 },
    { url = "https://files.pythonhosted.org/packages/22/ad/77e921b9f256d5da36424ffb711ae79ca3f451ff8489eeca544d0701d74a/numpy-2.0.2-cp310-cp310-win32.whl", hash = "sha256:984d96121c9f9616cd33fbd0618b7f08e0cfc9600a7ee1d6fd9b239186d19d97", size = 6472170 },
    { url = "https://files.pythonhosted.org/packages/10/05/3442317535028bc29cf0c0dd4c191a4481e8376e9f0db6bcf29703cadae6/numpy-2.0.2-cp310-cp310-win_amd64.whl", hash = "sha256:c7b0be4ef08607dd04da4092faee0b86607f111d5ae68036f16cc787e250a131", size = 15905558 },
    { url = "https://files.pythonhosted.org/packages/8b/cf/034500fb83041aa0286e0fb16e7c76e5c8b67c0711bb6e9e9737a717d5fe/numpy-2.0.2-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:49ca4decb342d66018b01932139c0961a8f9ddc7589611158cb3c27cbcf76448", size = 21169137 },
    { url = "https://files.pythonhosted.org/packages/4a/d9/32de45561811a4b87fbdee23b5797394e3d1504b4a7cf40c10199848893e/numpy-2.0.2-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:11a76c372d1d37437857280aa142086476136a8c0f373b2e648ab2c8f18fb195", size = 13703552 },
    { url = "https://files.pythonhosted.org/packages/c1/ca/2f384720020c7b244d22508cb7ab23d95f179fcfff33c31a6eeba8d6c512/numpy-2.0.2-cp311-cp311-macosx_14_0_arm64.whl", hash = "sha256:807ec44583fd708a21d4a11d94aedf2f4f3c3719035c76a2bbe1fe8e217bdc57", size = 5298957 },
    { url = "https://files.pythonhosted.org/packages/0e/78/a3e4f9fb6aa4e6fdca0c5428e8ba039408514388cf62d89651aade838269/numpy-2.0.2-cp311-cp311-macosx_14_0_x86_64.whl", hash = "sha256:8cafab480740e22f8d833acefed5cc87ce276f4ece12fdaa2e8903db2f82897a", size = 6905573 },
    { url = "https://files.pythonhosted.org/packages/a0/72/cfc3a1beb2caf4efc9d0b38a15fe34025230da27e1c08cc2eb9bfb1c7231/numpy-2.0.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a15f476a45e6e5a3a79d8a14e62161d27ad897381fecfa4a09ed5322f2085669", size = 13914330 },
    { url = "https://files.pythonhosted.org/packages/ba/a8/c17acf65a931ce551fee11b72e8de63bf7e8a6f0e21add4c937c83563538/numpy-2.0.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:13e689d772146140a252c3a28501da66dfecd77490b498b168b501835041f951", size = 19534895 },
    { url = "https://files.pythonhosted.org/packages/ba/86/8767f3d54f6ae0165749f84648da9dcc8cd78ab65d415494962c86fac80f/numpy-2.0.2-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:9ea91dfb7c3d1c56a0e55657c0afb38cf1eeae4544c208dc465c3c9f3a7c09f9", size = 19937253 },
    { url = "https://files.pythonhosted.org/packages/df/87/f76450e6e1c14e5bb1eae6836478b1028e096fd02e85c1c37674606ab752/numpy-2.0.2-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:c1c9307701fec8f3f7a1e6711f9089c06e6284b3afbbcd259f7791282d660a15", size = 14414074 },
    { url = "https://files.pythonhosted.org/packages/5c/ca/0f0f328e1e59f73754f06e1adfb909de43726d4f24c6a3f8805f34f2b0fa/numpy-2.0.2-cp311-cp311-win32.whl", hash = "sha256:a392a68bd329eafac5817e5aefeb39038c48b671afd242710b451e76090e81f4", size = 6470640 },
    { url = "https://files.pythonhosted.org/packages/eb/57/3a3f14d3a759dcf9bf6e9eda905794726b758819df4663f217d658a58695/numpy-2.0.2-cp311-cp311-win_amd64.whl", hash = "sha256:286cd40ce2b7d652a6f22efdfc6d1edf879440e53e76a75955bc0c826c7e64dc", size = 15910230 },
    { url = "https://files.pythonhosted.org/packages/45/40/2e117be60ec50d98fa08c2f8c48e09b3edea93cfcabd5a9ff6925d54b1c2/numpy-2.0.2-cp312-cp312-macosx_10_9_x86_64.whl", hash = "sha256:df55d490dea7934f330006d0f81e8551ba6010a5bf035a249ef61a94f21c500b", size = 20895803 },
    { url = "https://files.pythonhosted.org/packages/46/92/1b8b8dee833f53cef3e0a3f69b2374467789e0bb7399689582314df02651/numpy-2.0.2-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:8df823f570d9adf0978347d1f926b2a867d5608f434a7cff7f7908c6570dcf5e", size = 13471835 },
    { url = "https://files.pythonhosted.org/packages/7f/19/e2793bde475f1edaea6945be141aef6c8b4c669b90c90a300a8954d08f0a/numpy-2.0.2-cp312-cp312-macosx_14_0_arm64.whl", hash = "sha256:9a92ae5c14811e390f3767053ff54eaee3bf84576d99a2456391401323f4ec2c", size = 5038499 },
    { url = "https://files.pythonhosted.org/packages/e3/ff/ddf6dac2ff0dd50a7327bcdba45cb0264d0e96bb44d33324853f781a8f3c/numpy-2.0.2-cp312-cp312-macosx_14_0_x86_64.whl", hash = "sha256:a842d573724391493a97a62ebbb8e731f8a5dcc5d285dfc99141ca15a3302d0c", size = 6633497 },
    { url = "https://files.pythonhosted.org/packages/72/21/67f36eac8e2d2cd652a2e69595a54128297cdcb1ff3931cfc87838874bd4/numpy-2.0.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:c05e238064fc0610c840d1cf6a13bf63d7e391717d247f1bf0318172e759e692", size = 13621158 },
    { url = "https://files.pythonhosted.org/packages/39/68/e9f1126d757653496dbc096cb429014347a36b228f5a991dae2c6b6cfd40/numpy-2.0.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:0123ffdaa88fa4ab64835dcbde75dcdf89c453c922f18dced6e27c90d1d0ec5a", size = 19236173 },
    { url = "https://files.pythonhosted.org/packages/d1/e9/1f5333281e4ebf483ba1c888b1d61ba7e78d7e910fdd8e6499667041cc35/numpy-2.0.2-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:96a55f64139912d61de9137f11bf39a55ec8faec288c75a54f93dfd39f7eb40c", size = 19634174 },
    { url = "https://files.pythonhosted.org/packages/71/af/a469674070c8d8408384e3012e064299f7a2de540738a8e414dcfd639996/numpy-2.0.2-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:ec9852fb39354b5a45a80bdab5ac02dd02b15f44b3804e9f00c556bf24b4bded", size = 14099701 },
    { url = "https://files.pythonhosted.org/packages/d0/3d/08ea9f239d0e0e939b6ca52ad403c84a2bce1bde301a8eb4888c1c1543f1/numpy-2.0.2-cp312-cp312-win32.whl", hash = "sha256:671bec6496f83202ed2d3c8fdc486a8fc86942f2e69ff0e986140339a63bcbe5", size = 6174313 },
    { url = "https://files.pythonhosted.org/packages/b2/b5/4ac39baebf1fdb2e72585c8352c56d063b6126be9fc95bd2bb5ef5770c20/numpy-2.0.2-cp312-cp312-win_amd64.whl", hash = "sha256:cfd41e13fdc257aa5778496b8caa5e856dc4896d4ccf01841daee1d96465467a", size = 15606179 },
    { url = "https://files.pythonhosted.org/packages/43/c1/41c8f6df3162b0c6ffd4437d729115704bd43363de0090c7f913cfbc2d89/numpy-2.0.2-cp39-cp39-macosx_10_9_x86_64.whl", hash = "sha256:9059e10581ce4093f735ed23f3b9d283b9d517ff46009ddd485f1747eb22653c", size = 21169942 },
    { url = "https://files.pythonhosted.org/packages/39/bc/fd298f308dcd232b56a4031fd6ddf11c43f9917fbc937e53762f7b5a3bb1/numpy-2.0.2-cp39-cp39-macosx_11_0_arm64.whl", hash = "sha256:423e89b23490805d2a5a96fe40ec507407b8ee786d66f7328be214f9679df6dd", size = 13711512 },
    { url = "https://files.pythonhosted.org/packages/96/ff/06d1aa3eeb1c614eda245c1ba4fb88c483bee6520d361641331872ac4b82/numpy-2.0.2-cp39-cp39-macosx_14_0_arm64.whl", hash = "sha256:2b2955fa6f11907cf7a70dab0d0755159bca87755e831e47932367fc8f2f2d0b", size = 5306976 },
    { url = "https://files.pythonhosted.org/packages/2d/98/121996dcfb10a6087a05e54453e28e58694a7db62c5a5a29cee14c6e047b/numpy-2.0.2-cp39-cp39-macosx_14_0_x86_64.whl", hash = "sha256:97032a27bd9d8988b9a97a8c4d2c9f2c15a81f61e2f21404d7e8ef00cb5be729", size = 6906494 },
    { url = "https://files.pythonhosted.org/packages/15/31/9dffc70da6b9bbf7968f6551967fc21156207366272c2a40b4ed6008dc9b/numpy-2.0.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:1e795a8be3ddbac43274f18588329c72939870a16cae810c2b73461c40718ab1", size = 13912596 },
    { url = "https://files.pythonhosted.org/packages/b9/14/78635daab4b07c0930c919d451b8bf8c164774e6a3413aed04a6d95758ce/numpy-2.0.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:f26b258c385842546006213344c50655ff1555a9338e2e5e02a0756dc3e803dd", size = 19526099 },
    { url = "https://files.pythonhosted.org/packages/26/4c/0eeca4614003077f68bfe7aac8b7496f04221865b3a5e7cb230c9d055afd/numpy-2.0.2-cp39-cp39-musllinux_1_1_x86_64.whl", hash = "sha256:5fec9451a7789926bcf7c2b8d187292c9f93ea30284802a0ab3f5be8ab36865d", size = 19932823 },
    { url = "https://files.pythonhosted.org/packages/f1/46/ea25b98b13dccaebddf1a803f8c748680d972e00507cd9bc6dcdb5aa2ac1/numpy-2.0.2-cp39-cp39-musllinux_1_2_aarch64.whl", hash = "sha256:9189427407d88ff25ecf8f12469d4d39d35bee1db5d39fc5c168c6f088a6956d", size = 14404424 },
    { url = "https://files.pythonhosted.org/packages/c8/a6/177dd88d95ecf07e722d21008b1b40e681a929eb9e329684d449c36586b2/numpy-2.0.2-cp39-cp39-win32.whl", hash = "sha256:905d16e0c60200656500c95b6b8dca5d109e23cb24abc701d41c02d74c6b3afa", size = 6476809 },
    { url = "https://files.pythonhosted.org/packages/ea/2b/7fc9f4e7ae5b507c1a3a21f0f15ed03e794c1242ea8a242ac158beb56034/numpy-2.0.2-cp39-cp39-win_amd64.whl", hash = "sha256:a3f4ab0caa7f053f6797fcd4e1e25caee367db3112ef2b6ef82d749530768c73", size = 15911314 },
    { url = "https://files.pythonhosted.org/packages/8f/3b/df5a870ac6a3be3a86856ce195ef42eec7ae50d2a202be1f5a4b3b340e14/numpy-2.0.2-pp39-pypy39_pp73-macosx_10_9_x86_64.whl", hash = "sha256:7f0a0c6f12e07fa94133c8a67404322845220c06a9e80e85999afe727f7438b8", size = 21025288 },
    { url = "https://files.pythonhosted.org/packages/2c/97/51af92f18d6f6f2d9ad8b482a99fb74e142d71372da5d834b3a2747a446e/numpy-2.0.2-pp39-pypy39_pp73-macosx_14_0_x86_64.whl", hash = "sha256:312950fdd060354350ed123c0e25a71327d3711584beaef30cdaa93320c392d4", size = 6762793 },
    { url = "https://files.pythonhosted.org/packages/12/46/de1fbd0c1b5ccaa7f9a005b66761533e2f6a3e560096682683a223631fe9/numpy-2.0.2-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:26df23238872200f63518dd2aa984cfca675d82469535dc7162dc2ee52d9dd5c", size = 19334885 },
    { url = "https://files.pythonhosted.org/packages/cc/dc/d330a6faefd92b446ec0f0dfea4c3207bb1fef3c4771d19cf4543efd2c78/numpy-2.0.2-pp39-pypy39_pp73-win_amd64.whl", hash = "sha256:a46288ec55ebbd58947d31d72be2c63cbf839f0a63b49cb755022310792a3385", size = 15828784 },
]

[[package]]
name = "numpy"
version = "2.2.6"
source = { registry = "https://pypi.org/simple" }
resolution-markers = [
    "python_full_version == '3.10.*'",
]
sdist = { url = "https://files.pythonhosted.org/packages/76/21/7d2a95e4bba9dc13d043ee156a356c0a8f0c6309dff6b21b4d71a073b8a8/numpy-2.2.6.tar.gz", hash = "sha256:e29554e2bef54a90aa5cc07da6ce955accb83f21ab5de01a62c8478897b264fd", size = 20276440 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/9a/3e/ed6db5be21ce87955c0cbd3009f2803f59fa08df21b5df06862e2d8e2bdd/numpy-2.2.6-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:b412caa66f72040e6d268491a59f2c43bf03eb6c96dd8f0307829feb7fa2b6fb", size = 21165245 },
    { url = "https://files.pythonhosted.org/packages/22/c2/4b9221495b2a132cc9d2eb862e21d42a009f5a60e45fc44b00118c174bff/numpy-2.2.6-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:8e41fd67c52b86603a91c1a505ebaef50b3314de0213461c7a6e99c9a3beff90", size = 14360048 },
    { url = "https://files.pythonhosted.org/packages/fd/77/dc2fcfc66943c6410e2bf598062f5959372735ffda175b39906d54f02349/numpy-2.2.6-cp310-cp310-macosx_14_0_arm64.whl", hash = "sha256:37e990a01ae6ec7fe7fa1c26c55ecb672dd98b19c3d0e1d1f326fa13cb38d163", size = 5340542 },
    { url = "https://files.pythonhosted.org/packages/7a/4f/1cb5fdc353a5f5cc7feb692db9b8ec2c3d6405453f982435efc52561df58/numpy-2.2.6-cp310-cp310-macosx_14_0_x86_64.whl", hash = "sha256:5a6429d4be8ca66d889b7cf70f536a397dc45ba6faeb5f8c5427935d9592e9cf", size = 6878301 },
    { url = "https://files.pythonhosted.org/packages/eb/17/96a3acd228cec142fcb8723bd3cc39c2a474f7dcf0a5d16731980bcafa95/numpy-2.2.6-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:efd28d4e9cd7d7a8d39074a4d44c63eda73401580c5c76acda2ce969e0a38e83", size = 14297320 },
    { url = "https://files.pythonhosted.org/packages/b4/63/3de6a34ad7ad6646ac7d2f55ebc6ad439dbbf9c4370017c50cf403fb19b5/numpy-2.2.6-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:fc7b73d02efb0e18c000e9ad8b83480dfcd5dfd11065997ed4c6747470ae8915", size = 16801050 },
    { url = "https://files.pythonhosted.org/packages/07/b6/89d837eddef52b3d0cec5c6ba0456c1bf1b9ef6a6672fc2b7873c3ec4e2e/numpy-2.2.6-cp310-cp310-musllinux_1_2_aarch64.whl", hash = "sha256:74d4531beb257d2c3f4b261bfb0fc09e0f9ebb8842d82a7b4209415896adc680", size = 15807034 },
    { url = "https://files.pythonhosted.org/packages/01/c8/dc6ae86e3c61cfec1f178e5c9f7858584049b6093f843bca541f94120920/numpy-2.2.6-cp310-cp310-musllinux_1_2_x86_64.whl", hash = "sha256:8fc377d995680230e83241d8a96def29f204b5782f371c532579b4f20607a289", size = 18614185 },
    { url = "https://files.pythonhosted.org/packages/5b/c5/0064b1b7e7c89137b471ccec1fd2282fceaae0ab3a9550f2568782d80357/numpy-2.2.6-cp310-cp310-win32.whl", hash = "sha256:b093dd74e50a8cba3e873868d9e93a85b78e0daf2e98c6797566ad8044e8363d", size = 6527149 },
    { url = "https://files.pythonhosted.org/packages/a3/dd/4b822569d6b96c39d1215dbae0582fd99954dcbcf0c1a13c61783feaca3f/numpy-2.2.6-cp310-cp310-win_amd64.whl", hash = "sha256:f0fd6321b839904e15c46e0d257fdd101dd7f530fe03fd6359c1ea63738703f3", size = 12904620 },
    { url = "https://files.pythonhosted.org/packages/da/a8/4f83e2aa666a9fbf56d6118faaaf5f1974d456b1823fda0a176eff722839/numpy-2.2.6-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:f9f1adb22318e121c5c69a09142811a201ef17ab257a1e66ca3025065b7f53ae", size = 21176963 },
    { url = "https://files.pythonhosted.org/packages/b3/2b/64e1affc7972decb74c9e29e5649fac940514910960ba25cd9af4488b66c/numpy-2.2.6-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:c820a93b0255bc360f53eca31a0e676fd1101f673dda8da93454a12e23fc5f7a", size = 14406743 },
    { url = "https://files.pythonhosted.org/packages/4a/9f/0121e375000b5e50ffdd8b25bf78d8e1a5aa4cca3f185d41265198c7b834/numpy-2.2.6-cp311-cp311-macosx_14_0_arm64.whl", hash = "sha256:3d70692235e759f260c3d837193090014aebdf026dfd167834bcba43e30c2a42", size = 5352616 },
    { url = "https://files.pythonhosted.org/packages/31/0d/b48c405c91693635fbe2dcd7bc84a33a602add5f63286e024d3b6741411c/numpy-2.2.6-cp311-cp311-macosx_14_0_x86_64.whl", hash = "sha256:481b49095335f8eed42e39e8041327c05b0f6f4780488f61286ed3c01368d491", size = 6889579 },
    { url = "https://files.pythonhosted.org/packages/52/b8/7f0554d49b565d0171eab6e99001846882000883998e7b7d9f0d98b1f934/numpy-2.2.6-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:b64d8d4d17135e00c8e346e0a738deb17e754230d7e0810ac5012750bbd85a5a", size = 14312005 },
    { url = "https://files.pythonhosted.org/packages/b3/dd/2238b898e51bd6d389b7389ffb20d7f4c10066d80351187ec8e303a5a475/numpy-2.2.6-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:ba10f8411898fc418a521833e014a77d3ca01c15b0c6cdcce6a0d2897e6dbbdf", size = 16821570 },
    { url = "https://files.pythonhosted.org/packages/83/6c/44d0325722cf644f191042bf47eedad61c1e6df2432ed65cbe28509d404e/numpy-2.2.6-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:bd48227a919f1bafbdda0583705e547892342c26fb127219d60a5c36882609d1", size = 15818548 },
    { url = "https://files.pythonhosted.org/packages/ae/9d/81e8216030ce66be25279098789b665d49ff19eef08bfa8cb96d4957f422/numpy-2.2.6-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:9551a499bf125c1d4f9e250377c1ee2eddd02e01eac6644c080162c0c51778ab", size = 18620521 },
    { url = "https://files.pythonhosted.org/packages/6a/fd/e19617b9530b031db51b0926eed5345ce8ddc669bb3bc0044b23e275ebe8/numpy-2.2.6-cp311-cp311-win32.whl", hash = "sha256:0678000bb9ac1475cd454c6b8c799206af8107e310843532b04d49649c717a47", size = 6525866 },
    { url = "https://files.pythonhosted.org/packages/31/0a/f354fb7176b81747d870f7991dc763e157a934c717b67b58456bc63da3df/numpy-2.2.6-cp311-cp311-win_amd64.whl", hash = "sha256:e8213002e427c69c45a52bbd94163084025f533a55a59d6f9c5b820774ef3303", size = 12907455 },
    { url = "https://files.pythonhosted.org/packages/82/5d/c00588b6cf18e1da539b45d3598d3557084990dcc4331960c15ee776ee41/numpy-2.2.6-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:41c5a21f4a04fa86436124d388f6ed60a9343a6f767fced1a8a71c3fbca038ff", size = 20875348 },
    { url = "https://files.pythonhosted.org/packages/66/ee/560deadcdde6c2f90200450d5938f63a34b37e27ebff162810f716f6a230/numpy-2.2.6-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:de749064336d37e340f640b05f24e9e3dd678c57318c7289d222a8a2f543e90c", size = 14119362 },
    { url = "https://files.pythonhosted.org/packages/3c/65/4baa99f1c53b30adf0acd9a5519078871ddde8d2339dc5a7fde80d9d87da/numpy-2.2.6-cp312-cp312-macosx_14_0_arm64.whl", hash = "sha256:894b3a42502226a1cac872f840030665f33326fc3dac8e57c607905773cdcde3", size = 5084103 },
    { url = "https://files.pythonhosted.org/packages/cc/89/e5a34c071a0570cc40c9a54eb472d113eea6d002e9ae12bb3a8407fb912e/numpy-2.2.6-cp312-cp312-macosx_14_0_x86_64.whl", hash = "sha256:71594f7c51a18e728451bb50cc60a3ce4e6538822731b2933209a1f3614e9282", size = 6625382 },
    { url = "https://files.pythonhosted.org/packages/f8/35/8c80729f1ff76b3921d5c9487c7ac3de9b2a103b1cd05e905b3090513510/numpy-2.2.6-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:f2618db89be1b4e05f7a1a847a9c1c0abd63e63a1607d892dd54668dd92faf87", size = 14018462 },
    { url = "https://files.pythonhosted.org/packages/8c/3d/1e1db36cfd41f895d266b103df00ca5b3cbe965184df824dec5c08c6b803/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:fd83c01228a688733f1ded5201c678f0c53ecc1006ffbc404db9f7a899ac6249", size = 16527618 },
    { url = "https://files.pythonhosted.org/packages/61/c6/03ed30992602c85aa3cd95b9070a514f8b3c33e31124694438d88809ae36/numpy-2.2.6-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:37c0ca431f82cd5fa716eca9506aefcabc247fb27ba69c5062a6d3ade8cf8f49", size = 15505511 },
    { url = "https://files.pythonhosted.org/packages/b7/25/5761d832a81df431e260719ec45de696414266613c9ee268394dd5ad8236/numpy-2.2.6-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:fe27749d33bb772c80dcd84ae7e8df2adc920ae8297400dabec45f0dedb3f6de", size = 18313783 },
    { url = "https://files.pythonhosted.org/packages/57/0a/72d5a3527c5ebffcd47bde9162c39fae1f90138c961e5296491ce778e682/numpy-2.2.6-cp312-cp312-win32.whl", hash = "sha256:4eeaae00d789f66c7a25ac5f34b71a7035bb474e679f410e5e1a94deb24cf2d4", size = 6246506 },
    { url = "https://files.pythonhosted.org/packages/36/fa/8c9210162ca1b88529ab76b41ba02d433fd54fecaf6feb70ef9f124683f1/numpy-2.2.6-cp312-cp312-win_amd64.whl", hash = "sha256:c1f9540be57940698ed329904db803cf7a402f3fc200bfe599334c9bd84a40b2", size = 12614190 },
    { url = "https://files.pythonhosted.org/packages/f9/5c/6657823f4f594f72b5471f1db1ab12e26e890bb2e41897522d134d2a3e81/numpy-2.2.6-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:0811bb762109d9708cca4d0b13c4f67146e3c3b7cf8d34018c722adb2d957c84", size = 20867828 },
    { url = "https://files.pythonhosted.org/packages/dc/9e/14520dc3dadf3c803473bd07e9b2bd1b69bc583cb2497b47000fed2fa92f/numpy-2.2.6-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:287cc3162b6f01463ccd86be154f284d0893d2b3ed7292439ea97eafa8170e0b", size = 14143006 },
    { url = "https://files.pythonhosted.org/packages/4f/06/7e96c57d90bebdce9918412087fc22ca9851cceaf5567a45c1f404480e9e/numpy-2.2.6-cp313-cp313-macosx_14_0_arm64.whl", hash = "sha256:f1372f041402e37e5e633e586f62aa53de2eac8d98cbfb822806ce4bbefcb74d", size = 5076765 },
    { url = "https://files.pythonhosted.org/packages/73/ed/63d920c23b4289fdac96ddbdd6132e9427790977d5457cd132f18e76eae0/numpy-2.2.6-cp313-cp313-macosx_14_0_x86_64.whl", hash = "sha256:55a4d33fa519660d69614a9fad433be87e5252f4b03850642f88993f7b2ca566", size = 6617736 },
    { url = "https://files.pythonhosted.org/packages/85/c5/e19c8f99d83fd377ec8c7e0cf627a8049746da54afc24ef0a0cb73d5dfb5/numpy-2.2.6-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:f92729c95468a2f4f15e9bb94c432a9229d0d50de67304399627a943201baa2f", size = 14010719 },
    { url = "https://files.pythonhosted.org/packages/19/49/4df9123aafa7b539317bf6d342cb6d227e49f7a35b99c287a6109b13dd93/numpy-2.2.6-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:1bc23a79bfabc5d056d106f9befb8d50c31ced2fbc70eedb8155aec74a45798f", size = 16526072 },
    { url = "https://files.pythonhosted.org/packages/b2/6c/04b5f47f4f32f7c2b0e7260442a8cbcf8168b0e1a41ff1495da42f42a14f/numpy-2.2.6-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:e3143e4451880bed956e706a3220b4e5cf6172ef05fcc397f6f36a550b1dd868", size = 15503213 },
    { url = "https://files.pythonhosted.org/packages/17/0a/5cd92e352c1307640d5b6fec1b2ffb06cd0dabe7d7b8227f97933d378422/numpy-2.2.6-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:b4f13750ce79751586ae2eb824ba7e1e8dba64784086c98cdbbcc6a42112ce0d", size = 18316632 },
    { url = "https://files.pythonhosted.org/packages/f0/3b/5cba2b1d88760ef86596ad0f3d484b1cbff7c115ae2429678465057c5155/numpy-2.2.6-cp313-cp313-win32.whl", hash = "sha256:5beb72339d9d4fa36522fc63802f469b13cdbe4fdab4a288f0c441b74272ebfd", size = 6244532 },
    { url = "https://files.pythonhosted.org/packages/cb/3b/d58c12eafcb298d4e6d0d40216866ab15f59e55d148a5658bb3132311fcf/numpy-2.2.6-cp313-cp313-win_amd64.whl", hash = "sha256:b0544343a702fa80c95ad5d3d608ea3599dd54d4632df855e4c8d24eb6ecfa1c", size = 12610885 },
    { url = "https://files.pythonhosted.org/packages/6b/9e/4bf918b818e516322db999ac25d00c75788ddfd2d2ade4fa66f1f38097e1/numpy-2.2.6-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:0bca768cd85ae743b2affdc762d617eddf3bcf8724435498a1e80132d04879e6", size = 20963467 },
    { url = "https://files.pythonhosted.org/packages/61/66/d2de6b291507517ff2e438e13ff7b1e2cdbdb7cb40b3ed475377aece69f9/numpy-2.2.6-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:fc0c5673685c508a142ca65209b4e79ed6740a4ed6b2267dbba90f34b0b3cfda", size = 14225144 },
    { url = "https://files.pythonhosted.org/packages/e4/25/480387655407ead912e28ba3a820bc69af9adf13bcbe40b299d454ec011f/numpy-2.2.6-cp313-cp313t-macosx_14_0_arm64.whl", hash = "sha256:5bd4fc3ac8926b3819797a7c0e2631eb889b4118a9898c84f585a54d475b7e40", size = 5200217 },
    { url = "https://files.pythonhosted.org/packages/aa/4a/6e313b5108f53dcbf3aca0c0f3e9c92f4c10ce57a0a721851f9785872895/numpy-2.2.6-cp313-cp313t-macosx_14_0_x86_64.whl", hash = "sha256:fee4236c876c4e8369388054d02d0e9bb84821feb1a64dd59e137e6511a551f8", size = 6712014 },
    { url = "https://files.pythonhosted.org/packages/b7/30/172c2d5c4be71fdf476e9de553443cf8e25feddbe185e0bd88b096915bcc/numpy-2.2.6-cp313-cp313t-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:e1dda9c7e08dc141e0247a5b8f49cf05984955246a327d4c48bda16821947b2f", size = 14077935 },
    { url = "https://files.pythonhosted.org/packages/12/fb/9e743f8d4e4d3c710902cf87af3512082ae3d43b945d5d16563f26ec251d/numpy-2.2.6-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:f447e6acb680fd307f40d3da4852208af94afdfab89cf850986c3ca00562f4fa", size = 16600122 },
    { url = "https://files.pythonhosted.org/packages/12/75/ee20da0e58d3a66f204f38916757e01e33a9737d0b22373b3eb5a27358f9/numpy-2.2.6-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:389d771b1623ec92636b0786bc4ae56abafad4a4c513d36a55dce14bd9ce8571", size = 15586143 },
    { url = "https://files.pythonhosted.org/packages/76/95/bef5b37f29fc5e739947e9ce5179ad402875633308504a52d188302319c8/numpy-2.2.6-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:8e9ace4a37db23421249ed236fdcdd457d671e25146786dfc96835cd951aa7c1", size = 18385260 },
    { url = "https://files.pythonhosted.org/packages/09/04/f2f83279d287407cf36a7a8053a5abe7be3622a4363337338f2585e4afda/numpy-2.2.6-cp313-cp313t-win32.whl", hash = "sha256:038613e9fb8c72b0a41f025a7e4c3f0b7a1b5d768ece4796b674c8f3fe13efff", size = 6377225 },
    { url = "https://files.pythonhosted.org/packages/67/0e/35082d13c09c02c011cf21570543d202ad929d961c02a147493cb0c2bdf5/numpy-2.2.6-cp313-cp313t-win_amd64.whl", hash = "sha256:6031dd6dfecc0cf9f668681a37648373bddd6421fff6c66ec1624eed0180ee06", size = 12771374 },
    { url = "https://files.pythonhosted.org/packages/9e/3b/d94a75f4dbf1ef5d321523ecac21ef23a3cd2ac8b78ae2aac40873590229/numpy-2.2.6-pp310-pypy310_pp73-macosx_10_15_x86_64.whl", hash = "sha256:0b605b275d7bd0c640cad4e5d30fa701a8d59302e127e5f79138ad62762c3e3d", size = 21040391 },
    { url = "https://files.pythonhosted.org/packages/17/f4/09b2fa1b58f0fb4f7c7963a1649c64c4d315752240377ed74d9cd878f7b5/numpy-2.2.6-pp310-pypy310_pp73-macosx_14_0_x86_64.whl", hash = "sha256:7befc596a7dc9da8a337f79802ee8adb30a552a94f792b9c9d18c840055907db", size = 6786754 },
    { url = "https://files.pythonhosted.org/packages/af/30/feba75f143bdc868a1cc3f44ccfa6c4b9ec522b36458e738cd00f67b573f/numpy-2.2.6-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:ce47521a4754c8f4593837384bd3424880629f718d87c5d44f8ed763edd63543", size = 16643476 },
    { url = "https://files.pythonhosted.org/packages/37/48/ac2a9584402fb6c0cd5b5d1a91dcf176b15760130dd386bbafdbfe3640bf/numpy-2.2.6-pp310-pypy310_pp73-win_amd64.whl", hash = "sha256:d042d24c90c41b54fd506da306759e06e568864df8ec17ccc17e9e884634fd00", size = 12812666 },
]

[[package]]
name = "numpy"
version = "2.3.1"
source = { registry = "https://pypi.org/simple" }
resolution-markers = [
    "python_full_version >= '3.11'",
]
sdist = { url = "https://files.pythonhosted.org/packages/2e/19/d7c972dfe90a353dbd3efbbe1d14a5951de80c99c9dc1b93cd998d51dc0f/numpy-2.3.1.tar.gz", hash = "sha256:1ec9ae20a4226da374362cca3c62cd753faf2f951440b0e3b98e93c235441d2b", size = 20390372 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b0/c7/87c64d7ab426156530676000c94784ef55676df2f13b2796f97722464124/numpy-2.3.1-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:6ea9e48336a402551f52cd8f593343699003d2353daa4b72ce8d34f66b722070", size = 21199346 },
    { url = "https://files.pythonhosted.org/packages/58/0e/0966c2f44beeac12af8d836e5b5f826a407cf34c45cb73ddcdfce9f5960b/numpy-2.3.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:5ccb7336eaf0e77c1635b232c141846493a588ec9ea777a7c24d7166bb8533ae", size = 14361143 },
    { url = "https://files.pythonhosted.org/packages/7d/31/6e35a247acb1bfc19226791dfc7d4c30002cd4e620e11e58b0ddf836fe52/numpy-2.3.1-cp311-cp311-macosx_14_0_arm64.whl", hash = "sha256:0bb3a4a61e1d327e035275d2a993c96fa786e4913aa089843e6a2d9dd205c66a", size = 5378989 },
    { url = "https://files.pythonhosted.org/packages/b0/25/93b621219bb6f5a2d4e713a824522c69ab1f06a57cd571cda70e2e31af44/numpy-2.3.1-cp311-cp311-macosx_14_0_x86_64.whl", hash = "sha256:e344eb79dab01f1e838ebb67aab09965fb271d6da6b00adda26328ac27d4a66e", size = 6912890 },
    { url = "https://files.pythonhosted.org/packages/ef/60/6b06ed98d11fb32e27fb59468b42383f3877146d3ee639f733776b6ac596/numpy-2.3.1-cp311-cp311-manylinux_2_28_aarch64.whl", hash = "sha256:467db865b392168ceb1ef1ffa6f5a86e62468c43e0cfb4ab6da667ede10e58db", size = 14569032 },
    { url = "https://files.pythonhosted.org/packages/75/c9/9bec03675192077467a9c7c2bdd1f2e922bd01d3a69b15c3a0fdcd8548f6/numpy-2.3.1-cp311-cp311-manylinux_2_28_x86_64.whl", hash = "sha256:afed2ce4a84f6b0fc6c1ce734ff368cbf5a5e24e8954a338f3bdffa0718adffb", size = 16930354 },
    { url = "https://files.pythonhosted.org/packages/6a/e2/5756a00cabcf50a3f527a0c968b2b4881c62b1379223931853114fa04cda/numpy-2.3.1-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:0025048b3c1557a20bc80d06fdeb8cc7fc193721484cca82b2cfa072fec71a93", size = 15879605 },
    { url = "https://files.pythonhosted.org/packages/ff/86/a471f65f0a86f1ca62dcc90b9fa46174dd48f50214e5446bc16a775646c5/numpy-2.3.1-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:a5ee121b60aa509679b682819c602579e1df14a5b07fe95671c8849aad8f2115", size = 18666994 },
    { url = "https://files.pythonhosted.org/packages/43/a6/482a53e469b32be6500aaf61cfafd1de7a0b0d484babf679209c3298852e/numpy-2.3.1-cp311-cp311-win32.whl", hash = "sha256:a8b740f5579ae4585831b3cf0e3b0425c667274f82a484866d2adf9570539369", size = 6603672 },
    { url = "https://files.pythonhosted.org/packages/6b/fb/bb613f4122c310a13ec67585c70e14b03bfc7ebabd24f4d5138b97371d7c/numpy-2.3.1-cp311-cp311-win_amd64.whl", hash = "sha256:d4580adadc53311b163444f877e0789f1c8861e2698f6b2a4ca852fda154f3ff", size = 13024015 },
    { url = "https://files.pythonhosted.org/packages/51/58/2d842825af9a0c041aca246dc92eb725e1bc5e1c9ac89712625db0c4e11c/numpy-2.3.1-cp311-cp311-win_arm64.whl", hash = "sha256:ec0bdafa906f95adc9a0c6f26a4871fa753f25caaa0e032578a30457bff0af6a", size = 10456989 },
    { url = "https://files.pythonhosted.org/packages/c6/56/71ad5022e2f63cfe0ca93559403d0edef14aea70a841d640bd13cdba578e/numpy-2.3.1-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:2959d8f268f3d8ee402b04a9ec4bb7604555aeacf78b360dc4ec27f1d508177d", size = 20896664 },
    { url = "https://files.pythonhosted.org/packages/25/65/2db52ba049813670f7f987cc5db6dac9be7cd95e923cc6832b3d32d87cef/numpy-2.3.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:762e0c0c6b56bdedfef9a8e1d4538556438288c4276901ea008ae44091954e29", size = 14131078 },
    { url = "https://files.pythonhosted.org/packages/57/dd/28fa3c17b0e751047ac928c1e1b6990238faad76e9b147e585b573d9d1bd/numpy-2.3.1-cp312-cp312-macosx_14_0_arm64.whl", hash = "sha256:867ef172a0976aaa1f1d1b63cf2090de8b636a7674607d514505fb7276ab08fc", size = 5112554 },
    { url = "https://files.pythonhosted.org/packages/c9/fc/84ea0cba8e760c4644b708b6819d91784c290288c27aca916115e3311d17/numpy-2.3.1-cp312-cp312-macosx_14_0_x86_64.whl", hash = "sha256:4e602e1b8682c2b833af89ba641ad4176053aaa50f5cacda1a27004352dde943", size = 6646560 },
    { url = "https://files.pythonhosted.org/packages/61/b2/512b0c2ddec985ad1e496b0bd853eeb572315c0f07cd6997473ced8f15e2/numpy-2.3.1-cp312-cp312-manylinux_2_28_aarch64.whl", hash = "sha256:8e333040d069eba1652fb08962ec5b76af7f2c7bce1df7e1418c8055cf776f25", size = 14260638 },
    { url = "https://files.pythonhosted.org/packages/6e/45/c51cb248e679a6c6ab14b7a8e3ead3f4a3fe7425fc7a6f98b3f147bec532/numpy-2.3.1-cp312-cp312-manylinux_2_28_x86_64.whl", hash = "sha256:e7cbf5a5eafd8d230a3ce356d892512185230e4781a361229bd902ff403bc660", size = 16632729 },
    { url = "https://files.pythonhosted.org/packages/e4/ff/feb4be2e5c09a3da161b412019caf47183099cbea1132fd98061808c2df2/numpy-2.3.1-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:5f1b8f26d1086835f442286c1d9b64bb3974b0b1e41bb105358fd07d20872952", size = 15565330 },
    { url = "https://files.pythonhosted.org/packages/bc/6d/ceafe87587101e9ab0d370e4f6e5f3f3a85b9a697f2318738e5e7e176ce3/numpy-2.3.1-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:ee8340cb48c9b7a5899d1149eece41ca535513a9698098edbade2a8e7a84da77", size = 18361734 },
    { url = "https://files.pythonhosted.org/packages/2b/19/0fb49a3ea088be691f040c9bf1817e4669a339d6e98579f91859b902c636/numpy-2.3.1-cp312-cp312-win32.whl", hash = "sha256:e772dda20a6002ef7061713dc1e2585bc1b534e7909b2030b5a46dae8ff077ab", size = 6320411 },
    { url = "https://files.pythonhosted.org/packages/b1/3e/e28f4c1dd9e042eb57a3eb652f200225e311b608632bc727ae378623d4f8/numpy-2.3.1-cp312-cp312-win_amd64.whl", hash = "sha256:cfecc7822543abdea6de08758091da655ea2210b8ffa1faf116b940693d3df76", size = 12734973 },
    { url = "https://files.pythonhosted.org/packages/04/a8/8a5e9079dc722acf53522b8f8842e79541ea81835e9b5483388701421073/numpy-2.3.1-cp312-cp312-win_arm64.whl", hash = "sha256:7be91b2239af2658653c5bb6f1b8bccafaf08226a258caf78ce44710a0160d30", size = 10191491 },
    { url = "https://files.pythonhosted.org/packages/d4/bd/35ad97006d8abff8631293f8ea6adf07b0108ce6fec68da3c3fcca1197f2/numpy-2.3.1-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:25a1992b0a3fdcdaec9f552ef10d8103186f5397ab45e2d25f8ac51b1a6b97e8", size = 20889381 },
    { url = "https://files.pythonhosted.org/packages/f1/4f/df5923874d8095b6062495b39729178eef4a922119cee32a12ee1bd4664c/numpy-2.3.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:7dea630156d39b02a63c18f508f85010230409db5b2927ba59c8ba4ab3e8272e", size = 14152726 },
    { url = "https://files.pythonhosted.org/packages/8c/0f/a1f269b125806212a876f7efb049b06c6f8772cf0121139f97774cd95626/numpy-2.3.1-cp313-cp313-macosx_14_0_arm64.whl", hash = "sha256:bada6058dd886061f10ea15f230ccf7dfff40572e99fef440a4a857c8728c9c0", size = 5105145 },
    { url = "https://files.pythonhosted.org/packages/6d/63/a7f7fd5f375b0361682f6ffbf686787e82b7bbd561268e4f30afad2bb3c0/numpy-2.3.1-cp313-cp313-macosx_14_0_x86_64.whl", hash = "sha256:a894f3816eb17b29e4783e5873f92faf55b710c2519e5c351767c51f79d8526d", size = 6639409 },
    { url = "https://files.pythonhosted.org/packages/bf/0d/1854a4121af895aab383f4aa233748f1df4671ef331d898e32426756a8a6/numpy-2.3.1-cp313-cp313-manylinux_2_28_aarch64.whl", hash = "sha256:18703df6c4a4fee55fd3d6e5a253d01c5d33a295409b03fda0c86b3ca2ff41a1", size = 14257630 },
    { url = "https://files.pythonhosted.org/packages/50/30/af1b277b443f2fb08acf1c55ce9d68ee540043f158630d62cef012750f9f/numpy-2.3.1-cp313-cp313-manylinux_2_28_x86_64.whl", hash = "sha256:5902660491bd7a48b2ec16c23ccb9124b8abfd9583c5fdfa123fe6b421e03de1", size = 16627546 },
    { url = "https://files.pythonhosted.org/packages/6e/ec/3b68220c277e463095342d254c61be8144c31208db18d3fd8ef02712bcd6/numpy-2.3.1-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:36890eb9e9d2081137bd78d29050ba63b8dab95dff7912eadf1185e80074b2a0", size = 15562538 },
    { url = "https://files.pythonhosted.org/packages/77/2b/4014f2bcc4404484021c74d4c5ee8eb3de7e3f7ac75f06672f8dcf85140a/numpy-2.3.1-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:a780033466159c2270531e2b8ac063704592a0bc62ec4a1b991c7c40705eb0e8", size = 18360327 },
    { url = "https://files.pythonhosted.org/packages/40/8d/2ddd6c9b30fcf920837b8672f6c65590c7d92e43084c25fc65edc22e93ca/numpy-2.3.1-cp313-cp313-win32.whl", hash = "sha256:39bff12c076812595c3a306f22bfe49919c5513aa1e0e70fac756a0be7c2a2b8", size = 6312330 },
    { url = "https://files.pythonhosted.org/packages/dd/c8/beaba449925988d415efccb45bf977ff8327a02f655090627318f6398c7b/numpy-2.3.1-cp313-cp313-win_amd64.whl", hash = "sha256:8d5ee6eec45f08ce507a6570e06f2f879b374a552087a4179ea7838edbcbfa42", size = 12731565 },
    { url = "https://files.pythonhosted.org/packages/0b/c3/5c0c575d7ec78c1126998071f58facfc124006635da75b090805e642c62e/numpy-2.3.1-cp313-cp313-win_arm64.whl", hash = "sha256:0c4d9e0a8368db90f93bd192bfa771ace63137c3488d198ee21dfb8e7771916e", size = 10190262 },
    { url = "https://files.pythonhosted.org/packages/ea/19/a029cd335cf72f79d2644dcfc22d90f09caa86265cbbde3b5702ccef6890/numpy-2.3.1-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:b0b5397374f32ec0649dd98c652a1798192042e715df918c20672c62fb52d4b8", size = 20987593 },
    { url = "https://files.pythonhosted.org/packages/25/91/8ea8894406209107d9ce19b66314194675d31761fe2cb3c84fe2eeae2f37/numpy-2.3.1-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:c5bdf2015ccfcee8253fb8be695516ac4457c743473a43290fd36eba6a1777eb", size = 14300523 },
    { url = "https://files.pythonhosted.org/packages/a6/7f/06187b0066eefc9e7ce77d5f2ddb4e314a55220ad62dd0bfc9f2c44bac14/numpy-2.3.1-cp313-cp313t-macosx_14_0_arm64.whl", hash = "sha256:d70f20df7f08b90a2062c1f07737dd340adccf2068d0f1b9b3d56e2038979fee", size = 5227993 },
    { url = "https://files.pythonhosted.org/packages/e8/ec/a926c293c605fa75e9cfb09f1e4840098ed46d2edaa6e2152ee35dc01ed3/numpy-2.3.1-cp313-cp313t-macosx_14_0_x86_64.whl", hash = "sha256:2fb86b7e58f9ac50e1e9dd1290154107e47d1eef23a0ae9145ded06ea606f992", size = 6736652 },
    { url = "https://files.pythonhosted.org/packages/e3/62/d68e52fb6fde5586650d4c0ce0b05ff3a48ad4df4ffd1b8866479d1d671d/numpy-2.3.1-cp313-cp313t-manylinux_2_28_aarch64.whl", hash = "sha256:23ab05b2d241f76cb883ce8b9a93a680752fbfcbd51c50eff0b88b979e471d8c", size = 14331561 },
    { url = "https://files.pythonhosted.org/packages/fc/ec/b74d3f2430960044bdad6900d9f5edc2dc0fb8bf5a0be0f65287bf2cbe27/numpy-2.3.1-cp313-cp313t-manylinux_2_28_x86_64.whl", hash = "sha256:ce2ce9e5de4703a673e705183f64fd5da5bf36e7beddcb63a25ee2286e71ca48", size = 16693349 },
    { url = "https://files.pythonhosted.org/packages/0d/15/def96774b9d7eb198ddadfcbd20281b20ebb510580419197e225f5c55c3e/numpy-2.3.1-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:c4913079974eeb5c16ccfd2b1f09354b8fed7e0d6f2cab933104a09a6419b1ee", size = 15642053 },
    { url = "https://files.pythonhosted.org/packages/2b/57/c3203974762a759540c6ae71d0ea2341c1fa41d84e4971a8e76d7141678a/numpy-2.3.1-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:010ce9b4f00d5c036053ca684c77441f2f2c934fd23bee058b4d6f196efd8280", size = 18434184 },
    { url = "https://files.pythonhosted.org/packages/22/8a/ccdf201457ed8ac6245187850aff4ca56a79edbea4829f4e9f14d46fa9a5/numpy-2.3.1-cp313-cp313t-win32.whl", hash = "sha256:6269b9edfe32912584ec496d91b00b6d34282ca1d07eb10e82dfc780907d6c2e", size = 6440678 },
    { url = "https://files.pythonhosted.org/packages/f1/7e/7f431d8bd8eb7e03d79294aed238b1b0b174b3148570d03a8a8a8f6a0da9/numpy-2.3.1-cp313-cp313t-win_amd64.whl", hash = "sha256:2a809637460e88a113e186e87f228d74ae2852a2e0c44de275263376f17b5bdc", size = 12870697 },
    { url = "https://files.pythonhosted.org/packages/d4/ca/af82bf0fad4c3e573c6930ed743b5308492ff19917c7caaf2f9b6f9e2e98/numpy-2.3.1-cp313-cp313t-win_arm64.whl", hash = "sha256:eccb9a159db9aed60800187bc47a6d3451553f0e1b08b068d8b277ddfbb9b244", size = 10260376 },
    { url = "https://files.pythonhosted.org/packages/e8/34/facc13b9b42ddca30498fc51f7f73c3d0f2be179943a4b4da8686e259740/numpy-2.3.1-pp311-pypy311_pp73-macosx_10_15_x86_64.whl", hash = "sha256:ad506d4b09e684394c42c966ec1527f6ebc25da7f4da4b1b056606ffe446b8a3", size = 21070637 },
    { url = "https://files.pythonhosted.org/packages/65/b6/41b705d9dbae04649b529fc9bd3387664c3281c7cd78b404a4efe73dcc45/numpy-2.3.1-pp311-pypy311_pp73-macosx_14_0_arm64.whl", hash = "sha256:ebb8603d45bc86bbd5edb0d63e52c5fd9e7945d3a503b77e486bd88dde67a19b", size = 5304087 },
    { url = "https://files.pythonhosted.org/packages/7a/b4/fe3ac1902bff7a4934a22d49e1c9d71a623204d654d4cc43c6e8fe337fcb/numpy-2.3.1-pp311-pypy311_pp73-macosx_14_0_x86_64.whl", hash = "sha256:15aa4c392ac396e2ad3d0a2680c0f0dee420f9fed14eef09bdb9450ee6dcb7b7", size = 6817588 },
    { url = "https://files.pythonhosted.org/packages/ae/ee/89bedf69c36ace1ac8f59e97811c1f5031e179a37e4821c3a230bf750142/numpy-2.3.1-pp311-pypy311_pp73-manylinux_2_28_aarch64.whl", hash = "sha256:c6e0bf9d1a2f50d2b65a7cf56db37c095af17b59f6c132396f7c6d5dd76484df", size = 14399010 },
    { url = "https://files.pythonhosted.org/packages/15/08/e00e7070ede29b2b176165eba18d6f9784d5349be3c0c1218338e79c27fd/numpy-2.3.1-pp311-pypy311_pp73-manylinux_2_28_x86_64.whl", hash = "sha256:eabd7e8740d494ce2b4ea0ff05afa1b7b291e978c0ae075487c51e8bd93c0c68", size = 16752042 },
    { url = "https://files.pythonhosted.org/packages/48/6b/1c6b515a83d5564b1698a61efa245727c8feecf308f4091f565988519d20/numpy-2.3.1-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:e610832418a2bc09d974cc9fecebfa51e9532d6190223bc5ef6a7402ebf3b5cb", size = 12927246 },
]

[[package]]
name = "packaging"
version = "25.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a1/d4/1fc4078c65507b51b96ca8f8c3ba19e6a61c8253c72794544580a7b6c24d/packaging-25.0.tar.gz", hash = "sha256:d443872c98d677bf60f6a1f2f8c1cb748e8fe762d2bf9d3148b5599295b0fc4f", size = 165727 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/20/12/38679034af332785aac8774540895e234f4d07f7545804097de4b666afd8/packaging-25.0-py3-none-any.whl", hash = "sha256:29572ef2b1f17581046b3a2227d5c611fb25ec70ca1ba8554b24b0e69331a484", size = 66469 },
]

[[package]]
name = "paho-mqtt"
version = "2.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/39/15/0a6214e76d4d32e7f663b109cf71fb22561c2be0f701d67f93950cd40542/paho_mqtt-2.1.0.tar.gz", hash = "sha256:12d6e7511d4137555a3f6ea167ae846af2c7357b10bc6fa4f7c3968fc1723834", size = 148848 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c4/cb/00451c3cf31790287768bb12c6bec834f5d292eaf3022afc88e14b8afc94/paho_mqtt-2.1.0-py3-none-any.whl", hash = "sha256:6db9ba9b34ed5bc6b6e3812718c7e06e2fd7444540df2455d2c51bd58808feee", size = 67219 },
]

[[package]]
name = "pluggy"
version = "1.6.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f9/e2/3e91f31a7d2b083fe6ef3fa267035b518369d9511ffab804f839851d2779/pluggy-1.6.0.tar.gz", hash = "sha256:7dcc130b76258d33b90f61b658791dede3486c3e6bfb003ee5c9bfb396dd22f3", size = 69412 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/54/20/4d324d65cc6d9205fabedc306948156824eb9f0ee1633355a8f7ec5c66bf/pluggy-1.6.0-py3-none-any.whl", hash = "sha256:e920276dd6813095e9377c0bc5566d94c932c33b27a3e3945d8389c374dd4746", size = 20538 },
]

[[package]]
name = "psutil"
version = "7.0.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/2a/80/336820c1ad9286a4ded7e845b2eccfcb27851ab8ac6abece774a6ff4d3de/psutil-7.0.0.tar.gz", hash = "sha256:7be9c3eba38beccb6495ea33afd982a44074b78f28c434a1f51cc07fd315c456", size = 497003 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ed/e6/2d26234410f8b8abdbf891c9da62bee396583f713fb9f3325a4760875d22/psutil-7.0.0-cp36-abi3-macosx_10_9_x86_64.whl", hash = "sha256:101d71dc322e3cffd7cea0650b09b3d08b8e7c4109dd6809fe452dfd00e58b25", size = 238051 },
    { url = "https://files.pythonhosted.org/packages/04/8b/30f930733afe425e3cbfc0e1468a30a18942350c1a8816acfade80c005c4/psutil-7.0.0-cp36-abi3-macosx_11_0_arm64.whl", hash = "sha256:39db632f6bb862eeccf56660871433e111b6ea58f2caea825571951d4b6aa3da", size = 239535 },
    { url = "https://files.pythonhosted.org/packages/2a/ed/d362e84620dd22876b55389248e522338ed1bf134a5edd3b8231d7207f6d/psutil-7.0.0-cp36-abi3-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:1fcee592b4c6f146991ca55919ea3d1f8926497a713ed7faaf8225e174581e91", size = 275004 },
    { url = "https://files.pythonhosted.org/packages/bf/b9/b0eb3f3cbcb734d930fdf839431606844a825b23eaf9a6ab371edac8162c/psutil-7.0.0-cp36-abi3-manylinux_2_12_x86_64.manylinux2010_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:4b1388a4f6875d7e2aff5c4ca1cc16c545ed41dd8bb596cefea80111db353a34", size = 277986 },
    { url = "https://files.pythonhosted.org/packages/eb/a2/709e0fe2f093556c17fbafda93ac032257242cabcc7ff3369e2cb76a97aa/psutil-7.0.0-cp36-abi3-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a5f098451abc2828f7dc6b58d44b532b22f2088f4999a937557b603ce72b1993", size = 279544 },
    { url = "https://files.pythonhosted.org/packages/50/e6/eecf58810b9d12e6427369784efe814a1eec0f492084ce8eb8f4d89d6d61/psutil-7.0.0-cp37-abi3-win32.whl", hash = "sha256:ba3fcef7523064a6c9da440fc4d6bd07da93ac726b5733c29027d7dc95b39d99", size = 241053 },
    { url = "https://files.pythonhosted.org/packages/50/1b/6921afe68c74868b4c9fa424dad3be35b095e16687989ebbb50ce4fceb7c/psutil-7.0.0-cp37-abi3-win_amd64.whl", hash = "sha256:4cf3d4eb1aa9b348dec30105c55cd9b7d4629285735a102beb4441e38db90553", size = 244885 },
]

[[package]]
name = "pydantic"
version = "2.11.7"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "annotated-types" },
    { name = "pydantic-core" },
    { name = "typing-extensions" },
    { name = "typing-inspection" },
]
sdist = { url = "https://files.pythonhosted.org/packages/00/dd/4325abf92c39ba8623b5af936ddb36ffcfe0beae70405d456ab1fb2f5b8c/pydantic-2.11.7.tar.gz", hash = "sha256:d989c3c6cb79469287b1569f7447a17848c998458d49ebe294e975b9baf0f0db", size = 788350 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6a/c0/ec2b1c8712ca690e5d61979dee872603e92b8a32f94cc1b72d53beab008a/pydantic-2.11.7-py3-none-any.whl", hash = "sha256:dde5df002701f6de26248661f6835bbe296a47bf73990135c7d07ce741b9623b", size = 444782 },
]

[[package]]
name = "pydantic-core"
version = "2.33.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/ad/88/5f2260bdfae97aabf98f1778d43f69574390ad787afb646292a638c923d4/pydantic_core-2.33.2.tar.gz", hash = "sha256:7cb8bc3605c29176e1b105350d2e6474142d7c1bd1d9327c4a9bdb46bf827acc", size = 435195 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e5/92/b31726561b5dae176c2d2c2dc43a9c5bfba5d32f96f8b4c0a600dd492447/pydantic_core-2.33.2-cp310-cp310-macosx_10_12_x86_64.whl", hash = "sha256:2b3d326aaef0c0399d9afffeb6367d5e26ddc24d351dbc9c636840ac355dc5d8", size = 2028817 },
    { url = "https://files.pythonhosted.org/packages/a3/44/3f0b95fafdaca04a483c4e685fe437c6891001bf3ce8b2fded82b9ea3aa1/pydantic_core-2.33.2-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:0e5b2671f05ba48b94cb90ce55d8bdcaaedb8ba00cc5359f6810fc918713983d", size = 1861357 },
    { url = "https://files.pythonhosted.org/packages/30/97/e8f13b55766234caae05372826e8e4b3b96e7b248be3157f53237682e43c/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0069c9acc3f3981b9ff4cdfaf088e98d83440a4c7ea1bc07460af3d4dc22e72d", size = 1898011 },
    { url = "https://files.pythonhosted.org/packages/9b/a3/99c48cf7bafc991cc3ee66fd544c0aae8dc907b752f1dad2d79b1b5a471f/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:d53b22f2032c42eaaf025f7c40c2e3b94568ae077a606f006d206a463bc69572", size = 1982730 },
    { url = "https://files.pythonhosted.org/packages/de/8e/a5b882ec4307010a840fb8b58bd9bf65d1840c92eae7534c7441709bf54b/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:0405262705a123b7ce9f0b92f123334d67b70fd1f20a9372b907ce1080c7ba02", size = 2136178 },
    { url = "https://files.pythonhosted.org/packages/e4/bb/71e35fc3ed05af6834e890edb75968e2802fe98778971ab5cba20a162315/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:4b25d91e288e2c4e0662b8038a28c6a07eaac3e196cfc4ff69de4ea3db992a1b", size = 2736462 },
    { url = "https://files.pythonhosted.org/packages/31/0d/c8f7593e6bc7066289bbc366f2235701dcbebcd1ff0ef8e64f6f239fb47d/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:6bdfe4b3789761f3bcb4b1ddf33355a71079858958e3a552f16d5af19768fef2", size = 2005652 },
    { url = "https://files.pythonhosted.org/packages/d2/7a/996d8bd75f3eda405e3dd219ff5ff0a283cd8e34add39d8ef9157e722867/pydantic_core-2.33.2-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:efec8db3266b76ef9607c2c4c419bdb06bf335ae433b80816089ea7585816f6a", size = 2113306 },
    { url = "https://files.pythonhosted.org/packages/ff/84/daf2a6fb2db40ffda6578a7e8c5a6e9c8affb251a05c233ae37098118788/pydantic_core-2.33.2-cp310-cp310-musllinux_1_1_aarch64.whl", hash = "sha256:031c57d67ca86902726e0fae2214ce6770bbe2f710dc33063187a68744a5ecac", size = 2073720 },
    { url = "https://files.pythonhosted.org/packages/77/fb/2258da019f4825128445ae79456a5499c032b55849dbd5bed78c95ccf163/pydantic_core-2.33.2-cp310-cp310-musllinux_1_1_armv7l.whl", hash = "sha256:f8de619080e944347f5f20de29a975c2d815d9ddd8be9b9b7268e2e3ef68605a", size = 2244915 },
    { url = "https://files.pythonhosted.org/packages/d8/7a/925ff73756031289468326e355b6fa8316960d0d65f8b5d6b3a3e7866de7/pydantic_core-2.33.2-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:73662edf539e72a9440129f231ed3757faab89630d291b784ca99237fb94db2b", size = 2241884 },
    { url = "https://files.pythonhosted.org/packages/0b/b0/249ee6d2646f1cdadcb813805fe76265745c4010cf20a8eba7b0e639d9b2/pydantic_core-2.33.2-cp310-cp310-win32.whl", hash = "sha256:0a39979dcbb70998b0e505fb1556a1d550a0781463ce84ebf915ba293ccb7e22", size = 1910496 },
    { url = "https://files.pythonhosted.org/packages/66/ff/172ba8f12a42d4b552917aa65d1f2328990d3ccfc01d5b7c943ec084299f/pydantic_core-2.33.2-cp310-cp310-win_amd64.whl", hash = "sha256:b0379a2b24882fef529ec3b4987cb5d003b9cda32256024e6fe1586ac45fc640", size = 1955019 },
    { url = "https://files.pythonhosted.org/packages/3f/8d/71db63483d518cbbf290261a1fc2839d17ff89fce7089e08cad07ccfce67/pydantic_core-2.33.2-cp311-cp311-macosx_10_12_x86_64.whl", hash = "sha256:4c5b0a576fb381edd6d27f0a85915c6daf2f8138dc5c267a57c08a62900758c7", size = 2028584 },
    { url = "https://files.pythonhosted.org/packages/24/2f/3cfa7244ae292dd850989f328722d2aef313f74ffc471184dc509e1e4e5a/pydantic_core-2.33.2-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:e799c050df38a639db758c617ec771fd8fb7a5f8eaaa4b27b101f266b216a246", size = 1855071 },
    { url = "https://files.pythonhosted.org/packages/b3/d3/4ae42d33f5e3f50dd467761304be2fa0a9417fbf09735bc2cce003480f2a/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:dc46a01bf8d62f227d5ecee74178ffc448ff4e5197c756331f71efcc66dc980f", size = 1897823 },
    { url = "https://files.pythonhosted.org/packages/f4/f3/aa5976e8352b7695ff808599794b1fba2a9ae2ee954a3426855935799488/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:a144d4f717285c6d9234a66778059f33a89096dfb9b39117663fd8413d582dcc", size = 1983792 },
    { url = "https://files.pythonhosted.org/packages/d5/7a/cda9b5a23c552037717f2b2a5257e9b2bfe45e687386df9591eff7b46d28/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:73cf6373c21bc80b2e0dc88444f41ae60b2f070ed02095754eb5a01df12256de", size = 2136338 },
    { url = "https://files.pythonhosted.org/packages/2b/9f/b8f9ec8dd1417eb9da784e91e1667d58a2a4a7b7b34cf4af765ef663a7e5/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:3dc625f4aa79713512d1976fe9f0bc99f706a9dee21dfd1810b4bbbf228d0e8a", size = 2730998 },
    { url = "https://files.pythonhosted.org/packages/47/bc/cd720e078576bdb8255d5032c5d63ee5c0bf4b7173dd955185a1d658c456/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:881b21b5549499972441da4758d662aeea93f1923f953e9cbaff14b8b9565aef", size = 2003200 },
    { url = "https://files.pythonhosted.org/packages/ca/22/3602b895ee2cd29d11a2b349372446ae9727c32e78a94b3d588a40fdf187/pydantic_core-2.33.2-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:bdc25f3681f7b78572699569514036afe3c243bc3059d3942624e936ec93450e", size = 2113890 },
    { url = "https://files.pythonhosted.org/packages/ff/e6/e3c5908c03cf00d629eb38393a98fccc38ee0ce8ecce32f69fc7d7b558a7/pydantic_core-2.33.2-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:fe5b32187cbc0c862ee201ad66c30cf218e5ed468ec8dc1cf49dec66e160cc4d", size = 2073359 },
    { url = "https://files.pythonhosted.org/packages/12/e7/6a36a07c59ebefc8777d1ffdaf5ae71b06b21952582e4b07eba88a421c79/pydantic_core-2.33.2-cp311-cp311-musllinux_1_1_armv7l.whl", hash = "sha256:bc7aee6f634a6f4a95676fcb5d6559a2c2a390330098dba5e5a5f28a2e4ada30", size = 2245883 },
    { url = "https://files.pythonhosted.org/packages/16/3f/59b3187aaa6cc0c1e6616e8045b284de2b6a87b027cce2ffcea073adf1d2/pydantic_core-2.33.2-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:235f45e5dbcccf6bd99f9f472858849f73d11120d76ea8707115415f8e5ebebf", size = 2241074 },
    { url = "https://files.pythonhosted.org/packages/e0/ed/55532bb88f674d5d8f67ab121a2a13c385df382de2a1677f30ad385f7438/pydantic_core-2.33.2-cp311-cp311-win32.whl", hash = "sha256:6368900c2d3ef09b69cb0b913f9f8263b03786e5b2a387706c5afb66800efd51", size = 1910538 },
    { url = "https://files.pythonhosted.org/packages/fe/1b/25b7cccd4519c0b23c2dd636ad39d381abf113085ce4f7bec2b0dc755eb1/pydantic_core-2.33.2-cp311-cp311-win_amd64.whl", hash = "sha256:1e063337ef9e9820c77acc768546325ebe04ee38b08703244c1309cccc4f1bab", size = 1952909 },
    { url = "https://files.pythonhosted.org/packages/49/a9/d809358e49126438055884c4366a1f6227f0f84f635a9014e2deb9b9de54/pydantic_core-2.33.2-cp311-cp311-win_arm64.whl", hash = "sha256:6b99022f1d19bc32a4c2a0d544fc9a76e3be90f0b3f4af413f87d38749300e65", size = 1897786 },
    { url = "https://files.pythonhosted.org/packages/18/8a/2b41c97f554ec8c71f2a8a5f85cb56a8b0956addfe8b0efb5b3d77e8bdc3/pydantic_core-2.33.2-cp312-cp312-macosx_10_12_x86_64.whl", hash = "sha256:a7ec89dc587667f22b6a0b6579c249fca9026ce7c333fc142ba42411fa243cdc", size = 2009000 },
    { url = "https://files.pythonhosted.org/packages/a1/02/6224312aacb3c8ecbaa959897af57181fb6cf3a3d7917fd44d0f2917e6f2/pydantic_core-2.33.2-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:3c6db6e52c6d70aa0d00d45cdb9b40f0433b96380071ea80b09277dba021ddf7", size = 1847996 },
    { url = "https://files.pythonhosted.org/packages/d6/46/6dcdf084a523dbe0a0be59d054734b86a981726f221f4562aed313dbcb49/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:4e61206137cbc65e6d5256e1166f88331d3b6238e082d9f74613b9b765fb9025", size = 1880957 },
    { url = "https://files.pythonhosted.org/packages/ec/6b/1ec2c03837ac00886ba8160ce041ce4e325b41d06a034adbef11339ae422/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:eb8c529b2819c37140eb51b914153063d27ed88e3bdc31b71198a198e921e011", size = 1964199 },
    { url = "https://files.pythonhosted.org/packages/2d/1d/6bf34d6adb9debd9136bd197ca72642203ce9aaaa85cfcbfcf20f9696e83/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:c52b02ad8b4e2cf14ca7b3d918f3eb0ee91e63b3167c32591e57c4317e134f8f", size = 2120296 },
    { url = "https://files.pythonhosted.org/packages/e0/94/2bd0aaf5a591e974b32a9f7123f16637776c304471a0ab33cf263cf5591a/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:96081f1605125ba0855dfda83f6f3df5ec90c61195421ba72223de35ccfb2f88", size = 2676109 },
    { url = "https://files.pythonhosted.org/packages/f9/41/4b043778cf9c4285d59742281a769eac371b9e47e35f98ad321349cc5d61/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:8f57a69461af2a5fa6e6bbd7a5f60d3b7e6cebb687f55106933188e79ad155c1", size = 2002028 },
    { url = "https://files.pythonhosted.org/packages/cb/d5/7bb781bf2748ce3d03af04d5c969fa1308880e1dca35a9bd94e1a96a922e/pydantic_core-2.33.2-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:572c7e6c8bb4774d2ac88929e3d1f12bc45714ae5ee6d9a788a9fb35e60bb04b", size = 2100044 },
    { url = "https://files.pythonhosted.org/packages/fe/36/def5e53e1eb0ad896785702a5bbfd25eed546cdcf4087ad285021a90ed53/pydantic_core-2.33.2-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:db4b41f9bd95fbe5acd76d89920336ba96f03e149097365afe1cb092fceb89a1", size = 2058881 },
    { url = "https://files.pythonhosted.org/packages/01/6c/57f8d70b2ee57fc3dc8b9610315949837fa8c11d86927b9bb044f8705419/pydantic_core-2.33.2-cp312-cp312-musllinux_1_1_armv7l.whl", hash = "sha256:fa854f5cf7e33842a892e5c73f45327760bc7bc516339fda888c75ae60edaeb6", size = 2227034 },
    { url = "https://files.pythonhosted.org/packages/27/b9/9c17f0396a82b3d5cbea4c24d742083422639e7bb1d5bf600e12cb176a13/pydantic_core-2.33.2-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:5f483cfb75ff703095c59e365360cb73e00185e01aaea067cd19acffd2ab20ea", size = 2234187 },
    { url = "https://files.pythonhosted.org/packages/b0/6a/adf5734ffd52bf86d865093ad70b2ce543415e0e356f6cacabbc0d9ad910/pydantic_core-2.33.2-cp312-cp312-win32.whl", hash = "sha256:9cb1da0f5a471435a7bc7e439b8a728e8b61e59784b2af70d7c169f8dd8ae290", size = 1892628 },
    { url = "https://files.pythonhosted.org/packages/43/e4/5479fecb3606c1368d496a825d8411e126133c41224c1e7238be58b87d7e/pydantic_core-2.33.2-cp312-cp312-win_amd64.whl", hash = "sha256:f941635f2a3d96b2973e867144fde513665c87f13fe0e193c158ac51bfaaa7b2", size = 1955866 },
    { url = "https://files.pythonhosted.org/packages/0d/24/8b11e8b3e2be9dd82df4b11408a67c61bb4dc4f8e11b5b0fc888b38118b5/pydantic_core-2.33.2-cp312-cp312-win_arm64.whl", hash = "sha256:cca3868ddfaccfbc4bfb1d608e2ccaaebe0ae628e1416aeb9c4d88c001bb45ab", size = 1888894 },
    { url = "https://files.pythonhosted.org/packages/46/8c/99040727b41f56616573a28771b1bfa08a3d3fe74d3d513f01251f79f172/pydantic_core-2.33.2-cp313-cp313-macosx_10_12_x86_64.whl", hash = "sha256:1082dd3e2d7109ad8b7da48e1d4710c8d06c253cbc4a27c1cff4fbcaa97a9e3f", size = 2015688 },
    { url = "https://files.pythonhosted.org/packages/3a/cc/5999d1eb705a6cefc31f0b4a90e9f7fc400539b1a1030529700cc1b51838/pydantic_core-2.33.2-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:f517ca031dfc037a9c07e748cefd8d96235088b83b4f4ba8939105d20fa1dcd6", size = 1844808 },
    { url = "https://files.pythonhosted.org/packages/6f/5e/a0a7b8885c98889a18b6e376f344da1ef323d270b44edf8174d6bce4d622/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0a9f2c9dd19656823cb8250b0724ee9c60a82f3cdf68a080979d13092a3b0fef", size = 1885580 },
    { url = "https://files.pythonhosted.org/packages/3b/2a/953581f343c7d11a304581156618c3f592435523dd9d79865903272c256a/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:2b0a451c263b01acebe51895bfb0e1cc842a5c666efe06cdf13846c7418caa9a", size = 1973859 },
    { url = "https://files.pythonhosted.org/packages/e6/55/f1a813904771c03a3f97f676c62cca0c0a4138654107c1b61f19c644868b/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:1ea40a64d23faa25e62a70ad163571c0b342b8bf66d5fa612ac0dec4f069d916", size = 2120810 },
    { url = "https://files.pythonhosted.org/packages/aa/c3/053389835a996e18853ba107a63caae0b9deb4a276c6b472931ea9ae6e48/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:0fb2d542b4d66f9470e8065c5469ec676978d625a8b7a363f07d9a501a9cb36a", size = 2676498 },
    { url = "https://files.pythonhosted.org/packages/eb/3c/f4abd740877a35abade05e437245b192f9d0ffb48bbbbd708df33d3cda37/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9fdac5d6ffa1b5a83bca06ffe7583f5576555e6c8b3a91fbd25ea7780f825f7d", size = 2000611 },
    { url = "https://files.pythonhosted.org/packages/59/a7/63ef2fed1837d1121a894d0ce88439fe3e3b3e48c7543b2a4479eb99c2bd/pydantic_core-2.33.2-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:04a1a413977ab517154eebb2d326da71638271477d6ad87a769102f7c2488c56", size = 2107924 },
    { url = "https://files.pythonhosted.org/packages/04/8f/2551964ef045669801675f1cfc3b0d74147f4901c3ffa42be2ddb1f0efc4/pydantic_core-2.33.2-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:c8e7af2f4e0194c22b5b37205bfb293d166a7344a5b0d0eaccebc376546d77d5", size = 2063196 },
    { url = "https://files.pythonhosted.org/packages/26/bd/d9602777e77fc6dbb0c7db9ad356e9a985825547dce5ad1d30ee04903918/pydantic_core-2.33.2-cp313-cp313-musllinux_1_1_armv7l.whl", hash = "sha256:5c92edd15cd58b3c2d34873597a1e20f13094f59cf88068adb18947df5455b4e", size = 2236389 },
    { url = "https://files.pythonhosted.org/packages/42/db/0e950daa7e2230423ab342ae918a794964b053bec24ba8af013fc7c94846/pydantic_core-2.33.2-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:65132b7b4a1c0beded5e057324b7e16e10910c106d43675d9bd87d4f38dde162", size = 2239223 },
    { url = "https://files.pythonhosted.org/packages/58/4d/4f937099c545a8a17eb52cb67fe0447fd9a373b348ccfa9a87f141eeb00f/pydantic_core-2.33.2-cp313-cp313-win32.whl", hash = "sha256:52fb90784e0a242bb96ec53f42196a17278855b0f31ac7c3cc6f5c1ec4811849", size = 1900473 },
    { url = "https://files.pythonhosted.org/packages/a0/75/4a0a9bac998d78d889def5e4ef2b065acba8cae8c93696906c3a91f310ca/pydantic_core-2.33.2-cp313-cp313-win_amd64.whl", hash = "sha256:c083a3bdd5a93dfe480f1125926afcdbf2917ae714bdb80b36d34318b2bec5d9", size = 1955269 },
    { url = "https://files.pythonhosted.org/packages/f9/86/1beda0576969592f1497b4ce8e7bc8cbdf614c352426271b1b10d5f0aa64/pydantic_core-2.33.2-cp313-cp313-win_arm64.whl", hash = "sha256:e80b087132752f6b3d714f041ccf74403799d3b23a72722ea2e6ba2e892555b9", size = 1893921 },
    { url = "https://files.pythonhosted.org/packages/a4/7d/e09391c2eebeab681df2b74bfe6c43422fffede8dc74187b2b0bf6fd7571/pydantic_core-2.33.2-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:61c18fba8e5e9db3ab908620af374db0ac1baa69f0f32df4f61ae23f15e586ac", size = 1806162 },
    { url = "https://files.pythonhosted.org/packages/f1/3d/847b6b1fed9f8ed3bb95a9ad04fbd0b212e832d4f0f50ff4d9ee5a9f15cf/pydantic_core-2.33.2-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:95237e53bb015f67b63c91af7518a62a8660376a6a0db19b89acc77a4d6199f5", size = 1981560 },
    { url = "https://files.pythonhosted.org/packages/6f/9a/e73262f6c6656262b5fdd723ad90f518f579b7bc8622e43a942eec53c938/pydantic_core-2.33.2-cp313-cp313t-win_amd64.whl", hash = "sha256:c2fc0a768ef76c15ab9238afa6da7f69895bb5d1ee83aeea2e3509af4472d0b9", size = 1935777 },
    { url = "https://files.pythonhosted.org/packages/53/ea/bbe9095cdd771987d13c82d104a9c8559ae9aec1e29f139e286fd2e9256e/pydantic_core-2.33.2-cp39-cp39-macosx_10_12_x86_64.whl", hash = "sha256:a2b911a5b90e0374d03813674bf0a5fbbb7741570dcd4b4e85a2e48d17def29d", size = 2028677 },
    { url = "https://files.pythonhosted.org/packages/49/1d/4ac5ed228078737d457a609013e8f7edc64adc37b91d619ea965758369e5/pydantic_core-2.33.2-cp39-cp39-macosx_11_0_arm64.whl", hash = "sha256:6fa6dfc3e4d1f734a34710f391ae822e0a8eb8559a85c6979e14e65ee6ba2954", size = 1864735 },
    { url = "https://files.pythonhosted.org/packages/23/9a/2e70d6388d7cda488ae38f57bc2f7b03ee442fbcf0d75d848304ac7e405b/pydantic_core-2.33.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:c54c939ee22dc8e2d545da79fc5381f1c020d6d3141d3bd747eab59164dc89fb", size = 1898467 },
    { url = "https://files.pythonhosted.org/packages/ff/2e/1568934feb43370c1ffb78a77f0baaa5a8b6897513e7a91051af707ffdc4/pydantic_core-2.33.2-cp39-cp39-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:53a57d2ed685940a504248187d5685e49eb5eef0f696853647bf37c418c538f7", size = 1983041 },
    { url = "https://files.pythonhosted.org/packages/01/1a/1a1118f38ab64eac2f6269eb8c120ab915be30e387bb561e3af904b12499/pydantic_core-2.33.2-cp39-cp39-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:09fb9dd6571aacd023fe6aaca316bd01cf60ab27240d7eb39ebd66a3a15293b4", size = 2136503 },
    { url = "https://files.pythonhosted.org/packages/5c/da/44754d1d7ae0f22d6d3ce6c6b1486fc07ac2c524ed8f6eca636e2e1ee49b/pydantic_core-2.33.2-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:0e6116757f7959a712db11f3e9c0a99ade00a5bbedae83cb801985aa154f071b", size = 2736079 },
    { url = "https://files.pythonhosted.org/packages/4d/98/f43cd89172220ec5aa86654967b22d862146bc4d736b1350b4c41e7c9c03/pydantic_core-2.33.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:8d55ab81c57b8ff8548c3e4947f119551253f4e3787a7bbc0b6b3ca47498a9d3", size = 2006508 },
    { url = "https://files.pythonhosted.org/packages/2b/cc/f77e8e242171d2158309f830f7d5d07e0531b756106f36bc18712dc439df/pydantic_core-2.33.2-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:c20c462aa4434b33a2661701b861604913f912254e441ab8d78d30485736115a", size = 2113693 },
    { url = "https://files.pythonhosted.org/packages/54/7a/7be6a7bd43e0a47c147ba7fbf124fe8aaf1200bc587da925509641113b2d/pydantic_core-2.33.2-cp39-cp39-musllinux_1_1_aarch64.whl", hash = "sha256:44857c3227d3fb5e753d5fe4a3420d6376fa594b07b621e220cd93703fe21782", size = 2074224 },
    { url = "https://files.pythonhosted.org/packages/2a/07/31cf8fadffbb03be1cb520850e00a8490c0927ec456e8293cafda0726184/pydantic_core-2.33.2-cp39-cp39-musllinux_1_1_armv7l.whl", hash = "sha256:eb9b459ca4df0e5c87deb59d37377461a538852765293f9e6ee834f0435a93b9", size = 2245403 },
    { url = "https://files.pythonhosted.org/packages/b6/8d/bbaf4c6721b668d44f01861f297eb01c9b35f612f6b8e14173cb204e6240/pydantic_core-2.33.2-cp39-cp39-musllinux_1_1_x86_64.whl", hash = "sha256:9fcd347d2cc5c23b06de6d3b7b8275be558a0c90549495c699e379a80bf8379e", size = 2242331 },
    { url = "https://files.pythonhosted.org/packages/bb/93/3cc157026bca8f5006250e74515119fcaa6d6858aceee8f67ab6dc548c16/pydantic_core-2.33.2-cp39-cp39-win32.whl", hash = "sha256:83aa99b1285bc8f038941ddf598501a86f1536789740991d7d8756e34f1e74d9", size = 1910571 },
    { url = "https://files.pythonhosted.org/packages/5b/90/7edc3b2a0d9f0dda8806c04e511a67b0b7a41d2187e2003673a996fb4310/pydantic_core-2.33.2-cp39-cp39-win_amd64.whl", hash = "sha256:f481959862f57f29601ccced557cc2e817bce7533ab8e01a797a48b49c9692b3", size = 1956504 },
    { url = "https://files.pythonhosted.org/packages/30/68/373d55e58b7e83ce371691f6eaa7175e3a24b956c44628eb25d7da007917/pydantic_core-2.33.2-pp310-pypy310_pp73-macosx_10_12_x86_64.whl", hash = "sha256:5c4aa4e82353f65e548c476b37e64189783aa5384903bfea4f41580f255fddfa", size = 2023982 },
    { url = "https://files.pythonhosted.org/packages/a4/16/145f54ac08c96a63d8ed6442f9dec17b2773d19920b627b18d4f10a061ea/pydantic_core-2.33.2-pp310-pypy310_pp73-macosx_11_0_arm64.whl", hash = "sha256:d946c8bf0d5c24bf4fe333af284c59a19358aa3ec18cb3dc4370080da1e8ad29", size = 1858412 },
    { url = "https://files.pythonhosted.org/packages/41/b1/c6dc6c3e2de4516c0bb2c46f6a373b91b5660312342a0cf5826e38ad82fa/pydantic_core-2.33.2-pp310-pypy310_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:87b31b6846e361ef83fedb187bb5b4372d0da3f7e28d85415efa92d6125d6e6d", size = 1892749 },
    { url = "https://files.pythonhosted.org/packages/12/73/8cd57e20afba760b21b742106f9dbdfa6697f1570b189c7457a1af4cd8a0/pydantic_core-2.33.2-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:aa9d91b338f2df0508606f7009fde642391425189bba6d8c653afd80fd6bb64e", size = 2067527 },
    { url = "https://files.pythonhosted.org/packages/e3/d5/0bb5d988cc019b3cba4a78f2d4b3854427fc47ee8ec8e9eaabf787da239c/pydantic_core-2.33.2-pp310-pypy310_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:2058a32994f1fde4ca0480ab9d1e75a0e8c87c22b53a3ae66554f9af78f2fe8c", size = 2108225 },
    { url = "https://files.pythonhosted.org/packages/f1/c5/00c02d1571913d496aabf146106ad8239dc132485ee22efe08085084ff7c/pydantic_core-2.33.2-pp310-pypy310_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:0e03262ab796d986f978f79c943fc5f620381be7287148b8010b4097f79a39ec", size = 2069490 },
    { url = "https://files.pythonhosted.org/packages/22/a8/dccc38768274d3ed3a59b5d06f59ccb845778687652daa71df0cab4040d7/pydantic_core-2.33.2-pp310-pypy310_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:1a8695a8d00c73e50bff9dfda4d540b7dee29ff9b8053e38380426a85ef10052", size = 2237525 },
    { url = "https://files.pythonhosted.org/packages/d4/e7/4f98c0b125dda7cf7ccd14ba936218397b44f50a56dd8c16a3091df116c3/pydantic_core-2.33.2-pp310-pypy310_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:fa754d1850735a0b0e03bcffd9d4b4343eb417e47196e4485d9cca326073a42c", size = 2238446 },
    { url = "https://files.pythonhosted.org/packages/ce/91/2ec36480fdb0b783cd9ef6795753c1dea13882f2e68e73bce76ae8c21e6a/pydantic_core-2.33.2-pp310-pypy310_pp73-win_amd64.whl", hash = "sha256:a11c8d26a50bfab49002947d3d237abe4d9e4b5bdc8846a63537b6488e197808", size = 2066678 },
    { url = "https://files.pythonhosted.org/packages/7b/27/d4ae6487d73948d6f20dddcd94be4ea43e74349b56eba82e9bdee2d7494c/pydantic_core-2.33.2-pp311-pypy311_pp73-macosx_10_12_x86_64.whl", hash = "sha256:dd14041875d09cc0f9308e37a6f8b65f5585cf2598a53aa0123df8b129d481f8", size = 2025200 },
    { url = "https://files.pythonhosted.org/packages/f1/b8/b3cb95375f05d33801024079b9392a5ab45267a63400bf1866e7ce0f0de4/pydantic_core-2.33.2-pp311-pypy311_pp73-macosx_11_0_arm64.whl", hash = "sha256:d87c561733f66531dced0da6e864f44ebf89a8fba55f31407b00c2f7f9449593", size = 1859123 },
    { url = "https://files.pythonhosted.org/packages/05/bc/0d0b5adeda59a261cd30a1235a445bf55c7e46ae44aea28f7bd6ed46e091/pydantic_core-2.33.2-pp311-pypy311_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:2f82865531efd18d6e07a04a17331af02cb7a651583c418df8266f17a63c6612", size = 1892852 },
    { url = "https://files.pythonhosted.org/packages/3e/11/d37bdebbda2e449cb3f519f6ce950927b56d62f0b84fd9cb9e372a26a3d5/pydantic_core-2.33.2-pp311-pypy311_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:2bfb5112df54209d820d7bf9317c7a6c9025ea52e49f46b6a2060104bba37de7", size = 2067484 },
    { url = "https://files.pythonhosted.org/packages/8c/55/1f95f0a05ce72ecb02a8a8a1c3be0579bbc29b1d5ab68f1378b7bebc5057/pydantic_core-2.33.2-pp311-pypy311_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:64632ff9d614e5eecfb495796ad51b0ed98c453e447a76bcbeeb69615079fc7e", size = 2108896 },
    { url = "https://files.pythonhosted.org/packages/53/89/2b2de6c81fa131f423246a9109d7b2a375e83968ad0800d6e57d0574629b/pydantic_core-2.33.2-pp311-pypy311_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:f889f7a40498cc077332c7ab6b4608d296d852182211787d4f3ee377aaae66e8", size = 2069475 },
    { url = "https://files.pythonhosted.org/packages/b8/e9/1f7efbe20d0b2b10f6718944b5d8ece9152390904f29a78e68d4e7961159/pydantic_core-2.33.2-pp311-pypy311_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:de4b83bb311557e439b9e186f733f6c645b9417c84e2eb8203f3f820a4b988bf", size = 2239013 },
    { url = "https://files.pythonhosted.org/packages/3c/b2/5309c905a93811524a49b4e031e9851a6b00ff0fb668794472ea7746b448/pydantic_core-2.33.2-pp311-pypy311_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:82f68293f055f51b51ea42fafc74b6aad03e70e191799430b90c13d643059ebb", size = 2238715 },
    { url = "https://files.pythonhosted.org/packages/32/56/8a7ca5d2cd2cda1d245d34b1c9a942920a718082ae8e54e5f3e5a58b7add/pydantic_core-2.33.2-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:329467cecfb529c925cf2bbd4d60d2c509bc2fb52a20c1045bf09bb70971a9c1", size = 2066757 },
    { url = "https://files.pythonhosted.org/packages/08/98/dbf3fdfabaf81cda5622154fda78ea9965ac467e3239078e0dcd6df159e7/pydantic_core-2.33.2-pp39-pypy39_pp73-macosx_10_12_x86_64.whl", hash = "sha256:87acbfcf8e90ca885206e98359d7dca4bcbb35abdc0ff66672a293e1d7a19101", size = 2024034 },
    { url = "https://files.pythonhosted.org/packages/8d/99/7810aa9256e7f2ccd492590f86b79d370df1e9292f1f80b000b6a75bd2fb/pydantic_core-2.33.2-pp39-pypy39_pp73-macosx_11_0_arm64.whl", hash = "sha256:7f92c15cd1e97d4b12acd1cc9004fa092578acfa57b67ad5e43a197175d01a64", size = 1858578 },
    { url = "https://files.pythonhosted.org/packages/d8/60/bc06fa9027c7006cc6dd21e48dbf39076dc39d9abbaf718a1604973a9670/pydantic_core-2.33.2-pp39-pypy39_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:d3f26877a748dc4251cfcfda9dfb5f13fcb034f5308388066bcfe9031b63ae7d", size = 1892858 },
    { url = "https://files.pythonhosted.org/packages/f2/40/9d03997d9518816c68b4dfccb88969756b9146031b61cd37f781c74c9b6a/pydantic_core-2.33.2-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:dac89aea9af8cd672fa7b510e7b8c33b0bba9a43186680550ccf23020f32d535", size = 2068498 },
    { url = "https://files.pythonhosted.org/packages/d8/62/d490198d05d2d86672dc269f52579cad7261ced64c2df213d5c16e0aecb1/pydantic_core-2.33.2-pp39-pypy39_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:970919794d126ba8645f3837ab6046fb4e72bbc057b3709144066204c19a455d", size = 2108428 },
    { url = "https://files.pythonhosted.org/packages/9a/ec/4cd215534fd10b8549015f12ea650a1a973da20ce46430b68fc3185573e8/pydantic_core-2.33.2-pp39-pypy39_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:3eb3fe62804e8f859c49ed20a8451342de53ed764150cb14ca71357c765dc2a6", size = 2069854 },
    { url = "https://files.pythonhosted.org/packages/1a/1a/abbd63d47e1d9b0d632fee6bb15785d0889c8a6e0a6c3b5a8e28ac1ec5d2/pydantic_core-2.33.2-pp39-pypy39_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:3abcd9392a36025e3bd55f9bd38d908bd17962cc49bc6da8e7e96285336e2bca", size = 2237859 },
    { url = "https://files.pythonhosted.org/packages/80/1c/fa883643429908b1c90598fd2642af8839efd1d835b65af1f75fba4d94fe/pydantic_core-2.33.2-pp39-pypy39_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:3a1c81334778f9e3af2f8aeb7a960736e5cab1dfebfb26aabca09afd2906c039", size = 2239059 },
    { url = "https://files.pythonhosted.org/packages/d4/29/3cade8a924a61f60ccfa10842f75eb12787e1440e2b8660ceffeb26685e7/pydantic_core-2.33.2-pp39-pypy39_pp73-win_amd64.whl", hash = "sha256:2807668ba86cb38c6817ad9bc66215ab8584d1d304030ce4f0887336f28a5e27", size = 2066661 },
]

[[package]]
name = "pygments"
version = "2.19.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/b0/77/a5b8c569bf593b0140bde72ea885a803b82086995367bf2037de0159d924/pygments-2.19.2.tar.gz", hash = "sha256:636cb2477cec7f8952536970bc533bc43743542f70392ae026374600add5b887", size = 4968631 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c7/21/705964c7812476f378728bdf590ca4b771ec72385c533964653c68e86bdc/pygments-2.19.2-py3-none-any.whl", hash = "sha256:86540386c03d588bb81d44bc3928634ff26449851e99741617ecb9037ee5ec0b", size = 1225217 },
]

[[package]]
name = "pytest"
version = "8.4.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama", marker = "sys_platform == 'win32'" },
    { name = "exceptiongroup", marker = "python_full_version < '3.11'" },
    { name = "iniconfig" },
    { name = "packaging" },
    { name = "pluggy" },
    { name = "pygments" },
    { name = "tomli", marker = "python_full_version < '3.11'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/08/ba/45911d754e8eba3d5a841a5ce61a65a685ff1798421ac054f85aa8747dfb/pytest-8.4.1.tar.gz", hash = "sha256:7c67fd69174877359ed9371ec3af8a3d2b04741818c51e5e99cc1742251fa93c", size = 1517714 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/29/16/c8a903f4c4dffe7a12843191437d7cd8e32751d5de349d45d3fe69544e87/pytest-8.4.1-py3-none-any.whl", hash = "sha256:539c70ba6fcead8e78eebbf1115e8b589e7565830d7d006a8723f19ac8a0afb7", size = 365474 },
]

[[package]]
name = "pyyaml"
version = "6.0.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/54/ed/79a089b6be93607fa5cdaedf301d7dfb23af5f25c398d5ead2525b063e17/pyyaml-6.0.2.tar.gz", hash = "sha256:d584d9ec91ad65861cc08d42e834324ef890a082e591037abe114850ff7bbc3e", size = 130631 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/9b/95/a3fac87cb7158e231b5a6012e438c647e1a87f09f8e0d123acec8ab8bf71/PyYAML-6.0.2-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:0a9a2848a5b7feac301353437eb7d5957887edbf81d56e903999a75a3d743086", size = 184199 },
    { url = "https://files.pythonhosted.org/packages/c7/7a/68bd47624dab8fd4afbfd3c48e3b79efe09098ae941de5b58abcbadff5cb/PyYAML-6.0.2-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:29717114e51c84ddfba879543fb232a6ed60086602313ca38cce623c1d62cfbf", size = 171758 },
    { url = "https://files.pythonhosted.org/packages/49/ee/14c54df452143b9ee9f0f29074d7ca5516a36edb0b4cc40c3f280131656f/PyYAML-6.0.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:8824b5a04a04a047e72eea5cec3bc266db09e35de6bdfe34c9436ac5ee27d237", size = 718463 },
    { url = "https://files.pythonhosted.org/packages/4d/61/de363a97476e766574650d742205be468921a7b532aa2499fcd886b62530/PyYAML-6.0.2-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:7c36280e6fb8385e520936c3cb3b8042851904eba0e58d277dca80a5cfed590b", size = 719280 },
    { url = "https://files.pythonhosted.org/packages/6b/4e/1523cb902fd98355e2e9ea5e5eb237cbc5f3ad5f3075fa65087aa0ecb669/PyYAML-6.0.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:ec031d5d2feb36d1d1a24380e4db6d43695f3748343d99434e6f5f9156aaa2ed", size = 751239 },
    { url = "https://files.pythonhosted.org/packages/b7/33/5504b3a9a4464893c32f118a9cc045190a91637b119a9c881da1cf6b7a72/PyYAML-6.0.2-cp310-cp310-musllinux_1_1_aarch64.whl", hash = "sha256:936d68689298c36b53b29f23c6dbb74de12b4ac12ca6cfe0e047bedceea56180", size = 695802 },
    { url = "https://files.pythonhosted.org/packages/5c/20/8347dcabd41ef3a3cdc4f7b7a2aff3d06598c8779faa189cdbf878b626a4/PyYAML-6.0.2-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:23502f431948090f597378482b4812b0caae32c22213aecf3b55325e049a6c68", size = 720527 },
    { url = "https://files.pythonhosted.org/packages/be/aa/5afe99233fb360d0ff37377145a949ae258aaab831bde4792b32650a4378/PyYAML-6.0.2-cp310-cp310-win32.whl", hash = "sha256:2e99c6826ffa974fe6e27cdb5ed0021786b03fc98e5ee3c5bfe1fd5015f42b99", size = 144052 },
    { url = "https://files.pythonhosted.org/packages/b5/84/0fa4b06f6d6c958d207620fc60005e241ecedceee58931bb20138e1e5776/PyYAML-6.0.2-cp310-cp310-win_amd64.whl", hash = "sha256:a4d3091415f010369ae4ed1fc6b79def9416358877534caf6a0fdd2146c87a3e", size = 161774 },
    { url = "https://files.pythonhosted.org/packages/f8/aa/7af4e81f7acba21a4c6be026da38fd2b872ca46226673c89a758ebdc4fd2/PyYAML-6.0.2-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:cc1c1159b3d456576af7a3e4d1ba7e6924cb39de8f67111c735f6fc832082774", size = 184612 },
    { url = "https://files.pythonhosted.org/packages/8b/62/b9faa998fd185f65c1371643678e4d58254add437edb764a08c5a98fb986/PyYAML-6.0.2-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:1e2120ef853f59c7419231f3bf4e7021f1b936f6ebd222406c3b60212205d2ee", size = 172040 },
    { url = "https://files.pythonhosted.org/packages/ad/0c/c804f5f922a9a6563bab712d8dcc70251e8af811fce4524d57c2c0fd49a4/PyYAML-6.0.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:5d225db5a45f21e78dd9358e58a98702a0302f2659a3c6cd320564b75b86f47c", size = 736829 },
    { url = "https://files.pythonhosted.org/packages/51/16/6af8d6a6b210c8e54f1406a6b9481febf9c64a3109c541567e35a49aa2e7/PyYAML-6.0.2-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:5ac9328ec4831237bec75defaf839f7d4564be1e6b25ac710bd1a96321cc8317", size = 764167 },
    { url = "https://files.pythonhosted.org/packages/75/e4/2c27590dfc9992f73aabbeb9241ae20220bd9452df27483b6e56d3975cc5/PyYAML-6.0.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:3ad2a3decf9aaba3d29c8f537ac4b243e36bef957511b4766cb0057d32b0be85", size = 762952 },
    { url = "https://files.pythonhosted.org/packages/9b/97/ecc1abf4a823f5ac61941a9c00fe501b02ac3ab0e373c3857f7d4b83e2b6/PyYAML-6.0.2-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:ff3824dc5261f50c9b0dfb3be22b4567a6f938ccce4587b38952d85fd9e9afe4", size = 735301 },
    { url = "https://files.pythonhosted.org/packages/45/73/0f49dacd6e82c9430e46f4a027baa4ca205e8b0a9dce1397f44edc23559d/PyYAML-6.0.2-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:797b4f722ffa07cc8d62053e4cff1486fa6dc094105d13fea7b1de7d8bf71c9e", size = 756638 },
    { url = "https://files.pythonhosted.org/packages/22/5f/956f0f9fc65223a58fbc14459bf34b4cc48dec52e00535c79b8db361aabd/PyYAML-6.0.2-cp311-cp311-win32.whl", hash = "sha256:11d8f3dd2b9c1207dcaf2ee0bbbfd5991f571186ec9cc78427ba5bd32afae4b5", size = 143850 },
    { url = "https://files.pythonhosted.org/packages/ed/23/8da0bbe2ab9dcdd11f4f4557ccaf95c10b9811b13ecced089d43ce59c3c8/PyYAML-6.0.2-cp311-cp311-win_amd64.whl", hash = "sha256:e10ce637b18caea04431ce14fabcf5c64a1c61ec9c56b071a4b7ca131ca52d44", size = 161980 },
    { url = "https://files.pythonhosted.org/packages/86/0c/c581167fc46d6d6d7ddcfb8c843a4de25bdd27e4466938109ca68492292c/PyYAML-6.0.2-cp312-cp312-macosx_10_9_x86_64.whl", hash = "sha256:c70c95198c015b85feafc136515252a261a84561b7b1d51e3384e0655ddf25ab", size = 183873 },
    { url = "https://files.pythonhosted.org/packages/a8/0c/38374f5bb272c051e2a69281d71cba6fdb983413e6758b84482905e29a5d/PyYAML-6.0.2-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:ce826d6ef20b1bc864f0a68340c8b3287705cae2f8b4b1d932177dcc76721725", size = 173302 },
    { url = "https://files.pythonhosted.org/packages/c3/93/9916574aa8c00aa06bbac729972eb1071d002b8e158bd0e83a3b9a20a1f7/PyYAML-6.0.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:1f71ea527786de97d1a0cc0eacd1defc0985dcf6b3f17bb77dcfc8c34bec4dc5", size = 739154 },
    { url = "https://files.pythonhosted.org/packages/95/0f/b8938f1cbd09739c6da569d172531567dbcc9789e0029aa070856f123984/PyYAML-6.0.2-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:9b22676e8097e9e22e36d6b7bda33190d0d400f345f23d4065d48f4ca7ae0425", size = 766223 },
    { url = "https://files.pythonhosted.org/packages/b9/2b/614b4752f2e127db5cc206abc23a8c19678e92b23c3db30fc86ab731d3bd/PyYAML-6.0.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:80bab7bfc629882493af4aa31a4cfa43a4c57c83813253626916b8c7ada83476", size = 767542 },
    { url = "https://files.pythonhosted.org/packages/d4/00/dd137d5bcc7efea1836d6264f049359861cf548469d18da90cd8216cf05f/PyYAML-6.0.2-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:0833f8694549e586547b576dcfaba4a6b55b9e96098b36cdc7ebefe667dfed48", size = 731164 },
    { url = "https://files.pythonhosted.org/packages/c9/1f/4f998c900485e5c0ef43838363ba4a9723ac0ad73a9dc42068b12aaba4e4/PyYAML-6.0.2-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:8b9c7197f7cb2738065c481a0461e50ad02f18c78cd75775628afb4d7137fb3b", size = 756611 },
    { url = "https://files.pythonhosted.org/packages/df/d1/f5a275fdb252768b7a11ec63585bc38d0e87c9e05668a139fea92b80634c/PyYAML-6.0.2-cp312-cp312-win32.whl", hash = "sha256:ef6107725bd54b262d6dedcc2af448a266975032bc85ef0172c5f059da6325b4", size = 140591 },
    { url = "https://files.pythonhosted.org/packages/0c/e8/4f648c598b17c3d06e8753d7d13d57542b30d56e6c2dedf9c331ae56312e/PyYAML-6.0.2-cp312-cp312-win_amd64.whl", hash = "sha256:7e7401d0de89a9a855c839bc697c079a4af81cf878373abd7dc625847d25cbd8", size = 156338 },
    { url = "https://files.pythonhosted.org/packages/ef/e3/3af305b830494fa85d95f6d95ef7fa73f2ee1cc8ef5b495c7c3269fb835f/PyYAML-6.0.2-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:efdca5630322a10774e8e98e1af481aad470dd62c3170801852d752aa7a783ba", size = 181309 },
    { url = "https://files.pythonhosted.org/packages/45/9f/3b1c20a0b7a3200524eb0076cc027a970d320bd3a6592873c85c92a08731/PyYAML-6.0.2-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:50187695423ffe49e2deacb8cd10510bc361faac997de9efef88badc3bb9e2d1", size = 171679 },
    { url = "https://files.pythonhosted.org/packages/7c/9a/337322f27005c33bcb656c655fa78325b730324c78620e8328ae28b64d0c/PyYAML-6.0.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0ffe8360bab4910ef1b9e87fb812d8bc0a308b0d0eef8c8f44e0254ab3b07133", size = 733428 },
    { url = "https://files.pythonhosted.org/packages/a3/69/864fbe19e6c18ea3cc196cbe5d392175b4cf3d5d0ac1403ec3f2d237ebb5/PyYAML-6.0.2-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:17e311b6c678207928d649faa7cb0d7b4c26a0ba73d41e99c4fff6b6c3276484", size = 763361 },
    { url = "https://files.pythonhosted.org/packages/04/24/b7721e4845c2f162d26f50521b825fb061bc0a5afcf9a386840f23ea19fa/PyYAML-6.0.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:70b189594dbe54f75ab3a1acec5f1e3faa7e8cf2f1e08d9b561cb41b845f69d5", size = 759523 },
    { url = "https://files.pythonhosted.org/packages/2b/b2/e3234f59ba06559c6ff63c4e10baea10e5e7df868092bf9ab40e5b9c56b6/PyYAML-6.0.2-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:41e4e3953a79407c794916fa277a82531dd93aad34e29c2a514c2c0c5fe971cc", size = 726660 },
    { url = "https://files.pythonhosted.org/packages/fe/0f/25911a9f080464c59fab9027482f822b86bf0608957a5fcc6eaac85aa515/PyYAML-6.0.2-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:68ccc6023a3400877818152ad9a1033e3db8625d899c72eacb5a668902e4d652", size = 751597 },
    { url = "https://files.pythonhosted.org/packages/14/0d/e2c3b43bbce3cf6bd97c840b46088a3031085179e596d4929729d8d68270/PyYAML-6.0.2-cp313-cp313-win32.whl", hash = "sha256:bc2fa7c6b47d6bc618dd7fb02ef6fdedb1090ec036abab80d4681424b84c1183", size = 140527 },
    { url = "https://files.pythonhosted.org/packages/fa/de/02b54f42487e3d3c6efb3f89428677074ca7bf43aae402517bc7cca949f3/PyYAML-6.0.2-cp313-cp313-win_amd64.whl", hash = "sha256:8388ee1976c416731879ac16da0aff3f63b286ffdd57cdeb95f3f2e085687563", size = 156446 },
    { url = "https://files.pythonhosted.org/packages/65/d8/b7a1db13636d7fb7d4ff431593c510c8b8fca920ade06ca8ef20015493c5/PyYAML-6.0.2-cp39-cp39-macosx_10_9_x86_64.whl", hash = "sha256:688ba32a1cffef67fd2e9398a2efebaea461578b0923624778664cc1c914db5d", size = 184777 },
    { url = "https://files.pythonhosted.org/packages/0a/02/6ec546cd45143fdf9840b2c6be8d875116a64076218b61d68e12548e5839/PyYAML-6.0.2-cp39-cp39-macosx_11_0_arm64.whl", hash = "sha256:a8786accb172bd8afb8be14490a16625cbc387036876ab6ba70912730faf8e1f", size = 172318 },
    { url = "https://files.pythonhosted.org/packages/0e/9a/8cc68be846c972bda34f6c2a93abb644fb2476f4dcc924d52175786932c9/PyYAML-6.0.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:d8e03406cac8513435335dbab54c0d385e4a49e4945d2909a581c83647ca0290", size = 720891 },
    { url = "https://files.pythonhosted.org/packages/e9/6c/6e1b7f40181bc4805e2e07f4abc10a88ce4648e7e95ff1abe4ae4014a9b2/PyYAML-6.0.2-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:f753120cb8181e736c57ef7636e83f31b9c0d1722c516f7e86cf15b7aa57ff12", size = 722614 },
    { url = "https://files.pythonhosted.org/packages/3d/32/e7bd8535d22ea2874cef6a81021ba019474ace0d13a4819c2a4bce79bd6a/PyYAML-6.0.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:3b1fdb9dc17f5a7677423d508ab4f243a726dea51fa5e70992e59a7411c89d19", size = 737360 },
    { url = "https://files.pythonhosted.org/packages/d7/12/7322c1e30b9be969670b672573d45479edef72c9a0deac3bb2868f5d7469/PyYAML-6.0.2-cp39-cp39-musllinux_1_1_aarch64.whl", hash = "sha256:0b69e4ce7a131fe56b7e4d770c67429700908fc0752af059838b1cfb41960e4e", size = 699006 },
    { url = "https://files.pythonhosted.org/packages/82/72/04fcad41ca56491995076630c3ec1e834be241664c0c09a64c9a2589b507/PyYAML-6.0.2-cp39-cp39-musllinux_1_1_x86_64.whl", hash = "sha256:a9f8c2e67970f13b16084e04f134610fd1d374bf477b17ec1599185cf611d725", size = 723577 },
    { url = "https://files.pythonhosted.org/packages/ed/5e/46168b1f2757f1fcd442bc3029cd8767d88a98c9c05770d8b420948743bb/PyYAML-6.0.2-cp39-cp39-win32.whl", hash = "sha256:6395c297d42274772abc367baaa79683958044e5d3835486c16da75d2a694631", size = 144593 },
    { url = "https://files.pythonhosted.org/packages/19/87/5124b1c1f2412bb95c59ec481eaf936cd32f0fe2a7b16b97b81c4c017a6a/PyYAML-6.0.2-cp39-cp39-win_amd64.whl", hash = "sha256:39693e1f8320ae4f43943590b49779ffb98acb81f788220ea932a6b6c51004d8", size = 162312 },
]

[[package]]
name = "simpy"
version = "4.1.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a8/66/860505ec021a16f9d8cf4b8c4d60ee07bb427649b643312303698c93b551/simpy-4.1.1.tar.gz", hash = "sha256:06d0750a7884b11e0e8e20ce0bc7c6d4ed5f1743d456695340d13fdff95001a6", size = 408997 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/48/72/920ed1224c94a8a5a69e6c1275ac7fe4eb911ba8feffddf469f1629d47f3/simpy-4.1.1-py3-none-any.whl", hash = "sha256:7c5ae380240fd2238671160e4830956f8055830a8317edf5c05e495b3823cd88", size = 27224 },
]

[[package]]
name = "supcon-adventurex-factory-sim"
version = "1.0.0"
source = { editable = "." }
dependencies = [
    { name = "numpy", version = "2.0.2", source = { registry = "https://pypi.org/simple" }, marker = "python_full_version < '3.10'" },
    { name = "numpy", version = "2.2.6", source = { registry = "https://pypi.org/simple" }, marker = "python_full_version == '3.10.*'" },
    { name = "numpy", version = "2.3.1", source = { registry = "https://pypi.org/simple" }, marker = "python_full_version >= '3.11'" },
    { name = "paho-mqtt" },
    { name = "psutil" },
    { name = "pydantic" },
    { name = "pyyaml" },
    { name = "simpy" },
]

[package.dev-dependencies]
dev = [
    { name = "pytest" },
]

[package.metadata]
requires-dist = [
    { name = "numpy" },
    { name = "paho-mqtt" },
    { name = "psutil" },
    { name = "pydantic" },
    { name = "pyyaml" },
    { name = "simpy" },
]

[package.metadata.requires-dev]
dev = [{ name = "pytest" }]

[[package]]
name = "tomli"
version = "2.2.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/18/87/302344fed471e44a87289cf4967697d07e532f2421fdaf868a303cbae4ff/tomli-2.2.1.tar.gz", hash = "sha256:cd45e1dc79c835ce60f7404ec8119f2eb06d38b1deba146f07ced3bbc44505ff", size = 17175 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/43/ca/75707e6efa2b37c77dadb324ae7d9571cb424e61ea73fad7c56c2d14527f/tomli-2.2.1-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:678e4fa69e4575eb77d103de3df8a895e1591b48e740211bd1067378c69e8249", size = 131077 },
    { url = "https://files.pythonhosted.org/packages/c7/16/51ae563a8615d472fdbffc43a3f3d46588c264ac4f024f63f01283becfbb/tomli-2.2.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:023aa114dd824ade0100497eb2318602af309e5a55595f76b626d6d9f3b7b0a6", size = 123429 },
    { url = "https://files.pythonhosted.org/packages/f1/dd/4f6cd1e7b160041db83c694abc78e100473c15d54620083dbd5aae7b990e/tomli-2.2.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:ece47d672db52ac607a3d9599a9d48dcb2f2f735c6c2d1f34130085bb12b112a", size = 226067 },
    { url = "https://files.pythonhosted.org/packages/a9/6b/c54ede5dc70d648cc6361eaf429304b02f2871a345bbdd51e993d6cdf550/tomli-2.2.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:6972ca9c9cc9f0acaa56a8ca1ff51e7af152a9f87fb64623e31d5c83700080ee", size = 236030 },
    { url = "https://files.pythonhosted.org/packages/1f/47/999514fa49cfaf7a92c805a86c3c43f4215621855d151b61c602abb38091/tomli-2.2.1-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:c954d2250168d28797dd4e3ac5cf812a406cd5a92674ee4c8f123c889786aa8e", size = 240898 },
    { url = "https://files.pythonhosted.org/packages/73/41/0a01279a7ae09ee1573b423318e7934674ce06eb33f50936655071d81a24/tomli-2.2.1-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:8dd28b3e155b80f4d54beb40a441d366adcfe740969820caf156c019fb5c7ec4", size = 229894 },
    { url = "https://files.pythonhosted.org/packages/55/18/5d8bc5b0a0362311ce4d18830a5d28943667599a60d20118074ea1b01bb7/tomli-2.2.1-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:e59e304978767a54663af13c07b3d1af22ddee3bb2fb0618ca1593e4f593a106", size = 245319 },
    { url = "https://files.pythonhosted.org/packages/92/a3/7ade0576d17f3cdf5ff44d61390d4b3febb8a9fc2b480c75c47ea048c646/tomli-2.2.1-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:33580bccab0338d00994d7f16f4c4ec25b776af3ffaac1ed74e0b3fc95e885a8", size = 238273 },
    { url = "https://files.pythonhosted.org/packages/72/6f/fa64ef058ac1446a1e51110c375339b3ec6be245af9d14c87c4a6412dd32/tomli-2.2.1-cp311-cp311-win32.whl", hash = "sha256:465af0e0875402f1d226519c9904f37254b3045fc5084697cefb9bdde1ff99ff", size = 98310 },
    { url = "https://files.pythonhosted.org/packages/6a/1c/4a2dcde4a51b81be3530565e92eda625d94dafb46dbeb15069df4caffc34/tomli-2.2.1-cp311-cp311-win_amd64.whl", hash = "sha256:2d0f2fdd22b02c6d81637a3c95f8cd77f995846af7414c5c4b8d0545afa1bc4b", size = 108309 },
    { url = "https://files.pythonhosted.org/packages/52/e1/f8af4c2fcde17500422858155aeb0d7e93477a0d59a98e56cbfe75070fd0/tomli-2.2.1-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:4a8f6e44de52d5e6c657c9fe83b562f5f4256d8ebbfe4ff922c495620a7f6cea", size = 132762 },
    { url = "https://files.pythonhosted.org/packages/03/b8/152c68bb84fc00396b83e7bbddd5ec0bd3dd409db4195e2a9b3e398ad2e3/tomli-2.2.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:8d57ca8095a641b8237d5b079147646153d22552f1c637fd3ba7f4b0b29167a8", size = 123453 },
    { url = "https://files.pythonhosted.org/packages/c8/d6/fc9267af9166f79ac528ff7e8c55c8181ded34eb4b0e93daa767b8841573/tomli-2.2.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:4e340144ad7ae1533cb897d406382b4b6fede8890a03738ff1683af800d54192", size = 233486 },
    { url = "https://files.pythonhosted.org/packages/5c/51/51c3f2884d7bab89af25f678447ea7d297b53b5a3b5730a7cb2ef6069f07/tomli-2.2.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:db2b95f9de79181805df90bedc5a5ab4c165e6ec3fe99f970d0e302f384ad222", size = 242349 },
    { url = "https://files.pythonhosted.org/packages/ab/df/bfa89627d13a5cc22402e441e8a931ef2108403db390ff3345c05253935e/tomli-2.2.1-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:40741994320b232529c802f8bc86da4e1aa9f413db394617b9a256ae0f9a7f77", size = 252159 },
    { url = "https://files.pythonhosted.org/packages/9e/6e/fa2b916dced65763a5168c6ccb91066f7639bdc88b48adda990db10c8c0b/tomli-2.2.1-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:400e720fe168c0f8521520190686ef8ef033fb19fc493da09779e592861b78c6", size = 237243 },
    { url = "https://files.pythonhosted.org/packages/b4/04/885d3b1f650e1153cbb93a6a9782c58a972b94ea4483ae4ac5cedd5e4a09/tomli-2.2.1-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:02abe224de6ae62c19f090f68da4e27b10af2b93213d36cf44e6e1c5abd19fdd", size = 259645 },
    { url = "https://files.pythonhosted.org/packages/9c/de/6b432d66e986e501586da298e28ebeefd3edc2c780f3ad73d22566034239/tomli-2.2.1-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:b82ebccc8c8a36f2094e969560a1b836758481f3dc360ce9a3277c65f374285e", size = 244584 },
    { url = "https://files.pythonhosted.org/packages/1c/9a/47c0449b98e6e7d1be6cbac02f93dd79003234ddc4aaab6ba07a9a7482e2/tomli-2.2.1-cp312-cp312-win32.whl", hash = "sha256:889f80ef92701b9dbb224e49ec87c645ce5df3fa2cc548664eb8a25e03127a98", size = 98875 },
    { url = "https://files.pythonhosted.org/packages/ef/60/9b9638f081c6f1261e2688bd487625cd1e660d0a85bd469e91d8db969734/tomli-2.2.1-cp312-cp312-win_amd64.whl", hash = "sha256:7fc04e92e1d624a4a63c76474610238576942d6b8950a2d7f908a340494e67e4", size = 109418 },
    { url = "https://files.pythonhosted.org/packages/04/90/2ee5f2e0362cb8a0b6499dc44f4d7d48f8fff06d28ba46e6f1eaa61a1388/tomli-2.2.1-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:f4039b9cbc3048b2416cc57ab3bda989a6fcf9b36cf8937f01a6e731b64f80d7", size = 132708 },
    { url = "https://files.pythonhosted.org/packages/c0/ec/46b4108816de6b385141f082ba99e315501ccd0a2ea23db4a100dd3990ea/tomli-2.2.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:286f0ca2ffeeb5b9bd4fcc8d6c330534323ec51b2f52da063b11c502da16f30c", size = 123582 },
    { url = "https://files.pythonhosted.org/packages/a0/bd/b470466d0137b37b68d24556c38a0cc819e8febe392d5b199dcd7f578365/tomli-2.2.1-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a92ef1a44547e894e2a17d24e7557a5e85a9e1d0048b0b5e7541f76c5032cb13", size = 232543 },
    { url = "https://files.pythonhosted.org/packages/d9/e5/82e80ff3b751373f7cead2815bcbe2d51c895b3c990686741a8e56ec42ab/tomli-2.2.1-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9316dc65bed1684c9a98ee68759ceaed29d229e985297003e494aa825ebb0281", size = 241691 },
    { url = "https://files.pythonhosted.org/packages/05/7e/2a110bc2713557d6a1bfb06af23dd01e7dde52b6ee7dadc589868f9abfac/tomli-2.2.1-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:e85e99945e688e32d5a35c1ff38ed0b3f41f43fad8df0bdf79f72b2ba7bc5272", size = 251170 },
    { url = "https://files.pythonhosted.org/packages/64/7b/22d713946efe00e0adbcdfd6d1aa119ae03fd0b60ebed51ebb3fa9f5a2e5/tomli-2.2.1-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:ac065718db92ca818f8d6141b5f66369833d4a80a9d74435a268c52bdfa73140", size = 236530 },
    { url = "https://files.pythonhosted.org/packages/38/31/3a76f67da4b0cf37b742ca76beaf819dca0ebef26d78fc794a576e08accf/tomli-2.2.1-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:d920f33822747519673ee656a4b6ac33e382eca9d331c87770faa3eef562aeb2", size = 258666 },
    { url = "https://files.pythonhosted.org/packages/07/10/5af1293da642aded87e8a988753945d0cf7e00a9452d3911dd3bb354c9e2/tomli-2.2.1-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:a198f10c4d1b1375d7687bc25294306e551bf1abfa4eace6650070a5c1ae2744", size = 243954 },
    { url = "https://files.pythonhosted.org/packages/5b/b9/1ed31d167be802da0fc95020d04cd27b7d7065cc6fbefdd2f9186f60d7bd/tomli-2.2.1-cp313-cp313-win32.whl", hash = "sha256:d3f5614314d758649ab2ab3a62d4f2004c825922f9e370b29416484086b264ec", size = 98724 },
    { url = "https://files.pythonhosted.org/packages/c7/32/b0963458706accd9afcfeb867c0f9175a741bf7b19cd424230714d722198/tomli-2.2.1-cp313-cp313-win_amd64.whl", hash = "sha256:a38aa0308e754b0e3c67e344754dff64999ff9b513e691d0e786265c93583c69", size = 109383 },
    { url = "https://files.pythonhosted.org/packages/6e/c2/61d3e0f47e2b74ef40a68b9e6ad5984f6241a942f7cd3bbfbdbd03861ea9/tomli-2.2.1-py3-none-any.whl", hash = "sha256:cb55c73c5f4408779d0cf3eef9f762b9c9f147a77de7b258bef0a5628adc85cc", size = 14257 },
]

[[package]]
name = "typing-extensions"
version = "4.14.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d1/bc/51647cd02527e87d05cb083ccc402f93e441606ff1f01739a62c8ad09ba5/typing_extensions-4.14.0.tar.gz", hash = "sha256:8676b788e32f02ab42d9e7c61324048ae4c6d844a399eebace3d4979d75ceef4", size = 107423 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/69/e0/552843e0d356fbb5256d21449fa957fa4eff3bbc135a74a691ee70c7c5da/typing_extensions-4.14.0-py3-none-any.whl", hash = "sha256:a1514509136dd0b477638fc68d6a91497af5076466ad0fa6c338e44e359944af", size = 43839 },
]

[[package]]
name = "typing-inspection"
version = "0.4.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/f8/b1/0c11f5058406b3af7609f121aaa6b609744687f1d158b3c3a5bf4cc94238/typing_inspection-0.4.1.tar.gz", hash = "sha256:6ae134cc0203c33377d43188d4064e9b357dba58cff3185f22924610e70a9d28", size = 75726 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/17/69/cd203477f944c353c31bade965f880aa1061fd6bf05ded0726ca845b6ff7/typing_inspection-0.4.1-py3-none-any.whl", hash = "sha256:389055682238f53b04f7badcb49b989835495a96700ced5dab2d8feae4b26f51", size = 14552 },
]



================================================
File: .python-version
================================================
3.11



================================================
File: config/factory_layout.yml
================================================
# SUPCON Factory Layout Configuration
# This file defines the physical layout and parameters of the factory simulation

factory:
  name: "SUPCON AdventureX NLDF"
  description: "自然语言驱动智能制造仿真工厂"

# 工站配置
stations:
  - id: "StationA"
    # name: "组装工站"
    position: [15, 20]
    buffer_size: 3
    processing_times: # 产品类型: [最小时间, 最大时间] (秒)
      P1: [5, 5] #[30, 45]
      P2: [5, 5] #[40, 60]
      P3: [5, 5] #[35, 50]
    interacting_points: [P1]

  - id: "StationB"
    # name: "焊接工站"
    position: [35, 20]
    buffer_size: 3
    processing_times:
      P1: [5, 5] #[45, 60]
      P2: [5, 5] #[60, 80]
      P3: [5, 5] #[50, 70]
    interacting_points: [P3]

  - id: "StationC"
    # name: "测试工站"
    position: [55, 20]
    buffer_size: 3
    processing_times:
      P1: [5, 5] #[20, 30]
      P2: [5, 5] #[30, 40]
      P3: [5, 5] #[25, 35]
    interacting_points: [P5]

  - id: "QualityCheck"
    # name: "质量检测站"
    position: [75, 20]
    buffer_size: 1
    processing_times:
      P1: [5, 5] #[15, 25]
      P2: [5, 5] #[20, 30]
      P3: [5, 5] #[20, 30]
    output_buffer_capacity: 4
    interacting_points: [P7, P8]

# AGV配置
agvs:
  - id: "AGV_1"
    position: [10, 10] # initial position
    path_points:
      P0: [5, 15] # raw material warehouse
      P1: [12, 15] # StationA
      P2: [25, 15] # Conveyor_AB
      P3: [32, 15] # StationB
      P4: [45, 15] # Conveyor_BC
      P5: [52, 15] # StationC
      P6: [65, 10] # Conveyor_CQ_lower
      P7: [72, 15] # QualityChecker
      P8: [80, 15] # QualityChecker_output
      P9: [95, 15] # Warehouse
      P10: [10, 10] # Charging Area
    speed_mps: 2.0 # 移动速度 (米/秒)
    payload_capacity: 2 # 最大载货数量
    low_battery_threshold: 5.0 # 低电量阈值
    charging_point: P10 # 充电点坐标
    charging_speed: 3.33 # 充电速度(30秒充满)
    battery_consumption_per_meter: 0.1 # 每米消耗0.1%电量
    battery_consumption_per_action: 0.5 # 每次操作消耗0.5%电量

  - id: "AGV_2"
    position: [10, 30]
    path_points:
      P0: [5, 25]
      P1: [12, 25]
      P2: [25, 25]
      P3: [32, 25]
      P4: [45, 25]
      P5: [52, 25]
      P6: [65, 25]
      P7: [72, 25]
      P8: [80, 25]
      P9: [95, 25]
      P10: [10, 30]
    speed_mps: 2.0
    payload_capacity: 2
    low_battery_threshold: 5.0
    charging_point: P10
    charging_speed: 3.33
    battery_consumption_per_meter: 0.1
    battery_consumption_per_action: 0.5

conveyors:
  - id: "Conveyor_AB"
    position: [25, 20]
    transfer_time: 5.0
    capacity: 3
    interacting_points: [P2]

  - id: "Conveyor_BC"
    position: [45, 20]
    transfer_time: 5.0
    capacity: 3
    interacting_points: [P4]

  - id: "Conveyor_CQ"
    position: [65, 20]
    transfer_time: 5.0
    main_capacity: 4
    upper_capacity: 2
    lower_capacity: 2
    interacting_points: [P6]

warehouses:
  - id: "RawMaterial"
    position: [0, 20]
    interacting_points: [P0]

  - id: "Warehouse"
    position: [95, 20]
    interacting_points: [P9]

# 订单生成器配置
order_generator:
  generation_interval_range: [10, 10] # 最小/最大间隔 (秒)
  quantity_weights:
    1: 0.40
    2: 0.30
    3: 0.20
    4: 0.07
    5: 0.03
  product_distribution:
    P1: 0.60
    P2: 0.30
    P3: 0.10
  priority_distribution:
    low: 0.70
    medium: 0.25
    high: 0.05
  deadline_multipliers:
    low: 3.0
    medium: 2.0
    high: 1.5
  theoretical_production_times:
    P1: 160
    P2: 200
    P3: 250

# 故障系统参数
fault_system:
  fault_injection_interval: [120, 180] # 故障注入间隔 (2-3分钟)
  auto_recovery_time: [600, 1800] # 自动恢复时间 (10-30分钟)
  device_relationships:
    StationA: ["StationB", "AGV_1"]
    StationB: ["StationA", "StationC", "AGV_1", "AGV_2"]
    StationC: ["StationB", "QualityCheck", "AGV_2"]
    QualityCheck: ["StationC"]
    AGV_1: ["StationA", "StationB"]
    AGV_2: ["StationB", "StationC"]

# KPI计算权重
kpi_weights:
  production_efficiency: 0.40 # 生产效率 40%
  quality_cost: 0.30 # 质量与成本 30%
  agv_efficiency: 0.30 # AGV操控效率 30%
  
  # 生产效率子权重 (总和应为1.0)
  efficiency_components:
    order_completion: 0.40    # 订单完成率权重
    production_cycle: 0.40    # 生产周期效率权重
    device_utilization: 0.20  # 设备利用率权重
  
  # 质量成本子权重 (总和应为1.0)
  quality_cost_components:
    first_pass_rate: 0.40     # 一次通过率权重
    cost_efficiency: 0.60     # 成本效率权重
  
  # AGV效率子权重 (总和应为1.0)
  agv_components:
    charge_strategy: 0.30     # 充电策略效率权重
    energy_efficiency: 0.40   # 能效比权重
    utilization: 0.30         # AGV利用率权重

# KPI成本参数
kpi_costs:
  material_cost_per_product:
    P1: 10.0
    P2: 15.0
    P3: 20.0
  energy_cost_per_second: 0.2
  energy_cost_multiplier_peak: 1.5
  maintenance_cost_base: 8.0  # ~25% of average product cost, ~80s of energy cost
  scrap_cost_multiplier: 0.8

# 系统性能参数
system:
  status_publish_interval: 10.0 # 状态发布间隔 (秒)
  simulation_step_size: 0.1 # 仿真步长 (秒)
  max_concurrent_orders: 20 # 最大并发订单数



================================================
File: config/factory_layout_multi.yml
================================================
# SUPCON Factory Layout Configuration for Multiple Lines
# This file defines the physical layout and parameters of the factory simulation

factory:
  name: "SUPCON AdventureX NLDF"
  description: "自然语言驱动智能制造仿真工厂"

# # 系统性能参数 (Global)
# system:
#   status_publish_interval: 10.0  # 状态发布间隔 (秒)
#   simulation_step_size: 0.1      # 仿真步长 (秒)
#   max_concurrent_orders: 20      # 最大并发订单数

warehouses:
  - id: "RawMaterial"
    position: [0, 20]
    interacting_points: [P0]
  - id: "Warehouse"
    position: [95, 20]
    interacting_points: [P9]

order_generator:
  generation_interval_range: [10, 10]
  quantity_weights: {1: 0.4, 2: 0.3, 3: 0.2, 4: 0.07, 5: 0.03}
  product_distribution: {P1: 0.6, P2: 0.3, P3: 0.1}
  priority_distribution: {low: 0.7, medium: 0.25, high: 0.05}
  deadline_multipliers: {low: 3.0, medium: 2.0, high: 1.5}
  theoretical_production_times: {P1: 160, P2: 200, P3: 250}

production_lines:
  - name: "line1"
    stations:
      - id: "StationA"
        position: [15, 20]
        buffer_size: 2
        processing_times:
          P1: [5, 5]
          P2: [5, 5]
          P3: [5, 5]
        interacting_points: [P1]

      - id: "StationB"
        position: [35, 20]
        buffer_size: 2
        processing_times:
          P1: [5, 5]
          P2: [5, 5]
          P3: [5, 5]
        interacting_points: [P3]

      - id: "StationC"
        position: [55, 20]
        buffer_size: 2
        processing_times:
          P1: [5, 5]
          P2: [5, 5]
          P3: [5, 5]
        interacting_points: [P5]

      - id: "QualityCheck"
        position: [75, 20]
        buffer_size: 2
        processing_times:
          P1: [5, 5]
          P2: [5, 5]
          P3: [5, 5]
        output_buffer_capacity: 4
        interacting_points: [P7, P8]
        # pass_threshold: 99
        # scrap_threshold: 98
        
    agvs:
      - id: "AGV_1"
        position: [10, 10]
        path_points:
          P0: [5, 15]
          P1: [12, 15]
          P2: [25, 15]
          P3: [32, 15]
          P4: [45, 15]
          P5: [52, 15]
          P6: [65, 10]
          P7: [72, 15]
          P8: [80, 15]
          P9: [95, 15]
          P10: [10, 10]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.1
        battery_consumption_per_action: 0.5
      - id: "AGV_2"
        position: [10, 30]
        path_points:
          P0: [5, 25]
          P1: [12, 25]
          P2: [25, 25]
          P3: [32, 25]
          P4: [45, 25]
          P5: [52, 25]
          P6: [65, 25]
          P7: [72, 25]
          P8: [80, 25]
          P9: [95, 25]
          P10: [10, 30]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.5
        battery_consumption_per_action: 0.5
    agv_operations:
      AGV_1:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "lower", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
      AGV_2:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "upper", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
    conveyors:
      - id: "Conveyor_AB"
        position: [25, 20]
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P2]
      - id: "Conveyor_BC"
        position: [45, 20]
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P4]
      - id: "Conveyor_CQ"
        position: [65, 20]
        transfer_time: 5.0
        main_capacity: 4
        upper_capacity: 2
        lower_capacity: 2
        interacting_points: [P6]

    fault_system:
      fault_injection_interval: [120, 180]
      auto_recovery_time: [600, 1800]
      device_relationships:
        StationA: ["StationB", "AGV_1"]
        StationB: ["StationA", "StationC", "AGV_1", "AGV_2"]
        StationC: ["StationB", "QualityCheck", "AGV_2"]
        QualityCheck: ["StationC"]
        AGV_1: ["StationA", "StationB"]
        AGV_2: ["StationB", "StationC"]

  - name: "line2"
    stations:
      - id: "StationA"
        position: [15, 60] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P1]
      - id: "StationB"
        position: [35, 60] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P3]
      - id: "StationC"
        position: [55, 60] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P5]
      - id: "QualityCheck"
        position: [75, 60] # Changed Y coordinate
        buffer_size: 1
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        output_buffer_capacity: 4
        interacting_points: [P7, P8]
    agvs:
      - id: "AGV_1"
        position: [10, 50] # Changed Y coordinate
        path_points:
          P0: [5, 55]
          P1: [12, 55]
          P2: [25, 55]
          P3: [32, 55]
          P4: [45, 55]
          P5: [52, 55]
          P6: [65, 50]
          P7: [72, 55]
          P8: [80, 55]
          P9: [95, 55]
          P10: [10, 50]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.1
        battery_consumption_per_action: 0.5
      - id: "AGV_2"
        position: [10, 70] # Changed Y coordinate
        path_points:
          P0: [5, 65]
          P1: [12, 65]
          P2: [25, 65]
          P3: [32, 65]
          P4: [45, 65]
          P5: [52, 65]
          P6: [65, 65]
          P7: [72, 65]
          P8: [80, 65]
          P9: [95, 65]
          P10: [10, 70]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.1
        battery_consumption_per_action: 0.5
    agv_operations:
      AGV_1:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "lower", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
      AGV_2:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "upper", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
    conveyors:
      - id: "Conveyor_AB"
        position: [25, 60] # Changed Y coordinate
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P2]
      - id: "Conveyor_BC"
        position: [45, 60] # Changed Y coordinate
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P4]
      - id: "Conveyor_CQ"
        position: [65, 60] # Changed Y coordinate
        transfer_time: 5.0
        main_capacity: 4
        upper_capacity: 2
        lower_capacity: 2
        interacting_points: [P6]
    fault_system:
      fault_injection_interval: [120, 180]
      auto_recovery_time: [600, 1800]
      device_relationships:
        StationA: ["StationB", "AGV_1"]
        StationB: ["StationA", "StationC", "AGV_1", "AGV_2"]
        StationC: ["StationB", "QualityCheck", "AGV_2"]
        QualityCheck: ["StationC"]
        AGV_1: ["StationA", "StationB"]
        AGV_2: ["StationB", "StationC"]

  - name: "line3"
    stations:
      - id: "StationA"
        position: [15, 100] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P1]
      - id: "StationB"
        position: [35, 100] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P3]
      - id: "StationC"
        position: [55, 100] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P5]
      - id: "QualityCheck"
        position: [75, 100] # Changed Y coordinate
        buffer_size: 1
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        output_buffer_capacity: 4
        interacting_points: [P7, P8]
    agvs:
      - id: "AGV_1"
        position: [10, 90] # Changed Y coordinate
        path_points:
          P0: [5, 95]
          P1: [12, 95]
          P2: [25, 95]
          P3: [32, 95]
          P4: [45, 95]
          P5: [52, 95]
          P6: [65, 90]
          P7: [72, 95]
          P8: [80, 95]
          P9: [95, 95]
          P10: [10, 90]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.1
        battery_consumption_per_action: 0.5
      - id: "AGV_2"
        position: [10, 110] # Changed Y coordinate
        path_points:
          P0: [5, 105]
          P1: [12, 105]
          P2: [25, 105]
          P3: [32, 105]
          P4: [45, 105]
          P5: [52, 105]
          P6: [65, 105]
          P7: [72, 105]
          P8: [80, 105]
          P9: [95, 105]
          P10: [10, 110]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.1
        battery_consumption_per_action: 0.5
    agv_operations:
      AGV_1:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "lower", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
      AGV_2:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "upper", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
    conveyors:
      - id: "Conveyor_AB"
        position: [25, 100] # Changed Y coordinate
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P2]
      - id: "Conveyor_BC"
        position: [45, 100] # Changed Y coordinate
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P4]
      - id: "Conveyor_CQ"
        position: [65, 100] # Changed Y coordinate
        transfer_time: 5.0
        main_capacity: 4
        upper_capacity: 2
        lower_capacity: 2
        interacting_points: [P6]
    fault_system:
      fault_injection_interval: [120, 180]
      auto_recovery_time: [600, 1800]
      device_relationships:
        StationA: ["StationB", "AGV_1"]
        StationB: ["StationA", "StationC", "AGV_1", "AGV_2"]
        StationC: ["StationB", "QualityCheck", "AGV_2"]
        QualityCheck: ["StationC"]
        AGV_1: ["StationA", "StationB"]
        AGV_2: ["StationB", "StationC"] 


================================================
File: config/path_timing.py
================================================
# config/path_timing.py
"""
Path segment timing configuration for AGV navigation.
Defines the time required to travel between specific path points.
This file is auto-generated from AGVPathInfos.json by tools/process_path_data.py
"""

from typing import Dict, Tuple

# Path segment timing hashtable
# Key: (point_from, point_to) tuple
# Value: travel time in seconds
PATH_SEGMENT_TIMES: Dict[Tuple[str, str], float] = {
    ("P0", "P1"): 5.91666651,
    ("P0", "P10"): 8.949999,
    ("P0", "P11"): 2.98333287,
    ("P0", "P12"): 2.48000026,
    ("P0", "P13"): 16.6035519,
    ("P0", "P14"): 13.7135525,
    ("P0", "P15"): 2.50333285,
    ("P0", "P16"): 6.083333,
    ("P0", "P17"): 6.72,
    ("P0", "P18"): 9.636667,
    ("P0", "P19"): 11.3233328,
    ("P0", "P2"): 9.02,
    ("P0", "P20"): 12.1602192,
    ("P0", "P3"): 9.656666,
    ("P0", "P4"): 11.8866653,
    ("P0", "P5"): 12.5733328,
    ("P0", "P6"): 13.63335,
    ("P0", "P7"): 15.0968876,
    ("P0", "P8"): 16.65022,
    ("P0", "P9"): 19.54022,
    ("P1", "P10"): 11.8600006,
    ("P1", "P11"): 2.9333334,
    ("P1", "P12"): 5.436666,
    ("P1", "P13"): 19.5135536,
    ("P1", "P14"): 16.6235542,
    ("P1", "P15"): 3.41333342,
    ("P1", "P16"): 8.993334,
    ("P1", "P17"): 9.630001,
    ("P1", "P18"): 12.5466671,
    ("P1", "P19"): 14.2333336,
    ("P1", "P2"): 11.93,
    ("P1", "P20"): 15.0702209,
    ("P1", "P3"): 12.5666676,
    ("P1", "P4"): 14.7966661,
    ("P1", "P5"): 15.4833336,
    ("P1", "P6"): 16.54335,
    ("P1", "P7"): 18.0068874,
    ("P1", "P8"): 19.56022,
    ("P1", "P9"): 22.45022,
    ("P10", "P11"): 10.9266663,
    ("P10", "P12"): 11.43,
    ("P10", "P13"): 9.653553,
    ("P10", "P14"): 6.76355362,
    ("P10", "P15"): 8.446667,
    ("P10", "P16"): 4.866666,
    ("P10", "P17"): 4.22999954,
    ("P10", "P18"): 2.6866672,
    ("P10", "P19"): 4.37333345,
    ("P10", "P20"): 5.21022034,
    ("P11", "P12"): 2.50333285,
    ("P11", "P13"): 18.58022,
    ("P11", "P14"): 15.69022,
    ("P11", "P15"): 2.48000026,
    ("P11", "P16"): 8.06,
    ("P11", "P17"): 8.696667,
    ("P11", "P18"): 11.6133327,
    ("P11", "P19"): 13.3,
    ("P11", "P20"): 14.1368866,
    ("P12", "P13"): 19.0835514,
    ("P12", "P14"): 16.193552,
    ("P12", "P15"): 4.983333,
    ("P12", "P16"): 8.56333351,
    ("P12", "P17"): 9.2,
    ("P12", "P18"): 12.1166658,
    ("P12", "P19"): 13.8033323,
    ("P12", "P20"): 14.6402187,
    ("P13", "P14"): 4.88999939,
    ("P13", "P15"): 16.10022,
    ("P13", "P16"): 12.52022,
    ("P13", "P17"): 11.8835526,
    ("P13", "P18"): 8.96688652,
    ("P13", "P19"): 7.28,
    ("P13", "P20"): 6.443333,
    ("P14", "P15"): 13.21022,
    ("P14", "P16"): 9.630219,
    ("P14", "P17"): 8.993553,
    ("P14", "P18"): 6.076886,
    ("P14", "P19"): 4.39000034,
    ("P14", "P20"): 3.55333328,
    ("P15", "P16"): 5.58,
    ("P15", "P17"): 6.2166667,
    ("P15", "P18"): 9.133333,
    ("P15", "P19"): 10.8200006,
    ("P15", "P20"): 11.6568871,
    ("P16", "P17"): 2.63666654,
    ("P16", "P18"): 5.55333328,
    ("P16", "P19"): 7.24,
    ("P16", "P20"): 8.076886,
    ("P17", "P18"): 4.916667,
    ("P17", "P19"): 6.603333,
    ("P17", "P20"): 7.44022,
    ("P18", "P19"): 3.68666649,
    ("P18", "P20"): 4.523553,
    ("P19", "P20"): 2.83666682,
    ("P2", "P10"): 7.80333328,
    ("P2", "P11"): 10.9966679,
    ("P2", "P12"): 11.5,
    ("P2", "P13"): 15.4568863,
    ("P2", "P14"): 12.5668869,
    ("P2", "P15"): 8.516666,
    ("P2", "P16"): 2.93666673,
    ("P2", "P17"): 3.57333326,
    ("P2", "P18"): 6.49000025,
    ("P2", "P19"): 10.1766663,
    ("P2", "P20"): 11.0135527,
    ("P2", "P3"): 2.63666654,
    ("P2", "P4"): 4.866666,
    ("P2", "P5"): 5.55333328,
    ("P2", "P6"): 12.4866829,
    ("P2", "P7"): 13.9502192,
    ("P2", "P8"): 15.5035534,
    ("P2", "P9"): 18.3935528,
    ("P3", "P10"): 7.166666,
    ("P3", "P11"): 11.6333332,
    ("P3", "P12"): 12.1366673,
    ("P3", "P13"): 14.820219,
    ("P3", "P14"): 11.93022,
    ("P3", "P15"): 9.153334,
    ("P3", "P16"): 3.57333326,
    ("P3", "P17"): 2.93666673,
    ("P3", "P18"): 5.85333347,
    ("P3", "P19"): 9.539999,
    ("P3", "P20"): 10.3768864,
    ("P3", "P4"): 4.22999954,
    ("P3", "P5"): 4.916667,
    ("P3", "P6"): 11.8500156,
    ("P3", "P7"): 13.3135529,
    ("P3", "P8"): 14.8668861,
    ("P3", "P9"): 17.7568855,
    ("P4", "P10"): 2.93666673,
    ("P4", "P11"): 13.8633327,
    ("P4", "P12"): 14.3666658,
    ("P4", "P13"): 12.5902195,
    ("P4", "P14"): 9.70022,
    ("P4", "P15"): 11.3833332,
    ("P4", "P16"): 5.80333328,
    ("P4", "P17"): 7.166666,
    ("P4", "P18"): 3.623334,
    ("P4", "P19"): 7.31000042,
    ("P4", "P20"): 8.146887,
    ("P4", "P5"): 2.6866672,
    ("P4", "P6"): 9.620016,
    ("P4", "P7"): 11.0835533,
    ("P4", "P8"): 12.6368866,
    ("P4", "P9"): 15.526886,
    ("P5", "P10"): 3.623334,
    ("P5", "P11"): 14.55,
    ("P5", "P12"): 15.0533333,
    ("P5", "P13"): 11.903553,
    ("P5", "P14"): 9.013554,
    ("P5", "P15"): 12.0700006,
    ("P5", "P16"): 6.49000025,
    ("P5", "P17"): 7.85333347,
    ("P5", "P18"): 2.93666673,
    ("P5", "P19"): 6.623333,
    ("P5", "P20"): 7.46022,
    ("P5", "P6"): 8.93335,
    ("P5", "P7"): 10.3968868,
    ("P5", "P8"): 11.95022,
    ("P5", "P9"): 14.8402195,
    ("P6", "P10"): 6.68335056,
    ("P6", "P11"): 15.6100159,
    ("P6", "P12"): 16.11335,
    ("P6", "P13"): 9.576327,
    ("P6", "P14"): 6.686328,
    ("P6", "P15"): 13.1300163,
    ("P6", "P16"): 9.550016,
    ("P6", "P17"): 8.91335,
    ("P6", "P18"): 5.9966836,
    ("P6", "P19"): 2.310018,
    ("P6", "P20"): 5.13299465,
    ("P6", "P7"): 8.069662,
    ("P6", "P8"): 9.622995,
    ("P6", "P9"): 12.5129948,
    ("P7", "P10"): 8.146887,
    ("P7", "P11"): 17.0735531,
    ("P7", "P12"): 17.5768871,
    ("P7", "P13"): 9.379999,
    ("P7", "P14"): 6.49,
    ("P7", "P15"): 14.5935535,
    ("P7", "P16"): 11.0135536,
    ("P7", "P17"): 10.3768864,
    ("P7", "P18"): 7.46022,
    ("P7", "P19"): 5.77333355,
    ("P7", "P20"): 2.93666673,
    ("P7", "P8"): 3.55333328,
    ("P7", "P9"): 6.443333,
    ("P8", "P10"): 9.70022,
    ("P8", "P11"): 18.6268883,
    ("P8", "P12"): 19.13022,
    ("P8", "P13"): 7.826667,
    ("P8", "P14"): 2.93666673,
    ("P8", "P15"): 16.1468868,
    ("P8", "P16"): 12.5668869,
    ("P8", "P17"): 11.93022,
    ("P8", "P18"): 9.013554,
    ("P8", "P19"): 7.326667,
    ("P8", "P20"): 6.49,
    ("P8", "P9"): 4.88999939,
    ("P9", "P10"): 12.5902195,
    ("P9", "P11"): 21.5168877,
    ("P9", "P12"): 22.0202179,
    ("P9", "P13"): 2.93666673,
    ("P9", "P14"): 7.826667,
    ("P9", "P15"): 19.0368862,
    ("P9", "P16"): 15.4568863,
    ("P9", "P17"): 14.820219,
    ("P9", "P18"): 11.903553,
    ("P9", "P19"): 10.2166672,
    ("P9", "P20"): 9.379999,
}


def get_travel_time(from_point: str, to_point: str) -> float:
    """
    Get travel time between two path points, considering bidirectional paths.
    
    Args:
        from_point: Starting path point (e.g., "P0")
        to_point: Destination path point (e.g., "P1")
        
    Returns:
        Travel time in seconds, or -1.0 if path not found
    """
    segment = (from_point, to_point)
    segment_reverse = (to_point, from_point)
    if segment in PATH_SEGMENT_TIMES:
        return PATH_SEGMENT_TIMES[segment]
    elif segment_reverse in PATH_SEGMENT_TIMES:
        return PATH_SEGMENT_TIMES[segment_reverse]
    else:
        return -1.0


def get_all_reachable_points(from_point: str) -> Dict[str, float]:
    """
    Get all points reachable from a given point with their travel times.
    This function considers paths to be bidirectional.
    
    Args:
        from_point: Starting path point
        
    Returns:
        Dictionary mapping destination points to travel times
    """
    reachable = {}
    for (start, end), time in PATH_SEGMENT_TIMES.items():
        if start == from_point:
            reachable[end] = time
        elif end == from_point:
            reachable[start] = time
    return reachable


def is_path_available(from_point: str, to_point: str) -> bool:
    """
    Check if a direct path exists between two points, considering bidirectional paths.
    
    Args:
        from_point: Starting path point
        to_point: Destination path point
        
    Returns:
        True if direct path exists, False otherwise
    """
    segment = (from_point, to_point)
    segment_reverse = (to_point, from_point)
    return segment in PATH_SEGMENT_TIMES or segment_reverse in PATH_SEGMENT_TIMES



================================================
File: config/schemas.py
================================================
# config/schemas.py
from typing import Optional, Dict, Any, List
from pydantic import BaseModel, Field
from enum import Enum
from src.simulation.entities.product import Product

# --- Enums for Statuses and Priorities ---

class DeviceStatus(str, Enum):
    IDLE = "idle"
    PROCESSING = "processing"
    MAINTENANCE = "maintenance"
    SCRAP = "scrap"

    WORKING = "working"    # 正常工作中
    BLOCKED = "blocked"    # 被堵塞
    FAULT = "fault"        # 故障状态

    # AGV
    MOVING = "moving"
    INTERACTING = "interacting"  # New status for device-to-device interaction
    CHARGING = "charging"

class OrderPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

# --- 新增：设备详细状态信息 ---

class DeviceDetailedStatus(BaseModel):
    """设备详细状态信息，用于inspect功能"""
    # 基础信息
    device_id: str = Field(..., description="设备ID")
    device_type: str = Field(..., description="设备类型（station/agv）")
    current_status: DeviceStatus = Field(..., description="当前设备状态")
    
    # 性能指标
    temperature: float = Field(..., description="设备温度（°C）")
    vibration_level: float = Field(..., description="振动水平（mm/s）")
    power_consumption: float = Field(..., description="功耗（W）")
    efficiency_rate: float = Field(..., description="效率率（%）")
    
    # 工作状态
    cycle_count: int = Field(..., description="工作循环次数")
    last_maintenance_time: float = Field(..., description="上次维护时间")
    operating_hours: float = Field(..., description="运行小时数")
    
    # 故障相关
    fault_symptom: Optional[str] = Field(None, description="故障症状")
    frozen_until: Optional[float] = Field(None, description="冻结到什么时候")
    
    # 特定于工站的属性
    precision_level: Optional[float] = Field(None, description="加工精度水平")
    tool_wear_level: Optional[float] = Field(None, description="刀具磨损程度")
    lubricant_level: Optional[float] = Field(None, description="润滑油水平")
    
    # 特定于AGV的属性
    battery_level: Optional[float] = Field(None, description="电池电量")
    position_accuracy: Optional[float] = Field(None, description="定位精度")
    load_weight: Optional[float] = Field(None, description="当前载重")

class DiagnosisResult(BaseModel):
    """诊断结果schema"""
    device_id: str = Field(..., description="设备ID")
    diagnosis_command: str = Field(..., description="诊断命令")
    is_correct: bool = Field(..., description="诊断是否正确")
    repair_time: float = Field(..., description="修复时间（秒）")
    penalty_applied: bool = Field(..., description="是否应用了惩罚")
    affected_devices: List[str] = Field([], description="受影响的其他设备")
    can_skip: bool = Field(..., description="是否可以跳过等待时间")

# --- Schemas for MQTT Messages ---

class AgentCommand(BaseModel):
    """
    Schema for commands sent by the agent to the factory.
    Published to: factory/agent/commands
    """
    command_id: Optional[str] = Field(None, description="The ID of the command.")
    action: str = Field(..., description="The action to be performed, e.g., 'move_agv'.")
    target: str = Field(..., description="The ID of the device or entity to act upon.")
    params: Dict[str, Any] = Field({}, description="A dictionary of parameters for the action.")

class SystemResponse(BaseModel):
    """
    Schema for responses sent by the system to the agent.
    Published to: factory/agent/responses
    """
    timestamp: float = Field(..., description="Simulation timestamp of the response.")
    command_id: Optional[str] = Field(None, description="The ID of the command.")
    response: str = Field(..., description="The response to the command.")

class ProductInfo(BaseModel):
    """简化的产品信息，用于MQTT传输"""
    id: str = Field(..., description="Product ID")
    product_type: str = Field(..., description="Product type (P1, P2, P3)")
    quality_score: float = Field(..., description="Current quality score")
    rework_count: int = Field(0, description="Number of reworks")

class StationStatus(BaseModel):
    """
    Schema for the status of a production station.
    Published to: NLDF/line1/station/{id}/status
    """
    timestamp: float = Field(..., description="Simulation timestamp of the status update.")
    source_id: str = Field(..., description="ID of the station (e.g., 'Station_A').")
    status: DeviceStatus = Field(..., description="Current status of the station.")
    message: Optional[str] = Field(None, description="Current action message, e.g., 'emergency charging', 'voluntary charging', 'moving to P1'.")
    buffer: List[str] = Field(..., description="List of product IDs in the buffer.")
    stats: Dict[str, Any] = Field(..., description="Statistics of the station.")
    # Optional fields, primarily for QualityChecker
    output_buffer: List[str] = Field([], description="List of product IDs in the output buffer.")

class AGVStatus(BaseModel):
    """
    Schema for the status of an Automated Guided Vehicle (AGV).
    Published to: NLDF/line1/agv/{id}/status
    """
    timestamp: float = Field(..., description="Simulation timestamp of the status update.")
    source_id: str = Field(..., description="ID of the AGV (e.g., 'AGV_1').")
    status: DeviceStatus = Field(..., description="Current status of the AGV.")
    speed_mps: float = Field(..., description="Current speed of the AGV (m/s).")
    current_point: str = Field(..., description="Current point of the AGV, e.g., 'P1'.")
    position: Dict[str, float] = Field(..., description="Current coordinates of the AGV, e.g., {'x': 10.0, 'y': 15.0}.")
    target_point: Optional[str] = Field(None, description="Target point of the AGV if moving. eg. 'P1'")
    estimated_time: float = Field(..., description="Estimated time to complete the task or moving to the target point.")
    payload: List[str] = Field(..., description="List of product IDs currently being carried.")
    battery_level: float = Field(..., ge=0, le=100, description="Current battery level (0-100%).")
    message: Optional[str] = Field(None, description="Current action message, e.g., 'emergency charging', 'voluntary charging', 'moving to P1'.")

class ConveyorStatus(BaseModel):
    """传送带状态的数据模型"""
    timestamp: float = Field(..., description="Simulation timestamp of the status update.")
    source_id: str = Field(..., description="ID of the conveyor (e.g., 'Conveyor_1').")
    status: DeviceStatus = Field(..., description="Current status of the conveyor.")
    message: Optional[str] = Field(None, description="Current action message, e.g., 'emergency charging', 'voluntary charging', 'moving to P1'.")
    # For TripleBufferConveyor, buffer is the main buffer
    buffer: List[str] = Field(..., description="List of product IDs in the buffer.")
    # Only for TripleBufferConveyor
    upper_buffer: Optional[List[str]] = Field(None, description="List of product IDs in the upper buffer.")
    lower_buffer: Optional[List[str]] = Field(None, description="List of product IDs in the lower buffer.")
    # 可选：包含详细产品信息
    # buffer_details: Optional[List[ProductInfo]] = Field(None, description="Detailed product information in buffers")

class WarehouseStatus(BaseModel):
    """
    Schema for the status of a warehouse.
    Published to: NLDF/line1/warehouse/{id}/status
    """
    timestamp: float = Field(..., description="Simulation timestamp of the status update.")
    source_id: str = Field(..., description="ID of the warehouse (e.g., 'Warehouse_1').")
    message: str = Field(..., description="Message of the warehouse.")
    buffer: List[str] = Field(..., description="List of product IDs in the buffer.")
    stats: Dict[str, Any] = Field(..., description="Statistics of the warehouse.")

class OrderItem(BaseModel):
    """A single item within a new order."""
    product_type: str = Field(..., description="Type of the product (e.g., 'P1', 'P2', 'P3').")
    quantity: int = Field(..., gt=0, description="Number of units for this product type.")

class NewOrder(BaseModel):
    """
    Schema for a new manufacturing order.
    Published to: factory/orders/new
    """
    order_id: str = Field(..., description="Unique ID for the new order.")
    created_at: float = Field(..., description="Simulation timestamp when the order was created.")
    items: List[OrderItem] = Field(..., description="List of products and quantities in the order.")
    priority: OrderPriority = Field(..., description="Priority level of the order.")
    deadline: float = Field(..., description="Simulation timestamp by which the order should be completed.")

class FaultAlert(BaseModel):
    """
    Schema for fault alerts.
    Published to: NLDF/line1/alerts/{device_id}
    """
    timestamp: float = Field(..., description="Simulation timestamp of the alert.")
    device_id: str = Field(..., description="ID of the device that triggered the alert.")
    alert_type: str = Field(..., description="Type of the alert.")
    symptom: str = Field(..., description="Symptom of the alert.")
    fault_type: str = Field(..., description="Type of the fault.")
    estimated_duration: float = Field(..., description="Estimated duration of the fault (seconds).")
    message: str = Field(..., description="Message of the alert.")

class KPIUpdate(BaseModel):
    """
    Schema for Key Performance Indicator (KPI) updates.
    Published to: factory/kpi/update
    """
    timestamp: float = Field(..., description="Simulation timestamp of the KPI update.")
    
    # Production Efficiency (40%)
    order_completion_rate: float = Field(..., description="Percentage of orders completed.")
    average_production_cycle: float = Field(..., description="Weighted average of actual/theoretical production time ratio.")
    on_time_delivery_rate: float = Field(..., description="Percentage of orders completed on time.")
    device_utilization: float = Field(..., description="Average device utilization rate (%).")
    
    # Quality Metrics
    first_pass_rate: float = Field(..., description="Percentage of products passing quality check on first try.")
    
    # Cost Control (30%)
    total_production_cost: float = Field(..., description="Total accumulated production cost.")
    material_costs: float = Field(..., description="Total material costs.")
    energy_costs: float = Field(..., description="Total energy costs.")
    maintenance_costs: float = Field(..., description="Total maintenance costs.")
    scrap_costs: float = Field(..., description="Total costs from scrapped products.")
    
    # AGV Efficiency Metrics
    charge_strategy_efficiency: float = Field(0.0, description="Percentage of active charges vs total charges (%).")
    agv_energy_efficiency: float = Field(0.0, description="AGV tasks completed per minute of charging.")
    agv_utilization: float = Field(0.0, description="Average AGV transport time utilization (%).")
    
    # Raw Counts for Reference
    total_orders: int = Field(..., description="Total number of orders received.")
    completed_orders: int = Field(..., description="Number of completed orders.")
    active_orders: int = Field(..., description="Number of currently active orders.")
    total_products: int = Field(..., description="Total number of products produced.")
    active_faults: int = Field(..., description="Number of currently active faults.")

class FactoryStatus(BaseModel):
    """
    Schema for the overall factory status.
    Published to: factory/status
    """
    timestamp: float = Field(..., description="Simulation timestamp.")
    total_stations: int = Field(..., description="Total number of stations in the factory.")
    total_agvs: int = Field(..., description="Total number of AGVs in the factory.")
    active_orders: int = Field(..., description="Number of currently active orders.")
    total_orders: int = Field(..., description="Total number of orders received.")
    completed_orders: int = Field(..., description="Number of completed orders.")
    active_faults: int = Field(..., description="Number of currently active faults.")
    simulation_time: float = Field(..., description="Current simulation time.") 


================================================
File: config/settings.py
================================================
# config/settings.py

# MQTT Broker Configuration
# As specified in the user request.
MQTT_BROKER_HOST = "supos-ce-instance4.supos.app"
MQTT_BROKER_PORT = 1883

# Simulation Settings
SIMULATION_SPEED = 1  # 1 = real-time, 10 = 10x speed
LOG_LEVEL = "INFO"

# Path to factory layout and game rules configurations
FACTORY_LAYOUT_PATH = "config/factory_layout.yml"
GAME_RULES_PATH = "config/game_rules.yml" 


================================================
File: config/topics.py
================================================
# config/topics.py
# MQTT Topic definitions for the SUPCON AdventureX Factory Simulation

# Device status topics (published by factory devices)
# STATION_STATUS_TOPIC = "NLDF1/{line}/station/{device_id}/status"
# AGV_STATUS_TOPIC = "NLDF1/{line}/resource/{device_id}/status"
# QUALITY_CHECKER_STATUS_TOPIC = "NLDF1/{line}/quality/{device_id}/status"
NEW_FACTORY_STATUS_TOPIC = "NLDF1/{line}/{device_type}/{device_id}/status"
FACTORY_STATUS_TOPIC = "NLDF1/{line}/status"

# Buffer full alert topics (published by fault system)
BUFFER_FULL_ALERT_TOPIC = "NLDF1/line1/alerts/buffer_full"
AGV_BATTERY_LOW_ALERT_TOPIC = "NLDF1/line1/alerts/agv_battery_low"

# Order and KPI topics
NEW_ORDER_TOPIC = "NLDF1/line1/orders/status"
KPI_UPDATE_TOPIC = "NLDF1/line1/kpi/status"
RESULT_TOPIC = "NLDF1/line1/result/status"
# Agent command topics (published by AI agents)
AGENT_COMMANDS_TOPIC = "NLDF1/line1/agent/commands"
# Agent response topics (subscribed by AI agents)
AGENT_RESPONSES_TOPIC = "NLDF1/line1/agent/responses"

# Natural language logs for visualization
NL_LOGS_TOPIC = "NLDF1/{line}/agent/nl_logs"

# Topic patterns for subscription
ALL_STATION_STATUS = "NLDF1/{line}/station/+/status"
ALL_AGV_STATUS = "NLDF1/{line}/resource/+/status"
ALL_FACTORY_TOPICS = "NLDF1/{line}/+"

# Legacy topic definitions (keeping for backward compatibility)
STATION_STATUS_TOPIC_PREFIX = "NLDF1/line1/station"
CONVEYOR_STATUS_TOPIC_PREFIX = "NLDF1/line1/conveyor"
AGV_STATUS_TOPIC_PREFIX = "NLDF1/line1/agv"
WAREHOUSE_STATUS_TOPIC_PREFIX = "NLDF1/line1/warehouse"
DEVICE_ALERT_TOPIC = "NLDF1/line1/alerts"

def get_station_status_topic(station_id: str) -> str:
    """Returns the status topic for a specific station."""
    return f"{STATION_STATUS_TOPIC_PREFIX}/{station_id}/status"

def get_conveyor_status_topic(conveyor_id: str) -> str:
    """Returns the status topic for a specific conveyor."""
    return f"{CONVEYOR_STATUS_TOPIC_PREFIX}/{conveyor_id}/status"

def get_agv_status_topic(agv_id: str) -> str:
    """Returns the status topic for a specific AGV."""
    return f"{AGV_STATUS_TOPIC_PREFIX}/{agv_id}/status" 

def get_warehouse_status_topic(warehouse_id: str) -> str:
    """Returns the status topic for a specific warehouse."""
    return f"{WAREHOUSE_STATUS_TOPIC_PREFIX}/{warehouse_id}/status"




================================================
File: src/main.py
================================================
#!/usr/bin/env python3
# src/main.py

"""
Main entry point for the SUPCON Factory Simulation.

This script initializes and runs the complete simulation environment:
- Factory with stations and AGVs
- MQTT connectivity for agent communication
- Command handling for external control
"""

import logging
import signal
import sys
import time
import argparse
from typing import Optional

from src.simulation.factory import Factory
from src.utils.config_loader import load_factory_config
from src.utils.mqtt_client import MQTTClient
from src.agent_interface.command_handler import CommandHandler
from src.user_input import menu_input_thread
from config.settings import MQTT_BROKER_HOST, MQTT_BROKER_PORT, LOG_LEVEL
from src.game_logic.fault_system import FaultType

# Configure logging
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class FactorySimulation:
    """
    Main orchestrator class that combines all components of the factory simulation.
    """
    
    def __init__(self):
        self.factory: Optional[Factory] = None
        self.mqtt_client: Optional[MQTTClient] = None
        self.command_handler: Optional[CommandHandler] = None
        self.running = False

    def initialize(self, no_faults: bool = False):
        """Initialize all simulation components."""
        logger.info("🏭 Initializing Factory Simulation...")
        
        # Create MQTT client first
        self.mqtt_client = MQTTClient(MQTT_BROKER_HOST, MQTT_BROKER_PORT, "factory_simulation")
        
        # Connect to MQTT
        self.mqtt_client.connect()
        logger.info(f"📡 Connecting to MQTT broker at {MQTT_BROKER_HOST}:{MQTT_BROKER_PORT}")

        # Wait for MQTT client to be fully connected
        max_retries = 20
        retry_interval = 0.5
        for i in range(max_retries):
            if self.mqtt_client.is_connected():
                logger.info("✅ MQTT client is fully connected.")
                break
            logger.info(f"Waiting for MQTT connection... ({i+1}/{max_retries})")
            time.sleep(retry_interval)
        else:
            logger.error("❌ Failed to connect to MQTT broker within the given time. Exiting simulation.")
            raise ConnectionError("MQTT connection failed.")

        # Create the factory with MQTT client
        self.factory = Factory(load_factory_config(), self.mqtt_client, no_faults=no_faults)
        logger.info(f"✅ Factory created with {len(self.factory.stations)} stations and {len(self.factory.agvs)} AGVs")
        logger.info("📋 Order generation, fault system, and KPI calculation initialized")
        
        # Create command handler (this will start listening for commands)
        self.command_handler = CommandHandler(self.factory, self.mqtt_client)
        logger.info("🎯 Command handler initialized and listening for agent commands")
        
    def _calculate_station_utilization(self, station) -> float:
        """Calculate actual utilization of a station based on processing time and idle time."""
        if not hasattr(station, 'total_processing_time') or not hasattr(station, 'total_idle_time'):
            # If tracking isn't implemented yet, estimate based on status
            if station.status.value == 'processing':
                return 0.85  # High utilization when processing
            elif station.status.value == 'idle':
                return 0.15  # Low utilization when idle
            elif station.status.value == 'error':
                return 0.0   # No utilization during errors
            else:
                return 0.5   # Medium utilization for other states
        
        total_time = station.total_processing_time + station.total_idle_time
        if total_time == 0:
            return 0.0
        
        return min(1.0, station.total_processing_time / total_time)

    def run(self, duration: Optional[int] = None):
        """Run the simulation."""
        if self.factory is None:
            logger.error("❌ Factory is not initialized. Call initialize() first.")
            return

        logger.info("🚀 Starting Factory Simulation...")
        self.running = True
        
        try:
            if duration:
                logger.info(f"⏱️  Running simulation for {duration} seconds")
                self.factory.run(until=duration)
                # For fixed duration, print scores after normal completion
                self.factory.print_final_scores()
            else:
                logger.info("🔄 Running simulation indefinitely (Ctrl+C to stop)")
                while self.running:
                    # Run simulation for 1 second at a time
                    self.factory.run(until=int(self.factory.env.now) + 1)
                    time.sleep(1)  # Small delay to prevent busy waiting
                    
        except KeyboardInterrupt:
            logger.info("🛑 Simulation interrupted by user")
            # Scores will be printed in shutdown()
        except Exception as e:
            logger.error(f"❌ Simulation error: {e}")
        finally:
            # For indefinite runs or errors, print scores during shutdown
            if not duration:
                self.shutdown()
            else:
                # For fixed duration runs, just clean up without printing scores again
                logger.info("🧹 Cleaning up resources...")
                self.running = False
                if self.mqtt_client:
                    self.mqtt_client.disconnect()
                logger.info("👋 Factory Simulation stopped")

    def shutdown(self):
        """Clean up resources."""
        logger.info("🧹 Shutting down Factory Simulation...")
        self.running = False
        
        # Print final scores when shutting down
        if self.factory:
            self.factory.print_final_scores()
        
        if self.mqtt_client:
            self.mqtt_client.disconnect()
            
        logger.info("👋 Factory Simulation stopped")

def signal_handler(signum, frame):
    """Handle shutdown signals gracefully."""
    logger.info(f"Received signal {signum}, initiating graceful shutdown...")
    sys.exit(0)


def main(argv=None):
    """Main function."""
    # Add argparse to handle command-line arguments
    parser = argparse.ArgumentParser(description="SUPCON Factory Simulation Launcher")
    parser.add_argument(
        "--no-faults",
        action="store_true", # This makes it a boolean flag
        help="Run the simulation without the fault system enabled."
    )
    parser.add_argument(
        "--menu",
        action="store_true",
        help="Enable the interactive menu for manual control."
    )
    args = parser.parse_args(argv)

    # Set up signal handlers for graceful shutdown
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Create and run simulation
    simulation = FactorySimulation()
    
    try:
        simulation.initialize(no_faults=args.no_faults) # Pass the argument to initialize
        # Start menu input thread if requested
        if args.menu:
            import threading
            threading.Thread(target=menu_input_thread, args=(simulation.mqtt_client, simulation.factory), daemon=True).start()
            logger.info("Interactive menu enabled. Type commands in the console.")

        simulation.run()  # Run indefinitely
    except Exception as e:
        logger.error(f"❌ Failed to start simulation: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main()) 


================================================
File: src/user_input.py
================================================
import json
from src.simulation.factory import Factory
from src.utils.mqtt_client import MQTTClient
from config.topics import AGENT_COMMANDS_TOPIC, RESULT_TOPIC
from src.game_logic.fault_system import FaultType

def get_device_map(factory: Factory) -> dict:
    """Creates a mapping from simple codes to full device IDs."""
    device_map = {
        "R": "RawMaterial", "W": "Warehouse",
        "A": "StationA", "B": "StationB", "C": "StationC", "Q": "QualityCheck",
        "C1": "Conveyor_AB", "C2": "Conveyor_BC", "C3": "Conveyor_CQ",
    }
    # Dynamically add AGVs to the map
    for agv in factory.agvs.values():
        agv_num = agv.id.split('_')[-1]
        device_map[agv_num] = agv.id
    return device_map

def menu_input_thread(mqtt_client: MQTTClient, factory: Factory):
    """Thread for handling user menu input for manual control."""
    device_map = get_device_map(factory)
    
    load_unload_devices = {k: v for k, v in device_map.items() if not k.isdigit()}
    fault_devices = device_map

    load_prompt = f"请输入装载设备编号 ({', '.join(load_unload_devices.keys())}): "
    unload_prompt = f"请输入卸载设备编号 ({', '.join(load_unload_devices.keys())}): "
    fault_prompt = f"请输入设备编号 ({', '.join(fault_devices.keys())}): "

    while True:
        print("\n请选择操作类型：")
        print("1. 移动AGV")
        print("2. 装载")
        print("3. 卸载")
        print("4. 充电")
        print("5. 注入故障")
        print("6. 查看结果 (result)")
        print("7. 退出")
        op = input("> ").strip().lower()

        if op == "1":
            agv_id_short = input("请输入AGV编号 (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
            target_point = "P" + input("请输入目标点 (e.g., 1): ").strip()
            cmd = {"action": "move", "target": agv_id, "params": {"target_point": target_point}}

        elif op in ["2", "3"]: # Load/Unload
            action = "load" if op == "2" else "unload"
            agv_id_short = input("请输入AGV编号 (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
            
            prompt = load_prompt if action == "load" else unload_prompt
            device_id_short = input(prompt).strip().upper()
            device_id = load_unload_devices.get(device_id_short)

            if not device_id:
                print("无效设备编号，请重试。")
                continue

            buffer_type = input("请输入buffer类型 (N.A./output_buffer/upper/lower): ").strip()
            params = {"device_id": device_id, "buffer_type": buffer_type}

            if action == "load":
                product_id = input("请输入产品编号（可选）: ").strip()
                if product_id:
                    params["product_id"] = product_id
            
            cmd = {"action": action, "target": agv_id, "params": params}

        elif op == "4":
            agv_id_short = input("请输入AGV编号 (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
            try:
                target_level = float(input("请输入目标电量 (e.g., 80): ").strip())
            except ValueError:
                print("目标电量需为数字！")
                continue
            cmd = {"action": "charge", "target": agv_id, "params": {"target_level": target_level}}

        elif op == "5":
            if factory.fault_system is None:
                print("故障系统未初始化，请先初始化故障系统。")
                continue
            
            # 1:StationB, 2:Conveyor_BC, 3:StationC
            fast_fault = input("请输入故障类型 (1:StationA for 50s, 2:Conveyor_AB for 50s, 3.StationB for 50s,4, Conveyor_BC for 50s, 5:StationC for 50s) else manual: ").strip()
            if fast_fault == "1":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationA"
                fault_duration = 50.0
            elif fast_fault == "2":
                fault_type = FaultType.CONVEYOR_FAULT
                device_id = "Conveyor_AB"
                fault_duration = 50.0
            elif fast_fault == "3":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationB"
                fault_duration = 50.0
            elif fast_fault == "4":
                fault_type = FaultType.STATION_FAULT
                device_id = "Conveyor_BC"
                fault_duration = 50.0
            elif fast_fault == "5":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationC"
                fault_duration = 50.0
            else:
                print("手动设置故障，请输入设备编号: ")
                fault_type_in = input("请输入故障类型 (1:AGV, 2:工站, 3:传送带): ").strip()
                fault_map = {"1": FaultType.AGV_FAULT, "2": FaultType.STATION_FAULT, "3": FaultType.CONVEYOR_FAULT}
                fault_type = fault_map.get(fault_type_in)
                device_id_short = input(fault_prompt).strip().upper()
                device_id = fault_devices.get(device_id_short)
                if not device_id:
                    print("无效设备编号，请重试。")
                    continue
                fault_duration = float(input("请输入故障持续时间 (秒): ").strip())
                try:
                    if not fault_type:
                        raise ValueError("无效的故障类型")
                except (ValueError, KeyError) as e:
                    print(f"输入无效: {e}！")
                    continue
                try:
                    if not fault_type:
                        raise ValueError("无效的故障类型")
                except (ValueError, KeyError) as e:
                    print(f"输入无效: {e}！")
                    continue
            
            factory.fault_system._inject_fault_now(device_id, fault_type, fault_duration)
            print(f"已注入故障: {device_id} {fault_type.name} {fault_duration}s")
            continue

        elif op == "6" or op == "result":
            # 获取并显示最终结果
            if factory.kpi_calculator:
                final_scores = factory.kpi_calculator.get_final_score()
                
                # 打印到终端（与factory.print_final_scores()相同格式）
                print(f"\n{'='*60}")
                print("🏆 最终竞赛得分")
                print(f"{'='*60}")
                print(f"生产效率得分 (40%): {final_scores['efficiency_score']:.2f}")
                print(f"  - 订单完成率: {final_scores['efficiency_components']['order_completion']:.1f}%")
                print(f"  - 生产周期效率: {final_scores['efficiency_components']['production_cycle']:.1f}%")
                print(f"  - 设备利用率: {final_scores['efficiency_components']['device_utilization']:.1f}%")
                print(f"\n质量与成本得分 (30%): {final_scores['quality_cost_score']:.2f}")
                print(f"  - 一次通过率: {final_scores['quality_cost_components']['first_pass_rate']:.1f}%")
                print(f"  - 成本效率: {final_scores['quality_cost_components']['cost_efficiency']:.1f}%")
                print(f"\nAGV效率得分 (30%): {final_scores['agv_score']:.2f}")
                print(f"  - 充电策略效率: {final_scores['agv_components']['charge_strategy']:.1f}%")
                print(f"  - 能效比: {final_scores['agv_components']['energy_efficiency']:.1f}%")
                print(f"  - AGV利用率: {final_scores['agv_components']['utilization']:.1f}%")
                print(f"\n总得分: {final_scores['total_score']:.2f}")
                print(f"{'='*60}\n")
                
                # 发布得分到MQTT（不包含原始指标）
                result_topic = RESULT_TOPIC
                

                scores_only = {
                    "total_score": round(final_scores['total_score'], 2),
                    "efficiency_score": round(final_scores['efficiency_score'], 2),
                    "efficiency_components": {k: round(v, 2) for k, v in final_scores['efficiency_components'].items()},
                    "quality_cost_score": round(final_scores['quality_cost_score'], 2),
                    "quality_cost_components": {k: round(v, 2) for k, v in final_scores['quality_cost_components'].items()},
                    "agv_score": round(final_scores['agv_score'], 2),
                    "agv_components": {k: round(v, 2) for k, v in final_scores['agv_components'].items()}
                }
                result_json = json.dumps(scores_only)
            
                mqtt_client.publish(result_topic, result_json)
                print(f"✅ 结果已发布到 {result_topic}")
            else:
                print("❌ KPI计算器未初始化")
            continue
            
        elif op == "7":
            print("退出菜单输入线程。")
            break
        else:
            print("无效选择，请重试。")
            continue
        
        mqtt_client.publish(AGENT_COMMANDS_TOPIC, json.dumps(cmd))
        print(f"已发送命令: {cmd}")


================================================
File: src/user_input_multi.py
================================================
import json
import threading
import time
from src.simulation.factory_multi import Factory
from src.utils.mqtt_client import MQTTClient
from config.topics import AGENT_COMMANDS_TOPIC, RESULT_TOPIC
from src.game_logic.fault_system import FaultType
from src.utils.topic_manager import TopicManager
from src.simulation.entities.product import Product

# 全局变量控制自动上料
auto_feed_threads = {}  # {line_id: {"thread": thread, "active": bool}}

def auto_feed_station_a(factory: Factory, line_id: str, interval: float = 2.0, product_types=None):
    """自动连续添加原材料到 StationA 的线程函数
    
    Args:
        factory: 工厂实例
        line_id: 生产线ID
        interval: 上料间隔时间（秒）
        product_types: 要生产的产品类型列表，如 ['P1'], ['P2', 'P3'] 或 None（全部类型）
    """
    global auto_feed_threads
    product_count = 0
    
    # 如果没有指定产品类型，则循环所有类型
    if product_types is None:
        product_types = ['P1', 'P2', 'P3']
    
    type_index = 0
    
    while auto_feed_threads.get(line_id, {}).get("active", False):
        product_count += 1
        
        # 循环选择产品类型
        product_type = product_types[type_index]
        type_index = (type_index + 1) % len(product_types)
        
        # 创建 Product 对象
        order_id = f"auto_order_{line_id}_{product_count}"
        product = Product(product_type, order_id)
        
        # 直接向 StationA 的 buffer 添加产品
        try:
            station_a = factory.lines[line_id].stations["StationA"]
            # 检查 buffer 是否已满
            if len(station_a.buffer.items) < station_a.buffer.capacity:
                station_a.buffer.put(product)
                product.update_location(station_a.id, factory.env.now)
                product.add_history(factory.env.now, f"Auto-fed to StationA in {line_id}")
                print(f"{factory.env.now:.2f} ✅ 添加产品 {product.id} (类型: {product_type}) 到 {line_id} StationA")
                # 发布状态更新
                station_a.publish_status(f"Auto-fed product {product.id} added to buffer")
            else:
                print(f" {factory.env.now:.2f}⏸️  {line_id} StationA 的 buffer 已满，等待下次尝试")
        except Exception as e:
            print(f"[自动上料] ❌ 错误: {e}")
        
        time.sleep(interval)
    
    print(f"[自动上料] {line_id} 的自动上料已停止")

def get_device_map(factory: Factory) -> dict:
    """Creates a mapping from simple codes to full device IDs."""
    device_map = {
        "R": "RawMaterial", "W": "Warehouse",
        "A": "StationA", "B": "StationB", "C": "StationC", "Q": "QualityCheck",
        "C1": "Conveyor_AB", "C2": "Conveyor_BC", "C3": "Conveyor_CQ",
        "1": "AGV_1", "2": "AGV_2"
    }
    return device_map

def menu_input_thread(mqtt_client: MQTTClient, factory: Factory, topic_manager: TopicManager):
    """Thread for handling user menu input for manual control."""
    device_map = get_device_map(factory)
    
    load_unload_devices = {k: v for k, v in device_map.items() if not k.isdigit()}
    fault_devices = device_map

    load_prompt = f"请输入装载设备编号 ({', '.join(load_unload_devices.keys())}): "
    unload_prompt = f"请输入卸载设备编号 ({', '.join(load_unload_devices.keys())}): "
    fault_prompt = f"请输入设备编号 ({', '.join(fault_devices.keys())}): "

    while True:
        print("\n请选择操作类型：")
        print("1. 移动AGV")
        print("2. 装载")
        print("3. 卸载")
        print("4. 充电")
        print("5. 注入故障")
        print("6. 查看结果 (result)")
        print("7. 自动上料控制")
        print("8. 退出")
        op = input("> ").strip().lower()

        if op == "1":
            line_id = f"line{input('请输入生产线编号 (e.g., 1, 2, 3): ').strip()}"
            agv_id_short = input("请输入AGV编号 (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
            target_point = "P" + input("请输入目标点 (e.g., 1): ").strip()
            cmd = {"action": "move", "target": agv_id, "params": {"target_point": target_point}}

        elif op in ["2", "3"]: # Load/Unload
            action = "load" if op == "2" else "unload"
            line_id = f"line{input('请输入生产线编号 (e.g., 1, 2, 3): ').strip()}"
            agv_id_short = input("请输入AGV编号 (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
           
            params = {}
            if action == "load":
                product_id = input("请输入产品编号（可选）: ").strip()
                if product_id:
                    params["product_id"] = product_id
            
            cmd = {"action": action, "target": agv_id, "params": params}

        elif op == "4":
            line_id = f"line{input('请输入生产线编号 (e.g., 1, 2, 3): ').strip()}"
            agv_id_short = input("请输入AGV编号 (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
            try:
                target_level = float(input("请输入目标电量 (e.g., 80): ").strip())
            except ValueError:
                print("目标电量需为数字！")
                continue
            cmd = {"action": "charge", "target": agv_id, "params": {"target_level": target_level}}

        elif op == "5":
            line_id = f"line{input('请输入生产线编号 (e.g., 1, 2, 3): ').strip()}"
            
            if line_id not in factory.lines:
                print(f"生产线 {line_id} 不存在！")
                continue
            
            if not hasattr(factory.lines[line_id], 'fault_system') or factory.lines[line_id].fault_system is None:
                print("故障系统未初始化，请先初始化故障系统。")
                continue
            
            # 1:StationB, 2:Conveyor_BC, 3:StationC
            fast_fault = input("请输入故障类型 (1:StationA for 50s, 2:Conveyor_AB for 50s, 3.StationB for 50s,4, Conveyor_BC for 50s, 5:StationC for 50s) else manual: ").strip()
            if fast_fault == "1":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationA"
                fault_duration = 50.0
            elif fast_fault == "2":
                fault_type = FaultType.CONVEYOR_FAULT
                device_id = "Conveyor_AB"
                fault_duration = 50.0
            elif fast_fault == "3":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationB"
                fault_duration = 50.0
            elif fast_fault == "4":
                fault_type = FaultType.STATION_FAULT
                device_id = "Conveyor_BC"
                fault_duration = 50.0
            elif fast_fault == "5":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationC"
                fault_duration = 50.0
            else:
                print("手动设置故障，请输入设备编号: ")
                fault_type_in = input("请输入故障类型 (1:AGV, 2:工站, 3:传送带): ").strip()
                fault_map = {"1": FaultType.AGV_FAULT, "2": FaultType.STATION_FAULT, "3": FaultType.CONVEYOR_FAULT}
                fault_type = fault_map.get(fault_type_in)
                device_id_short = input(fault_prompt).strip().upper()
                device_id = fault_devices.get(device_id_short)
                if not device_id:
                    print("无效设备编号，请重试。")
                    continue
                fault_duration = float(input("请输入故障持续时间 (秒): ").strip())
                try:
                    if not fault_type:
                        raise ValueError("无效的故障类型")
                except (ValueError, KeyError) as e:
                    print(f"输入无效: {e}！")
                    continue
                try:
                    if not fault_type:
                        raise ValueError("无效的故障类型")
                except (ValueError, KeyError) as e:
                    print(f"输入无效: {e}！")
                    continue
            
            factory.lines[line_id].fault_system._inject_fault_now(device_id, fault_type, fault_duration)
            print(f"已注入故障: {device_id} {fault_type.name} {fault_duration}s")
            continue

        elif op == "6" or op == "result":
            # 通过MQTT发送get_result命令
            line_id = "line1"
            cmd = {
                "command_id": f"get_result_{int(time.time()*1000)}",
                "action": "get_result", 
                "target": "baisuishan",  # target is required by AgentCommand schema
                "params": {}
            }
            
        elif op == "7":
            global auto_feed_threads
            print("\n自动上料控制:")
            print("1. 启动自动上料")
            print("2. 停止自动上料")
            print("3. 查看自动上料状态")
            sub_op = input("> ").strip()
            
            if sub_op == "1":
                line_id = f"line{input('请输入生产线编号 (e.g., 1, 2, 3): ').strip()}"
                if line_id in auto_feed_threads and auto_feed_threads[line_id]["active"]:
                    print(f"{line_id} 的自动上料已在运行中")
                else:
                    # 选择产品类型
                    print("\n选择要生产的产品类型:")
                    print("1. 只生产 P1")
                    print("2. 只生产 P2")
                    print("3. 只生产 P3")
                    print("4. 轮流生产 P1 和 P2")
                    print("5. 轮流生产 P1 和 P3")
                    print("6. 轮流生产 P2 和 P3")
                    print("7. 轮流生产所有类型 (P1, P2, P3)")
                    
                    type_choice = input("> ").strip()
                    product_types_map = {
                        "1": ["P1"],
                        "2": ["P2"],
                        "3": ["P3"],
                        "4": ["P1", "P2"],
                        "5": ["P1", "P3"],
                        "6": ["P2", "P3"],
                        "7": ["P1", "P2", "P3"]
                    }
                    
                    product_types = product_types_map.get(type_choice, ["P1", "P2", "P3"])
                    
                    try:
                        interval = float(input("请输入上料间隔时间（秒，默认2.0）: ").strip() or "2.0")
                    except ValueError:
                        interval = 2.0
                    
                    # 设置状态为激活，包含产品类型信息
                    auto_feed_threads[line_id] = {
                        "active": True,
                        "product_types": product_types,
                        "interval": interval
                    }
                    # 创建并启动线程
                    thread = threading.Thread(
                        target=auto_feed_station_a,
                        args=(factory, line_id, interval, product_types),
                        daemon=True
                    )
                    auto_feed_threads[line_id]["thread"] = thread
                    thread.start()
                    print(f"✅ 已启动 {line_id} 的自动上料")
                    print(f"   产品类型: {', '.join(product_types)}")
                    print(f"   间隔时间: {interval} 秒")
            
            elif sub_op == "2":
                line_id = f"line{input('请输入生产线编号 (e.g., 1, 2, 3): ').strip()}"
                if line_id in auto_feed_threads and auto_feed_threads[line_id]["active"]:
                    auto_feed_threads[line_id]["active"] = False
                    print(f"✅ 正在停止 {line_id} 的自动上料...")
                else:
                    print(f"{line_id} 的自动上料未在运行")
            
            elif sub_op == "3":
                print("\n自动上料状态:")
                if not auto_feed_threads:
                    print("没有自动上料在运行")
                else:
                    for line_id, info in auto_feed_threads.items():
                        status = "运行中" if info["active"] else "已停止"
                        product_types = info.get("product_types", ["未知"])
                        interval = info.get("interval", "未知")
                        print(f"  {line_id}: {status}")
                        if info["active"]:
                            print(f"    - 产品类型: {', '.join(product_types)}")
                            print(f"    - 间隔时间: {interval} 秒")
            continue
            
        elif op == "8":
            print("退出菜单输入线程。")
            break
        else:
            print("无效选择，请重试。")
            continue
        
        # Only publish command if cmd was defined and line_id exists
        if 'cmd' in locals() and 'line_id' in locals():
            mqtt_client.publish(topic_manager.get_agent_command_topic(line_id), json.dumps(cmd))
            print(f"已发送命令: {cmd}")



================================================
File: src/agent_interface/command_handler.py
================================================
# src/agent_interface/command_handler.py
import json
import logging
from typing import Dict, Any, Optional

from config.schemas import AgentCommand, SystemResponse
from config.topics import AGENT_COMMANDS_TOPIC, AGENT_RESPONSES_TOPIC
from src.utils.mqtt_client import MQTTClient

logger = logging.getLogger(__name__)

class CommandHandler:
    """
    Handles MQTT commands received from agents and translates them 
    into method calls on the factory simulation.
    
    This is the bridge between the external MQTT interface and the internal simulation.
    """
    
    def __init__(self, factory, mqtt_client: MQTTClient):
        """
        Args:
            factory: The Factory instance to send commands to.
            mqtt_client: The MQTT client to subscribe to agent commands.
        """
        self.factory = factory
        self.mqtt_client = mqtt_client
        
        # Subscribe to agent commands
        self.mqtt_client.subscribe(AGENT_COMMANDS_TOPIC, self._handle_command_message)
        logger.info(f"CommandHandler initialized and subscribed to {AGENT_COMMANDS_TOPIC}")

    def _handle_command_message(self, topic: str, payload: bytes):
        """
        Callback for incoming MQTT command messages.
        Parses the JSON and validates it against the AgentCommand schema.
        """
        try:
            # Parse JSON payload
            command_data = json.loads(payload.decode('utf-8'))
            
            try:
                # Validate using Pydantic schema
                command = AgentCommand.model_validate(command_data)
            except Exception as e:
                msg = f"Failed to validate command: {e}"    
                logger.error(msg)
                response_payload = SystemResponse(timestamp=self.factory.env.now, response=msg, command_id=command_data.get("command_id")).model_dump_json()
                self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, response_payload)
                return
            
            logger.debug(f"Received valid command: {command.action} for {command.target}")
            
            # Route the command to the appropriate handler
            self._execute_command(command)
            
        except Exception as e:
            msg = f"Failed to process command: {e}"
            logger.error(msg)
            response_payload = SystemResponse(timestamp=self.factory.env.now, command_id=command_data.get("command_id"), response=msg).model_dump_json()
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, response_payload)

    def _execute_command(self, command: AgentCommand):
        """
        Executes a validated command by calling the appropriate factory method.
        """
        action = command.action
        params = command.params
        target = command.target
        command_id = command.command_id
        try:
            if action == "test":
                self._handle_test_command(target, params, command_id)
            elif action == "move":
                self._handle_move_agv(target, params, command_id)
            elif action == "load":
                self._handle_load_agv(target, params, command_id)
            elif action == "unload":
                self._handle_unload_agv(target, params, command_id)
            elif action == "charge":
                self._handle_charge_agv(target, params, command_id)
            elif action == "agv_action_sequence":
                self._handle_agv_action_sequence(target, params)
            elif action == "request_maintenance":
                self._handle_request_maintenance(target, params)
            elif action == "inspect_device":
                self._handle_inspect_device(target, params)
            elif action == "skip_repair_time":
                self._handle_skip_repair_time(target, params)
            elif action == "get_available_devices":
                self._handle_get_available_devices(target, params)
            elif action == "emergency_stop":
                self._handle_emergency_stop(target, params)
            elif action == "adjust_priority":
                self._handle_adjust_priority(target, params)
            elif action == "reroute_order":
                self._handle_reroute_order(target, params)
            else:
                logger.warning(f"Unknown action: {action}")
                
        except Exception as e:
            logger.error(f"Failed to execute command {action}: {e}")

    def _handle_test_command(self, target: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle test MQTT commands."""
        msg = f"Received MQTT test command to {target} with params: {json.dumps(params)}"
        logger.debug(msg)
        payload = SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=msg).model_dump_json()
        self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, payload)
        return True

    def _handle_move_agv(self, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle AGV movement commands.
        params: {target_point: str}
        """
        target_point = params.get("target_point")
        if not target_point:
            msg = "move_agv command missing 'target_point' parameter"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=msg).model_dump_json())
            return
            
        if agv_id not in self.factory.agvs:
            msg = f"AGV {agv_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=msg).model_dump_json())
            return
            
        agv = self.factory.agvs[agv_id]
        
        logger.info(f"Moving {agv_id} from {agv.current_point} to {target_point}")

        def move_process():
            success, message = yield from agv.move_to(target_point)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=message).model_dump_json())
            return success, message
        
        self.factory.env.process(move_process())

    def _handle_load_agv(self, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle AGV load commands.
        params: {device_id: str, buffer_type: str}
        """
        device_id = params.get("device_id")
        buffer_type = params.get("buffer_type")
        product_id = params.get("product_id", None)

        if not device_id:
            msg = "load_agv command missing 'device_id' parameter"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=msg).model_dump_json())
            return
        if agv_id not in self.factory.agvs:
            msg = f"AGV {agv_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=f"AGV {agv_id} not found in factory").model_dump_json())
            return
        agv = self.factory.agvs[agv_id]
        device = self.factory.all_devices.get(device_id)
        if not device:
            msg = f"Device {device_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=f"Device {device_id} not found in factory").model_dump_json())
            return
        logger.info(f"AGV {agv_id} loading from {device_id} with buffer_type {buffer_type}")
        
        def load_process():
            success, message, _ = yield from agv.load_from(device, buffer_type, product_id)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=message).model_dump_json())
            return success, message
        
        self.factory.env.process(load_process())

    def _handle_unload_agv(self, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle AGV unload commands.
        params: {device_id: str, buffer_type: str}
        """
        device_id = params.get("device_id")
        buffer_type = params.get("buffer_type")
        if not device_id:
            msg = "unload_agv command missing 'device_id' parameter"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=msg).model_dump_json())
            return
        if agv_id not in self.factory.agvs:
            msg = f"AGV {agv_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=msg).model_dump_json())
            return
        agv = self.factory.agvs[agv_id]
        device = self.factory.all_devices.get(device_id)
        if not device:
            msg = f"Device {device_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=msg).model_dump_json())
            return
        logger.info(f"AGV {agv_id} unloading {device_id} with buffer_type {buffer_type}")
        
        def unload_process():
            success, message, _ = yield from agv.unload_to(device, buffer_type)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=message).model_dump_json())
            return success, message
        
        self.factory.env.process(unload_process())

    def _handle_charge_agv(self, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle AGV charge commands.
        params: {target_level: float, action_time_factor: float}
        """
        target_level = params.get("target_level")
        if not target_level:
            msg = "charge_agv command missing 'target_level' parameter"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=msg).model_dump_json())
            return
        if agv_id not in self.factory.agvs:
            msg = f"AGV {agv_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=msg).model_dump_json())
            return
        agv = self.factory.agvs[agv_id]
        
        def charge_process():
            success, message = yield from agv.voluntary_charge(target_level)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=message).model_dump_json())
            return success, message
        
        self.factory.env.process(charge_process())

    def _handle_agv_action_sequence(self, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """支持agent一次下发一串AGV动作，仿真端按序执行并反馈。params: {actions: [{type, args}]}
        type: move/load/unload; args: dict
        """
        if agv_id not in self.factory.agvs:
            logger.error(f"AGV {agv_id} not found in factory")
            return
        agv = self.factory.agvs[agv_id]
        actions = params.get("actions", [])
        env = self.factory.env
        devices = {**self.factory.stations, **self.factory.agvs}
        # 加入conveyor/qualitychecker
        if hasattr(self.factory, 'conveyor_ab'):
            devices['conveyor_ab'] = self.factory.conveyor_ab
        if hasattr(self.factory, 'conveyor_bc'):
            devices['conveyor_bc'] = self.factory.conveyor_bc
        if hasattr(self.factory, 'conveyor_cq'):
            devices['conveyor_cq'] = self.factory.conveyor_cq
        if hasattr(self.factory, 'stations') and 'QualityCheck' in self.factory.stations:
            devices['QualityCheck'] = self.factory.stations['QualityCheck']
        def agv_action_sequence_proc():
            for idx, act in enumerate(actions):
                act_type = act.get('type')
                args = act.get('args', {})
                feedback = ""
                success = False
                # move: args: {target_point: str}
                if act_type == 'move':
                    # 支持两种格式：坐标位置或路径点名称
                    if 'target_point' in args:
                        # 使用路径点名称（推荐方式）
                        target_point = args['target_point']
                        success, feedback = yield from agv.move_to(target_point)
                    else:
                        feedback = f"move命令缺少target_point参数"
                        success = False
                # load: args: {device_id, buffer_type}
                elif act_type == 'load':
                    device_id = args.get('device_id')
                    buffer_type = args.get('buffer_type')
                    device = devices.get(device_id)
                    if device is None:
                        feedback = f"未找到设备{device_id}"
                    else:
                        s, f, _ = yield from agv.load_from(device, buffer_type)
                        feedback = f
                        success = s
                # unload: args: {device_id, buffer_type}
                elif act_type == 'unload':
                    device_id = args.get('device_id')
                    buffer_type = args.get('buffer_type')
                    device = devices.get(device_id)
                    if device is None:
                        feedback = f"未找到设备{device_id}"
                    else:
                        s, f, _ = yield from agv.unload_to(device, buffer_type)
                        feedback = f
                        success = s
                else:
                    feedback = f"未知动作类型: {act_type}"
                # 反馈
                resp = SystemResponse(timestamp=env.now, command_id=command_id, response=f"[{idx+1}/{len(actions)}] {act_type}: {feedback}").model_dump_json()
                self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, resp)
                # 若失败则中断后续
                if not success:
                    break
        # 启动仿真进程
        env.process(agv_action_sequence_proc())

    def _handle_request_maintenance(self, device_id: str, params: Dict[str, Any]):
        """Handle maintenance request commands."""
        maintenance_type = params.get("maintenance_type")
        if not maintenance_type:
            logger.error("request_maintenance command missing 'maintenance_type' parameter")
            return
            
        logger.info(f"Requesting {maintenance_type} maintenance for {device_id}")
        
        # Use the factory's maintenance handling system
        diagnosis_result = self.factory.handle_maintenance_request(device_id, maintenance_type)
        
        if diagnosis_result.is_correct:
            logger.info(f"✅ Correct diagnosis for {device_id}, repair time: {diagnosis_result.repair_time:.1f}s")
        else:
            logger.warning(f"❌ Incorrect diagnosis for {device_id}, penalty time: {diagnosis_result.repair_time:.1f}s")
            if diagnosis_result.affected_devices:
                logger.warning(f"   Affected devices: {', '.join(diagnosis_result.affected_devices)}")
        
        return diagnosis_result

    def _handle_inspect_device(self, device_id: str, params: Dict[str, Any]):
        """Handle device inspection commands."""
        logger.info(f"Inspecting device {device_id}")
        
        if not hasattr(self.factory, 'fault_system'):
            logger.error("Factory does not have fault system available")
            return None
            
        # Use the fault system's inspect function
        detailed_status = self.factory.fault_system.inspect_device(device_id)
        
        if detailed_status:
            logger.info(f"✅ Device {device_id} inspection completed")
            # 发布检查结果供agent使用
            self._publish_inspection_result(device_id, detailed_status)
        else:
            logger.warning(f"❌ Device {device_id} inspection failed")
        
        return detailed_status

    def _handle_skip_repair_time(self, device_id: str, params: Dict[str, Any]):
        """Handle skip repair time commands."""
        logger.info(f"Attempting to skip repair time for {device_id}")
        
        if not hasattr(self.factory, 'fault_system'):
            logger.error("Factory does not have fault system available")
            return False
            
        # Use the fault system's skip function
        success = self.factory.fault_system.skip_repair_time(device_id)
        
        if success:
            logger.info(f"✅ Successfully skipped repair time for {device_id}")
        else:
            logger.warning(f"❌ Failed to skip repair time for {device_id}")
        
        return success

    def _handle_get_available_devices(self, target: str, params: Dict[str, Any]):
        """Handle get available devices commands."""
        logger.info("Retrieving available devices list")
        
        if not hasattr(self.factory, 'fault_system'):
            logger.error("Factory does not have fault system available")
            return []
            
        # Get available devices from fault system
        available_devices = self.factory.fault_system.get_available_devices()
        
        logger.info(f"✅ Available devices: {', '.join(available_devices)}")
        
        # Publish available devices via MQTT
        self._publish_available_devices(available_devices)
        
        return available_devices
        
    def _handle_emergency_stop(self, device_id: str, params: Dict[str, Any]):
        """Handle emergency stop commands."""
        logger.info(f"Emergency stop requested for {device_id}")
        
        success = False
        
        # Handle station emergency stop
        if device_id in self.factory.stations:
            station = self.factory.stations[device_id]
            if hasattr(station, 'emergency_stop'):
                station.emergency_stop()
                success = True
            else:
                # Fallback: force station to idle state
                from src.simulation.entities.base import DeviceStatus
                station.status = DeviceStatus.MAINTENANCE
                logger.info(f"✅ Station {device_id} emergency stopped (forced to maintenance mode)")
                success = True
        
        # Handle AGV emergency stop
        elif device_id in self.factory.agvs:
            agv = self.factory.agvs[device_id]
            if hasattr(agv, 'emergency_stop'):
                agv.emergency_stop()
                success = True
            else:
                # Fallback: force AGV to stop
                agv.is_moving = False
                logger.info(f"✅ AGV {device_id} emergency stopped")
                success = True
        
        # Handle factory-wide emergency stop
        elif device_id == "factory":
            logger.info("🚨 Factory-wide emergency stop initiated")
            # Stop all stations
            for station_id, station in self.factory.stations.items():
                if hasattr(station, 'emergency_stop'):
                    station.emergency_stop()
                else:
                    from src.simulation.entities.base import DeviceStatus
                    station.status = DeviceStatus.MAINTENANCE
            
            # Stop all AGVs
            for agv_id, agv in self.factory.agvs.items():
                if hasattr(agv, 'emergency_stop'):
                    agv.emergency_stop()
                else:
                    agv.is_moving = False
            
            success = True
        
        else:
            logger.error(f"❌ Unknown device for emergency stop: {device_id}")
            
        if success:
            logger.info(f"✅ Emergency stop completed for {device_id}")
        else:
            logger.error(f"❌ Emergency stop failed for {device_id}")
        
        return success
        
    def _handle_adjust_priority(self, order_id: str, params: Dict[str, Any]):
        """Handle order priority adjustment commands."""
        new_priority = params.get("priority")
        if not new_priority:
            logger.error("adjust_priority command missing 'priority' parameter")
            return False
            
        logger.info(f"Adjusting priority of order {order_id} to {new_priority}")
        
        # Validate priority value
        valid_priorities = ["low", "medium", "high"]
        if new_priority not in valid_priorities:
            logger.error(f"Invalid priority '{new_priority}'. Valid priorities: {valid_priorities}")
            return False
        
        success = False
        
        # Try to find and update the order in the order generator
        if hasattr(self.factory, 'order_generator'):
            order_generator = self.factory.order_generator
            
            # Look for the order in active orders
            if hasattr(order_generator, 'active_orders'):
                for order in order_generator.active_orders:
                    if order.order_id == order_id:
                        old_priority = order.priority
                        order.priority = new_priority
                        
                        # Recalculate deadline based on new priority
                        if hasattr(order_generator, '_calculate_deadline'):
                            order.deadline = order_generator._calculate_deadline(new_priority, order.quantity)
                        
                        logger.info(f"✅ Order {order_id} priority changed from {old_priority} to {new_priority}")
                        success = True
                        break
            
            # If not found in active orders, check pending orders
            if not success and hasattr(order_generator, 'pending_orders'):
                for order in order_generator.pending_orders:
                    if order.order_id == order_id:
                        old_priority = order.priority
                        order.priority = new_priority
                        
                        # Recalculate deadline
                        if hasattr(order_generator, '_calculate_deadline'):
                            order.deadline = order_generator._calculate_deadline(new_priority, order.quantity)
                        
                        logger.info(f"✅ Order {order_id} priority changed from {old_priority} to {new_priority}")
                        success = True
                        break
        
        # Also try to update in KPI calculator if it tracks orders
        if hasattr(self.factory, 'kpi_calculator'):
            kpi_calculator = self.factory.kpi_calculator
            if hasattr(kpi_calculator, 'update_order_priority'):
                kpi_calculator.update_order_priority(order_id, new_priority)
        
        if not success:
            logger.error(f"❌ Order {order_id} not found or could not be updated")
        
        return success
        
    def _handle_reroute_order(self, order_id: str, params: Dict[str, Any]):
        """Handle order rerouting commands."""
        target_station_id = params.get("target_station_id")
        if not target_station_id:
            logger.error("reroute_order command missing 'target_station_id' parameter")
            return False
            
        logger.info(f"Rerouting order {order_id} to {target_station_id}")
        
        # Validate target station exists
        if target_station_id not in self.factory.stations:
            logger.error(f"Target station '{target_station_id}' does not exist")
            return False
        
        success = False
        
        # Try to find the order and reroute it
        if hasattr(self.factory, 'order_generator'):
            order_generator = self.factory.order_generator
            
            # Look for the order in active orders
            if hasattr(order_generator, 'active_orders'):
                for order in order_generator.active_orders:
                    if order.order_id == order_id:
                        # Check if the order has a route or current station
                        if hasattr(order, 'current_station'):
                            old_station = order.current_station
                            order.current_station = target_station_id
                            logger.info(f"✅ Order {order_id} rerouted from {old_station} to {target_station_id}")
                            success = True
                        elif hasattr(order, 'route'):
                            # Modify the route to include the target station
                            if isinstance(order.route, list):
                                # Insert target station at the beginning of remaining route
                                order.route.insert(0, target_station_id)
                            else:
                                # Simple case: set route to target station
                                order.route = [target_station_id]
                            logger.info(f"✅ Order {order_id} route updated to include {target_station_id}")
                            success = True
                        else:
                            # Create a new route attribute if it doesn't exist
                            order.next_station = target_station_id
                            logger.info(f"✅ Order {order_id} next station set to {target_station_id}")
                            success = True
                        break
        
        # If the order is currently being processed at a station, we might need to stop it
        if success:
            target_station = self.factory.stations[target_station_id]
            
            # Notify the target station about incoming order (if supported)
            if hasattr(target_station, 'notify_incoming_order'):
                target_station.notify_incoming_order(order_id)
            
            # Update KPI calculator if it tracks order routing
            if hasattr(self.factory, 'kpi_calculator'):
                kpi_calculator = self.factory.kpi_calculator
                if hasattr(kpi_calculator, 'update_order_route'):
                    kpi_calculator.update_order_route(order_id, target_station_id)
        
        if not success:
            logger.error(f"❌ Order {order_id} not found or could not be rerouted")
        
        return success

    def _publish_inspection_result(self, device_id: str, detailed_status):
        """Publish device inspection result via MQTT."""
        topic = f"factory/inspection/{device_id}/result"
        message = {
            "device_id": device_id,
            "timestamp": self.factory.env.now,
            "status": detailed_status.dict()
        }
        
        try:
            self.mqtt_client.publish(topic, json.dumps(message))
            logger.debug(f"Published inspection result for {device_id}")
        except Exception as e:
            logger.error(f"Failed to publish inspection result: {e}")

    def _publish_available_devices(self, available_devices):
        """Publish available devices list via MQTT."""
        topic = "factory/devices/available"
        message = {
            "timestamp": self.factory.env.now,
            "available_devices": available_devices
        }
        
        try:
            self.mqtt_client.publish(topic, json.dumps(message))
            logger.debug("Published available devices list")
        except Exception as e:
            logger.error(f"Failed to publish available devices: {e}")


================================================
File: src/agent_interface/multi_line_command_handler.py
================================================
# src/agent_interface/multi_line_command_handler.py
import json
import logging
from typing import Dict, Any, Optional

from config.schemas import AgentCommand, SystemResponse
from src.utils.mqtt_client import MQTTClient
from src.utils.topic_manager import TopicManager

logger = logging.getLogger(__name__)

class MultiLineCommandHandler:
    """
    Handles MQTT commands for a multi-line factory environment.
    It subscribes to a wildcard topic and parses the line_id from the topic.
    """
    
    def __init__(self, factory, mqtt_client: MQTTClient, topic_manager: TopicManager):
        """
        Args:
            factory: The multi-line Factory instance.
            mqtt_client: The MQTT client to subscribe to commands.
            topic_manager: The TopicManager to generate and parse topics.
        """
        self.factory = factory
        self.mqtt_client = mqtt_client
        self.topic_manager = topic_manager
        
        # Subscribe to a wildcard topic for all lines
        command_topic = self.topic_manager.get_agent_command_topic_wildcard()
        self.mqtt_client.subscribe(command_topic, self._handle_command_message)
        logger.info(f"MultiLineCommandHandler initialized and subscribed to {command_topic}")

    def _handle_command_message(self, topic: str, payload: bytes):
        """
        Callback for incoming MQTT command messages.
        Parses the topic to get line_id and device_id, then validates the payload.
        """
        try:
            # Parse the topic to extract line_id and device_id
            parsed_topic = self.topic_manager.parse_agent_command_topic(topic)
            if not parsed_topic:
                logger.error(f"Could not parse command topic: {topic}")
                return

            line_id = parsed_topic['line_id']
            # device_id is now expected in the command payload's target field
            
            # Parse JSON payload
            command_data = json.loads(payload.decode('utf-8'))
            
            try:
                # Validate using Pydantic schema
                command = AgentCommand.model_validate(command_data)
            except Exception as e:
                msg = f"Failed to validate command: {e}"    
                logger.error(msg)
                self._publish_response(line_id, command_data.get("command_id"), msg)
                return
            
            # No need to check command.target against topic-derived device_id anymore

            logger.debug(f"Received valid command for line '{line_id}': {command.action} for {command.target}")
            
            # Route the command to the appropriate handler
            self._execute_command(line_id, command)
            
        except Exception as e:
            msg = f"Failed to process command: {e}"
            logger.error(msg)
            # We might not have line_id if topic parsing fails, so publish to a general error topic
            self._publish_response(None, command_data.get("command_id"), msg)

    def _execute_command(self, line_id: str, command: AgentCommand):
        """
        Executes a validated command by calling the appropriate method on the correct line.
        """
        action = command.action
        params = command.params
        target_device_id = command.target
        command_id = command.command_id

        # Get the correct production line from the factory
        line = self.factory.lines.get(line_id)
        if not line:
            msg = f"Production line '{line_id}' not found."
            logger.error(msg)
            self._publish_response(line_id, command_id, msg)
            return

        try:
            if action == "move":
                self._handle_move_agv(line, target_device_id, params, command_id)
            elif action == "load":
                self._handle_load_agv(line, target_device_id, params, command_id)
            elif action == "unload":
                self._handle_unload_agv(line, target_device_id, params, command_id)
            elif action == "charge":
                self._handle_charge_agv(line, target_device_id, params, command_id)
            elif action == "get_result":
                self._handle_get_result(line_id, params, command_id)
            else:
                msg = f"Unknown action: {action}"
                logger.warning(msg)
                self._publish_response(line_id, command_id, msg)
                
        except Exception as e:
            msg = f"Failed to execute command {action}: {e}"
            logger.error(msg)
            self._publish_response(line_id, command_id, msg)

    def _handle_move_agv(self, line, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        target_point = params.get("target_point")
        if not target_point:
            self._publish_response(line.name, command_id, "'target_point' missing in move command.")
            return
            
        agv = line.agvs.get(agv_id)
        if not agv:
            self._publish_response(line.name, command_id, f"AGV '{agv_id}' not found in line '{line.name}'.")
            return
            
        def move_process():
            success, message = yield from agv.move_to(target_point)
            self._publish_response(line.name, command_id, message)
        
        self.factory.env.process(move_process())

    def _handle_load_agv(self, line, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        
        if agv_id not in line.agvs:
            msg = f"AGV {agv_id} not found in this line"
            logger.error(msg)
            self._publish_response(line.name, command_id, f"AGV {agv_id} not found in line {line.name}")
            return
        agv = line.agvs.get(agv_id)

        # Get device and buffer from AGV's position mapping
        point_ops = agv.get_point_operations(agv.current_point)
        if not point_ops or not point_ops.get('device'):
            msg = f"No device can be operated for {agv_id} at position {agv.current_point}"
            logger.error(msg)
            self._publish_response(line.name, command_id, msg)
            return
        
        device_id = point_ops['device']
        buffer_type = point_ops.get('buffer')  # May be None for some devices

        device = self._find_device(line, device_id)
        if not device:
            self._publish_response(line.name, command_id, f"Device '{device_id}' not found in line '{line.name}' or factory.")
            return

        def load_process():
            product_id = params.get("product_id", None) if device_id == "RawMaterial" else None
            success, message, _ = yield from agv.load_from(device, buffer_type, product_id)
            self._publish_response(line.name, command_id, message)
            return success, message
        
        self.factory.env.process(load_process())

    def _handle_unload_agv(self, line, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        
        if agv_id not in line.agvs:
            msg = f"AGV {agv_id} not found in this line"
            logger.error(msg)
            self._publish_response(line.name, command_id, f"AGV {agv_id} not found in line {line.name}")
            return
        agv = line.agvs.get(agv_id)

        # Get device and buffer from AGV's position mapping
        point_ops = agv.get_point_operations(agv.current_point)
        if not point_ops or not point_ops.get('device'):
            msg = f"No device mapping found for AGV {agv_id} at position {agv.current_point}"
            logger.error(msg)
            self._publish_response(line.name, command_id, msg)
            return
        
        device_id = point_ops['device']
        buffer_type = point_ops.get('buffer')  # May be None for some devices

        device = self._find_device(line, device_id)
        if not device:
            self._publish_response(line.name, command_id, f"Device {device_id} not found in line {line.name} or factory.")
            return

        def unload_process():
            success, message, _ = yield from agv.unload_to(device, buffer_type)
            self._publish_response(line.name, command_id, message)
        
        self.factory.env.process(unload_process())

    def _handle_charge_agv(self, line, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        agv = line.agvs.get(agv_id)
        if not agv:
            self._publish_response(line.name, command_id, f"AGV '{agv_id}' not found in line '{line.name}'.")
            return
        
        target_level = params.get("target_level")
        if not target_level:
            self._publish_response(line.name, command_id, "'target_level' missing in charge command, will charge to 80 by default")
            target_level = 80.0

        def charge_process():
            success, message = yield from agv.voluntary_charge(target_level)
            self._publish_response(line.name, command_id, message)
        
        self.factory.env.process(charge_process())

    def _find_device(self, line, device_id: str):
        """
        Find a device first in the line, then in factory global devices.
        Returns the device if found, None otherwise.
        """
        # First try to find in the current line
        device = line.all_devices.get(device_id)
        if device:
            return device
        
        # If not found in line, search in factory global devices (warehouse, raw_material)
        device = self.factory.all_devices.get(device_id)
        return device

    def _handle_get_result(self, line_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle get result command to retrieve and publish KPI scores."""
        if self.factory.kpi_calculator:
            final_scores = self.factory.kpi_calculator.get_final_score()
            
            # 打印到终端（与factory.print_final_scores()相同格式）
            print(f"\n{'='*60}")
            print("🏆 最终竞赛得分")
            print(f"{'='*60}")
            print(f"生产效率得分 (40%): {final_scores['efficiency_score']:.2f}")
            print(f"  - 订单完成率: {final_scores['efficiency_components']['order_completion']:.1f}%")
            print(f"  - 生产周期效率: {final_scores['efficiency_components']['production_cycle']:.1f}%")
            print(f"  - 设备利用率: {final_scores['efficiency_components']['device_utilization']:.1f}%")
            print(f"\n质量与成本得分 (30%): {final_scores['quality_cost_score']:.2f}")
            print(f"  - 一次通过率: {final_scores['quality_cost_components']['first_pass_rate']:.1f}%")
            print(f"  - 成本效率: {final_scores['quality_cost_components']['cost_efficiency']:.1f}%")
            print(f"\nAGV效率得分 (30%): {final_scores['agv_score']:.2f}")
            print(f"  - 充电策略效率: {final_scores['agv_components']['charge_strategy']:.1f}%")
            print(f"  - 能效比: {final_scores['agv_components']['energy_efficiency']:.1f}%")
            print(f"  - AGV利用率: {final_scores['agv_components']['utilization']:.1f}%")
            print(f"\n总得分: {final_scores['total_score']:.2f}")
            print(f"{'='*60}\n")
            
            # 发布得分到MQTT（不包含原始指标）
            result_topic = self.topic_manager.get_result_topic()
            
            scores_only = {
                "total_score": round(final_scores['total_score'], 2),
                "efficiency_score": round(final_scores['efficiency_score'], 2),
                "efficiency_components": {k: round(v, 2) for k, v in final_scores['efficiency_components'].items()},
                "quality_cost_score": round(final_scores['quality_cost_score'], 2),
                "quality_cost_components": {k: round(v, 2) for k, v in final_scores['quality_cost_components'].items()},
                "agv_score": round(final_scores['agv_score'], 2),
                "agv_components": {k: round(v, 2) for k, v in final_scores['agv_components'].items()}
            }
            result_json = json.dumps(scores_only)
            
            self.mqtt_client.publish(result_topic, result_json)
            print(f"✅ 结果已发布到 {result_topic}")
            
            # Also send a response to confirm the action was completed
            self._publish_response(line_id, command_id, f"Results published to {result_topic}")
        else:
            print("❌ KPI计算器未初始化")
            self._publish_response(line_id, command_id, "KPI calculator not initialized")

    def _publish_response(self, line_id: Optional[str], command_id: Optional[str], response_message: str):
        """Publishes a response to the appropriate MQTT topic."""
        response_topic = self.topic_manager.get_agent_response_topic(line_id)
        response_payload = SystemResponse(
            timestamp=self.factory.env.now,
            command_id=command_id,
            response=response_message
        ).model_dump_json()
        self.mqtt_client.publish(response_topic, response_payload)




================================================
File: src/game_logic/fault_system.py
================================================
# src/game_logic/fault_system.py
import random
import simpy
from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum
from src.utils.mqtt_client import MQTTClient
from config.schemas import DeviceStatus, FaultAlert
import json 
from src.utils.topic_manager import TopicManager

@dataclass
class FaultDefinition:
    """简化的故障定义"""
    symptom: str
    min_duration: float  # 最小故障持续时间（秒）
    max_duration: float  # 最大故障持续时间（秒）

class FaultType(Enum):
    STATION_FAULT = "station_fault"
    AGV_FAULT = "agv_fault"
    CONVEYOR_FAULT = "conveyor_fault"

class FaultSystem:
    """
    简化的故障系统：冻结设备，过一段时间解冻
    """
    
    def __init__(self, env: simpy.Environment, devices: Dict, mqtt_client: Optional[MQTTClient] = None, topic_manager: Optional[TopicManager] = None, line_id: Optional[str] = None, kpi_calculator=None, **kwargs):
        self.env = env
        self.factory_devices = devices
        self.mqtt_client = mqtt_client
        self.topic_manager = topic_manager
        self.line_id = line_id
        self.kpi_calculator = kpi_calculator
        self.active_faults: Dict[str, 'SimpleFault'] = {}
        self.fault_processes: Dict[str, simpy.Process] = {}
        self.pending_agv_faults: Dict[str, FaultType] = {} # 新增：用于挂起对繁忙AGV的故障
        
        self.fault_definitions = {
            FaultType.STATION_FAULT: FaultDefinition(
                symptom="Station Vibration",
                min_duration=20.0,
                max_duration=60.0
            ),
            FaultType.AGV_FAULT: FaultDefinition(
                symptom="AGV Stuck",
                min_duration=20.0,
                max_duration=60.0
            ),
            FaultType.CONVEYOR_FAULT: FaultDefinition(
                symptom="Conveyor Stuck",
                min_duration=20.0,
                max_duration=60.0
            )
        }
        
        # 故障注入参数
        self.fault_injection_interval = kwargs.get('fault_injection_interval', (120, 300))
        
        # 开始故障注入过程
        self.env.process(self.run_fault_injection())

    def run_fault_injection(self):
        """故障注入主循环"""
        while True:
            # 等待下次故障注入
            wait_time = random.uniform(*self.fault_injection_interval)
            yield self.env.timeout(wait_time)
            
            # 注入随机故障
            self.inject_random_fault()

    def inject_random_fault(self, target_device: Optional[str] = None, fault_type: Optional[FaultType] = None):
        """注入随机故障"""
        if fault_type is None:
            fault_type = random.choice(list(FaultType))
        
        if target_device is None:
            target_device = self._select_target_device(fault_type)
        
        # Check if the device has already been injected with a fault
        if target_device in self.active_faults:
            print(f"[{self.env.now:.2f}] ⚠️  设备 {target_device} 已有故障，跳过注入")
            return
        
        device = self.factory_devices[target_device]

        # For AGVs, if they are not idle, pend the fault instead of skipping
        if fault_type == FaultType.AGV_FAULT and device.status != DeviceStatus.IDLE:
            if target_device not in self.pending_agv_faults:
                self.pending_agv_faults[target_device] = fault_type
                print(f"[{self.env.now:.2f}] ⚠️  AGV {target_device} is currently {device.status.value}, fault injection is pending.")
            else:
                print(f"[{self.env.now:.2f}] ⚠️  AGV {target_device} already has a pending fault, skipping new injection.")
            return

        # Inject the fault now for non-AGVs or idle AGVs
        self._inject_fault_now(target_device, fault_type)

    def _select_target_device(self, fault_type: FaultType) -> str:
        """根据故障类型选择目标设备"""
        if fault_type == FaultType.AGV_FAULT:
            # AGV故障
            agv_devices = [dev_id for dev_id in self.factory_devices.keys() if "AGV" in dev_id]
            return random.choice(agv_devices) if agv_devices else "AGV_1"
        elif fault_type == FaultType.CONVEYOR_FAULT:
            # 传送带故障 except Conveyor_CQ
            conveyor_devices = [dev_id for dev_id in self.factory_devices.keys() if "Conveyor" in dev_id and "CQ" not in dev_id]
            return random.choice(conveyor_devices) if conveyor_devices else "Conveyor_AB"
        else:
            # 工站故障
            station_devices = [dev_id for dev_id in self.factory_devices.keys() 
                             if "Station" in dev_id or "Quality" in dev_id]
            return random.choice(station_devices) if station_devices else "StationA"

    def _inject_fault_now(self, device_id: str, fault_type: FaultType, duration: Optional[float] = None):
        """立即注入故障的核心逻辑"""
        if device_id in self.active_faults:
            # This check is important for when called externally
            print(f"[{self.env.now:.2f}] ⚠️  设备 {device_id} 已有故障，无法注入新故障")
            return

        if duration is None:
            fault = self._create_fault(device_id, fault_type)
        else: # For manual injection with specified duration
             fault = SimpleFault(
                device_id=device_id,
                fault_type=fault_type,
                symptom=self.fault_definitions[fault_type].symptom,
                duration=duration,
                start_time=self.env.now
            )

        self.active_faults[device_id] = fault
        
        device = self.factory_devices[device_id]
        
        # Special handling for conveyors - interrupt processing instead of main action
        if hasattr(device, 'interrupt_all_processing'):
            interrupted_count = device.interrupt_all_processing()
            print(f"[{self.env.now:.2f}] 🚫 {device_id}: Interrupted {interrupted_count} processing operations")
        # For other devices, interrupt the main action
        elif hasattr(device, 'action') and device.action and device.action.is_alive and device.action != self.env.active_process:
            device.action.interrupt("Fault injected")
        
        device.set_status(DeviceStatus.FAULT)
        device.publish_status(f"[{self.env.now:.2f}] {device_id}: Fault injected: {fault.symptom}")
        
        # If the device has a fault symptom attribute, set it
        if hasattr(device, 'fault_symptom'):
            device.fault_symptom = fault.symptom
        
        print(f"[{self.env.now:.2f}] 💥 故障注入: {device_id}")
        print(f"   - 症状: {fault.symptom}")
        print(f"   - 持续时间: {fault.duration:.1f}s")
        print(f"   - 🚫 设备已冻结")
        
        self._send_fault_alert(device_id, fault)
        
        # Report maintenance cost to KPI calculator (fault detection)
        if self.kpi_calculator:
            # Assume correct diagnosis for auto-generated faults
            self.kpi_calculator.add_maintenance_cost(device_id, fault.symptom, was_correct_diagnosis=True)
        
        # Start fault process
        fault_process = self.env.process(self._run_fault_process(fault))
        self.fault_processes[device_id] = fault_process

    def _create_fault(self, device_id: str, fault_type: FaultType) -> 'SimpleFault':
        """创建简单故障实例"""
        definition = self.fault_definitions[fault_type]
        duration = random.uniform(definition.min_duration, definition.max_duration)
        
        return SimpleFault(
            device_id=device_id,
            fault_type=fault_type,
            symptom=definition.symptom,
            duration=duration,
            start_time=self.env.now
        )

    def _run_fault_process(self, fault: 'SimpleFault'):
        """运行故障过程（等待故障持续时间）"""
        try:
            # Wait for the fault duration
            yield self.env.timeout(fault.duration)
            
            # Fault duration ended, automatically unfreeze the device
            self._clear_fault(fault.device_id)
            
        except simpy.Interrupt:
            # Fault process interrupted (e.g., manual repair)
            print(f"[{self.env.now:.2f}] 🔧 故障过程被中断: {fault.device_id}")

    def _clear_fault(self, device_id: str):
        """Clear the fault and unfreeze the device"""
        if device_id in self.active_faults:
            fault = self.active_faults[device_id]
            fault_symptom = fault.symptom
            # Calculate recovery time before deleting the fault
            recovery_time = self.env.now - fault.start_time
            
            del self.active_faults[device_id]
            
            # Clear the fault process
            if device_id in self.fault_processes:
                del self.fault_processes[device_id]
            
            # Unfreeze the device
            device = self.factory_devices[device_id]
            if hasattr(device, 'recover'):
                device.recover()
            else:
                # Fallback to default if no specific recover method
                device.set_status(DeviceStatus.IDLE)
            
            # Clear the fault symptom
            if hasattr(device, 'fault_symptom'):
                device.fault_symptom = None
            
            print(f"[{self.env.now:.2f}] ✅ 故障自动解除: {device_id}")
            print(f"   - 🔓 设备已解冻")
            
            # Report recovery time to KPI calculator
            if self.kpi_calculator and recovery_time > 0:
                self.kpi_calculator.add_fault_recovery_time(recovery_time)
                
                # Track AGV fault time specifically
                if fault.fault_type == FaultType.AGV_FAULT:
                    self.kpi_calculator.update_agv_fault_time(device_id, self.line_id, recovery_time)
            
            # Send recovery alert
            self._send_recovery_alert(device_id, fault_symptom)

    def _send_fault_alert(self, device_id: str, fault: 'SimpleFault'):
        """发送故障警报"""
        alert_data = FaultAlert(
            timestamp=self.env.now,
            device_id=device_id,
            alert_type="fault_injected",
            symptom=fault.symptom,
            fault_type=fault.fault_type.value,
            estimated_duration=fault.duration,
            message=f"Device {device_id} has fault: {fault.symptom}"
        )
        
        if self.mqtt_client and self.topic_manager and self.line_id:
            topic = self.topic_manager.get_fault_alert_topic(self.line_id)
            self.mqtt_client.publish(topic, alert_data.model_dump_json())

    def _send_recovery_alert(self, device_id: str, last_symptom: str):
        """发送恢复警报"""
        alert_data = FaultAlert(
            timestamp=self.env.now,
            device_id = device_id,
            alert_type = "fault_recovered",
            symptom= last_symptom,
            fault_type="unknown", # We don't know the fault type anymore after clearing it
            estimated_duration= 0.0,
            message=f"Device {device_id} fault has been automatically recovered"
        )
        
        if self.mqtt_client and self.topic_manager and self.line_id:
            topic = self.topic_manager.get_fault_alert_topic(self.line_id)
            self.mqtt_client.publish(topic, alert_data.model_dump_json())

    def force_clear_fault(self, device_id: str) -> bool:
        """强制清除故障（调试用）"""
        if device_id in self.active_faults:
            # 中断故障过程
            if device_id in self.fault_processes:
                self.fault_processes[device_id].interrupt()
            
            # 清除故障
            self._clear_fault(device_id)
            print(f"[{self.env.now:.2f}] 🔧 强制清除故障: {device_id}")
            return True
        
        print(f"[{self.env.now:.2f}] ❌ 设备 {device_id} 无故障需要清除")
        return False

    def get_device_symptom(self, device_id: str) -> Optional[str]:
        """获取设备症状"""
        if device_id in self.active_faults:
            return self.active_faults[device_id].symptom
        return None

    def is_device_faulty(self, device_id: str) -> bool:
        """检查设备是否有故障"""
        return device_id in self.active_faults

    def get_fault_info(self, device_id: str) -> Optional[Dict]:
        """获取设备故障信息"""
        if device_id in self.active_faults:
            fault = self.active_faults[device_id]
            remaining_time = fault.duration - (self.env.now - fault.start_time)
            return {
                "device_id": device_id,
                "fault_type": fault.fault_type.value,
                "symptom": fault.symptom,
                "duration": fault.duration,
                "remaining_time": max(0, remaining_time),
                "start_time": fault.start_time
            }
        return None

    def get_all_fault_info(self) -> List[Dict]:
        """获取所有故障信息"""
        fault_info_list = []
        for device_id in self.active_faults.keys():
            fault_info = self.get_fault_info(device_id)
            if fault_info is not None:
                fault_info_list.append(fault_info)
        return fault_info_list

    def get_available_devices(self) -> List[str]:
        """获取可用设备列表（无故障的设备）"""
        available = []
        for device_id, device in self.factory_devices.items():
            if device_id not in self.active_faults and device.status != DeviceStatus.FAULT:
                available.append(device_id)
        return available

    def get_fault_stats(self) -> Dict:
        """获取故障统计信息"""
        return {
            "active_faults": len(self.active_faults),
            "fault_devices": list(self.active_faults.keys()),
            "available_devices": len(self.get_available_devices()),
            "total_devices": len(self.factory_devices)
        }

@dataclass
class SimpleFault:
    """简化的故障实例"""
    device_id: str
    fault_type: FaultType
    symptom: str
    duration: float  # 故障持续时间（秒）
    start_time: float

# 为了向后兼容，保留原有的类名
FaultSystem = FaultSystem
ActiveFault = SimpleFault


================================================
File: src/game_logic/kpi_calculator.py
================================================
# src/game_logic/kpi_calculator.py
import simpy
from typing import Dict, List, Optional, Any, TYPE_CHECKING
from dataclasses import dataclass, field

from config.schemas import KPIUpdate, NewOrder
from config.topics import KPI_UPDATE_TOPIC
from src.utils.mqtt_client import MQTTClient
from src.utils.topic_manager import TopicManager

if TYPE_CHECKING:
    from src.simulation.entities.product import Product

@dataclass
class ProductTracking:
    """Track individual product for production cycle calculation."""
    product_id: str
    product_type: str  # P1, P2, P3
    order_id: str
    start_time: float  # When order is created
    theoretical_time: float  # Based on product type
    production_start_time: Optional[float] = None  # When it actually enters production (StationA)
    end_time: Optional[float] = None  # When it exits the production line

@dataclass
class OrderTracking:
    """Track individual order progress for KPI calculation."""
    order_id: str
    created_at: float
    deadline: float
    items_total: int
    items_completed: int = 0
    completed_at: Optional[float] = None
    is_on_time: Optional[bool] = None
    total_cost: float = 0.0
    products: List[ProductTracking] = field(default_factory=list)

@dataclass
class ProductionStats:
    """Production statistics for KPI calculation."""
    total_orders: int = 0
    completed_orders: int = 0
    on_time_orders: int = 0
    total_products: int = 0
    quality_passed_products: int = 0
    scrapped_products: int = 0
    
    # Time tracking
    total_production_time: float = 0.0
    total_simulation_time: float = 0.0
    weighted_production_cycle_sum: float = 0.0  # Sum of (actual/theoretical) ratios
    
    # Cost tracking
    material_costs: float = 0.0
    energy_costs: float = 0.0
    maintenance_costs: float = 0.0
    scrap_costs: float = 0.0
    
    # Fault tracking
    total_faults: int = 0
    correct_diagnoses: int = 0
    total_recovery_time: float = 0.0
    
    # Device utilization (device_id -> working_time)
    device_working_time: Dict[str, float] = field(default_factory=dict)
    device_total_time: Dict[str, float] = field(default_factory=dict)
    
    # AGV metrics
    agv_active_charges: int = 0  # 主动充电次数
    agv_passive_charges: int = 0  # 被动充电次数
    agv_total_charge_time: float = 0.0  # 总充电时间
    agv_completed_tasks: int = 0  # AGV完成的任务数
    agv_transport_time: Dict[str, float] = field(default_factory=dict)  # AGV运输时间
    agv_fault_time: Dict[str, float] = field(default_factory=dict)  # AGV故障时间
    agv_charge_time: Dict[str, float] = field(default_factory=dict)  # AGV充电时间

class KPICalculator:
    """
    Calculates KPIs according to PRD 3.4 Section 2.8 specifications.
    
    KPI categories defined in PRD:
    - Production Efficiency: Order completion rate, production cycle, device utilization
    - Quality & Cost: First pass rate, total production cost
    - AGV Efficiency: Charge strategy, energy efficiency, utilization
    
    Note: Competition scoring weights are not specified in PRD, so we use:
    - Production Efficiency: 40%
    - Quality & Cost: 30%
    - AGV Efficiency: 30%
    """
    
    def __init__(self, env: simpy.Environment, mqtt_client: Optional[MQTTClient] = None, topic_manager: Optional[TopicManager] = None, config: Optional[Dict[str, Any]] = None):
        self.env = env
        self.mqtt_client = mqtt_client
        self.topic_manager = topic_manager
        self.stats = ProductionStats()
        self.active_orders: Dict[str, OrderTracking] = {}
        self.completed_orders: List[OrderTracking] = []
        
        # Load configuration from YAML if not provided
        if config is None:
            from src.utils.config_loader import load_factory_config
            config = load_factory_config()
        
        # Load KPI weights from config
        kpi_weights = config.get('kpi_weights', {})
        self.weights = {
            'production_efficiency': kpi_weights.get('production_efficiency', 0.40),
            'quality_cost': kpi_weights.get('quality_cost', 0.30),
            'agv_efficiency': kpi_weights.get('agv_efficiency', 0.30)
        }
        
        # Load sub-weights for each KPI category
        self.efficiency_weights = kpi_weights.get('efficiency_components', {
            'order_completion': 0.40,
            'production_cycle': 0.40,
            'device_utilization': 0.20
        })
        
        self.quality_cost_weights = kpi_weights.get('quality_cost_components', {
            'first_pass_rate': 0.40,
            'cost_efficiency': 0.60
        })
        
        self.agv_weights = kpi_weights.get('agv_components', {
            'charge_strategy': 0.30,
            'energy_efficiency': 0.40,
            'utilization': 0.30
        })
        
        # Load cost parameters from config
        kpi_costs = config.get('kpi_costs', {})
        self.cost_parameters = {
            'material_cost_per_product': kpi_costs.get('material_cost_per_product', {'P1': 10.0, 'P2': 15.0, 'P3': 20.0}),
            'energy_cost_per_second': kpi_costs.get('energy_cost_per_second', 0.1),
            'energy_cost_multiplier_peak': kpi_costs.get('energy_cost_multiplier_peak', 1.5),
            'maintenance_cost_base': kpi_costs.get('maintenance_cost_base', 8.0),
            'scrap_cost_multiplier': kpi_costs.get('scrap_cost_multiplier', 0.8),
        }
        
        # Load theoretical production times from order generator config
        order_gen_config = config.get('order_generator', {})
        self.theoretical_production_times = order_gen_config.get('theoretical_production_times', {
            'P1': 160.0,
            'P2': 200.0,
            'P3': 250.0
        })
        
        # Track active products
        self.active_products: Dict[str, ProductTracking] = {}
        
        # Track last KPI state for change detection
        self.last_kpi_hash = None
        
        # Track active faults count
        self._active_faults_count = 0

    def _check_and_publish_kpi_update(self):
        """Calculate KPIs and publish only if changed."""
        kpi_update = self.calculate_current_kpis()
        
        # Create a hash of key KPI values to detect changes
        kpi_hash = (
            round(kpi_update.order_completion_rate, 2),
            round(kpi_update.average_production_cycle, 2),
            round(kpi_update.total_production_cost, 2),
            kpi_update.total_orders,
            kpi_update.completed_orders,
            kpi_update.total_products,
            kpi_update.active_faults,
            round(kpi_update.charge_strategy_efficiency, 2),
            round(kpi_update.agv_energy_efficiency, 2)
        )
        
        # Only publish if KPIs have changed
        if kpi_hash != self.last_kpi_hash:
            self.last_kpi_hash = kpi_hash
            self._publish_kpi_update(kpi_update)

    def register_new_order(self, order: NewOrder):
        """Register a new order for tracking."""
        total_items = sum(item.quantity for item in order.items)
        
        order_tracking = OrderTracking(
            order_id=order.order_id,
            created_at=order.created_at,
            deadline=order.deadline,
            items_total=total_items
        )
        
        self.active_orders[order.order_id] = order_tracking
        self.stats.total_orders += 1
        
        # Trigger KPI update on new order
        self._check_and_publish_kpi_update()
        
        # Create product tracking for each product (material costs will be added when taken from warehouse)
        for item in order.items:
            # Create product tracking for each product
            for i in range(item.quantity):
                product_id = f"{order.order_id}_P{item.product_type}_{i}"
                product_tracking = ProductTracking(
                    product_id=product_id,
                    product_type=item.product_type,
                    order_id=order.order_id,
                    start_time=self.env.now,  # Order creation time
                    theoretical_time=self.theoretical_production_times[item.product_type]
                )
                order_tracking.products.append(product_tracking)
                self.active_products[product_id] = product_tracking

    def complete_order_item(self, order_id: str, product_type: Optional[str] = None, passed_quality: bool = True):
        """Mark an order item as completed."""
        if order_id not in self.active_orders:
            return
            
        order = self.active_orders[order_id]
        order.items_completed += 1
        self.stats.total_products += 1
        
        # Find the product tracking and update it
        if product_type:
            for product in order.products:
                if product.product_type == product_type and product.end_time is None:
                    product.end_time = self.env.now
                    
                    # Use production_start_time if available, otherwise fall back to start_time
                    actual_start = product.production_start_time if product.production_start_time is not None else product.start_time
                    actual_time = product.end_time - actual_start
                    theoretical_time = product.theoretical_time
                    
                    # Add to weighted production cycle sum only for passed products
                    if theoretical_time > 0 and passed_quality:
                        self.stats.weighted_production_cycle_sum += actual_time / theoretical_time
                    
                    # Remove from active products
                    if product.product_id in self.active_products:
                        del self.active_products[product.product_id]
                    break
        
        if passed_quality:
            self.stats.quality_passed_products += 1
        else:
            self.stats.scrapped_products += 1
            # Add scrap cost
            if product_type:
                scrap_cost = self.cost_parameters['material_cost_per_product'][product_type] * self.cost_parameters['scrap_cost_multiplier']
                order.total_cost += scrap_cost
                self.stats.scrap_costs += scrap_cost
        
        # Check if order is complete
        if order.items_completed >= order.items_total:
            self._complete_order(order)

    def _complete_order(self, order: OrderTracking):
        """Complete an order and update statistics."""
        order.completed_at = self.env.now
        order.is_on_time = order.completed_at <= order.deadline
        
        self.stats.completed_orders += 1
        if order.is_on_time:
            self.stats.on_time_orders += 1
            
        # Add to production time tracking
        production_time = order.completed_at - order.created_at
        self.stats.total_production_time += production_time
        
        # Move to completed orders
        self.completed_orders.append(order)
        del self.active_orders[order.order_id]
        
        # Trigger KPI update on order completion
        self._check_and_publish_kpi_update()

    def add_energy_cost(self, device_id: str, line_id: Optional[str], duration: float, is_peak_hour: bool = False):
        """Add energy costs for device operation."""
        # Validate parameters to help debug
        try:
            if not isinstance(duration, (int, float)):
                raise TypeError(f"Duration must be a number, got {type(duration).__name__}: {duration}")
        except Exception as e:
            print(f"[DEBUG] add_energy_cost called with: device_id={device_id}, line_id={line_id}, duration={duration}, is_peak_hour={is_peak_hour}")
            raise
        
        base_cost = duration * self.cost_parameters['energy_cost_per_second']
        if is_peak_hour:
            base_cost *= self.cost_parameters['energy_cost_multiplier_peak']
        
        self.stats.energy_costs += base_cost
        
        # Update device working time with line_id to avoid conflicts
        # Note: Some devices (Station) only use this method to track working time
        internal_device_key = f"{line_id}_{device_id}" if line_id else device_id
        if internal_device_key not in self.stats.device_working_time:
            self.stats.device_working_time[internal_device_key] = 0.0
        self.stats.device_working_time[internal_device_key] += duration
        
        # Trigger KPI update on energy cost change
        self._check_and_publish_kpi_update()

    def add_maintenance_cost(self, _device_id: str, _maintenance_type: str, was_correct_diagnosis: bool):
        """Add maintenance costs and track diagnosis accuracy."""
        base_cost = self.cost_parameters['maintenance_cost_base']
        
        # Penalty for incorrect diagnosis
        if not was_correct_diagnosis:
            base_cost *= 2.0  # Double cost for wrong diagnosis
            
        self.stats.maintenance_costs += base_cost
        self.stats.total_faults += 1
        
        if was_correct_diagnosis:
            self.stats.correct_diagnoses += 1
        
        # Trigger KPI update on maintenance event
        self._check_and_publish_kpi_update()
    
    def update_active_faults_count(self, count: int):
        """Update the active faults count (called by FaultSystem)"""
        self._active_faults_count = count
        self._check_and_publish_kpi_update()
    
    def mark_production_start(self, product: 'Product'):
        """Mark when a product actually starts production (enters first station)."""
        # Find the product tracking by order_id and product_type
        order_id = product.order_id
        product_type = product.product_type
        
        # Look for the first unstarted product of this type in this order
        for tracking_id, tracking in self.active_products.items():
            if (tracking.order_id == order_id and 
                tracking.product_type == product_type and 
                tracking.production_start_time is None):
                tracking.production_start_time = self.env.now
                print(f"[KPI] Product {product.id} (tracking: {tracking_id}) started production at {self.env.now:.2f}")
                break
    
    def register_agv_charge(self, agv_id: str, line_id: Optional[str], is_active: bool, charge_duration: float):
        """Register AGV charging event."""
        if is_active:
            self.stats.agv_active_charges += 1
        else:
            self.stats.agv_passive_charges += 1
        
        self.stats.agv_total_charge_time += charge_duration
        
        # Update AGV charge time tracking with line_id to avoid conflicts
        internal_agv_key = f"{line_id}_{agv_id}" if line_id else agv_id
        if internal_agv_key not in self.stats.agv_charge_time:
            self.stats.agv_charge_time[internal_agv_key] = 0.0
        self.stats.agv_charge_time[internal_agv_key] += charge_duration
        
        # Trigger KPI update on charging event
        self._check_and_publish_kpi_update()
    
    def register_agv_task_complete(self, _agv_id: str, _line_id: Optional[str] = None):
        """Register AGV task completion."""
        self.stats.agv_completed_tasks += 1
        
        # Trigger KPI update on AGV task completion
        self._check_and_publish_kpi_update()
    
    def update_agv_transport_time(self, agv_id: str, line_id: Optional[str], transport_time: float):
        """Update AGV transport time."""
        internal_agv_key = f"{line_id}_{agv_id}" if line_id else agv_id
        if internal_agv_key not in self.stats.agv_transport_time:
            self.stats.agv_transport_time[internal_agv_key] = 0.0
        self.stats.agv_transport_time[internal_agv_key] += transport_time
        
        # Trigger KPI update on AGV transport time change
        self._check_and_publish_kpi_update()
    
    def update_agv_fault_time(self, agv_id: str, line_id: Optional[str], fault_time: float):
        """Update AGV fault time."""
        internal_agv_key = f"{line_id}_{agv_id}" if line_id else agv_id
        if internal_agv_key not in self.stats.agv_fault_time:
            self.stats.agv_fault_time[internal_agv_key] = 0.0
        self.stats.agv_fault_time[internal_agv_key] += fault_time
        
        # Trigger KPI update on AGV fault time change
        self._check_and_publish_kpi_update()

    def add_fault_recovery_time(self, recovery_time: float):
        """Track fault recovery time for robustness metrics."""
        self.stats.total_recovery_time += recovery_time
        
        # Trigger KPI update on fault recovery
        self._check_and_publish_kpi_update()

    def update_device_utilization(self, device_id: str, line_id: Optional[str], total_time: float):
        """Update device total time for utilization calculation."""
        internal_device_key = f"{line_id}_{device_id}" if line_id else device_id
        self.stats.device_total_time[internal_device_key] = total_time
        # Ensure device has a working_time entry to prevent KeyError
        if internal_device_key not in self.stats.device_working_time:
            self.stats.device_working_time[internal_device_key] = 0.0
        
        # Trigger KPI update on device utilization change
        self._check_and_publish_kpi_update()
    
    def track_device_working_time(self, device_id: str, line_id: Optional[str], duration: float):
        """Track actual working time for a device"""
        internal_device_key = f"{line_id}_{device_id}" if line_id else device_id
        if internal_device_key not in self.stats.device_working_time:
            self.stats.device_working_time[internal_device_key] = 0.0
        self.stats.device_working_time[internal_device_key] += duration
        
        # Trigger KPI update on device working time change
        self._check_and_publish_kpi_update()

    def calculate_current_kpis(self) -> KPIUpdate:
        """Calculate current KPI values according to PRD 3.4 Section 2.8 formulas."""
        current_time = self.env.now
        self.stats.total_simulation_time = current_time
        
        # Production Efficiency Metrics (40%)
        # 1. 订单完成率 (按时完成订单数 / 总订单数)
        order_completion_rate = (
            (self.stats.on_time_orders / self.stats.total_orders * 100) 
            if self.stats.total_orders > 0 else 0.0
        )
        
        # 2. 加权平均生产周期 (实际时间与理论时间的比率)
        # 改进：考虑产品完成率，避免选择性完成快速产品的策略
        base_cycle_ratio = (
            (self.stats.weighted_production_cycle_sum / self.stats.quality_passed_products)
            if self.stats.quality_passed_products > 0 else 0.0
        )
        
        # 计算产品完成率（已完成的产品数 / 已开始生产的产品总数）
        total_started_products = len(self.active_products) + self.stats.total_products
        product_completion_rate = (
            self.stats.quality_passed_products / total_started_products
            if total_started_products > 0 else 0.0
        )
        
        # 应用完成率权重：完成率低会增加生产周期值（惩罚）
        # 如果完成率是100%，则不影响；如果完成率是50%，则周期值翻倍
        if product_completion_rate > 0:
            average_production_cycle = base_cycle_ratio / product_completion_rate
        else:
            average_production_cycle = 0.0  # No production = 0 efficiency
        
        # 3. 按时交付率 (这个指标与订单完成率重复，可用于额外分析)
        on_time_delivery_rate = (
            (self.stats.on_time_orders / self.stats.completed_orders * 100)
            if self.stats.completed_orders > 0 else 0.0
        )
        
        # Quality Metrics
        first_pass_rate = (
            (self.stats.quality_passed_products / self.stats.total_products * 100)
            if self.stats.total_products > 0 else 0.0
        )
        
        # Device Utilization
        device_utilization = {}
        for device_id in self.stats.device_working_time:
            working_time = self.stats.device_working_time[device_id]
            total_time = self.stats.device_total_time.get(device_id, current_time)
            utilization = (working_time / total_time * 100) if total_time > 0 else 0.0
            device_utilization[device_id] = utilization
        
        average_device_utilization = (
            sum(device_utilization.values()) / len(device_utilization)
            if device_utilization else 0.0
        )
        
        # Cost Control Metrics (30%)
        total_production_cost = (
            self.stats.material_costs + self.stats.energy_costs + 
            self.stats.maintenance_costs + self.stats.scrap_costs
        )
        
        # AGV Metrics
        # 充电策略效率
        total_charges = self.stats.agv_active_charges + self.stats.agv_passive_charges
        charge_strategy_efficiency = (
            (self.stats.agv_active_charges / total_charges * 100)
            if total_charges > 0 else 0.0  # No charging activity = 0 efficiency
        )
        
        # AGV能效比 (完成任务数 / 总充电时间)
        # 时间单位：秒
        agv_energy_efficiency = (
            (self.stats.agv_completed_tasks / self.stats.agv_total_charge_time)  # tasks per second of charging
            if self.stats.agv_total_charge_time > 0 else 0.0
        )
        
        # AGV利用率
        agv_utilization = {}
        for agv_id in self.stats.agv_transport_time:
            transport_time = self.stats.agv_transport_time.get(agv_id, 0.0)
            fault_time = self.stats.agv_fault_time.get(agv_id, 0.0)
            charge_time = self.stats.agv_charge_time.get(agv_id, 0.0)
            total_time = current_time - fault_time - charge_time
            
            if total_time > 0:
                # Cap utilization at 100% to handle edge cases
                agv_utilization[agv_id] = min(100.0, transport_time / total_time * 100)
            else:
                agv_utilization[agv_id] = 0.0
        
        average_agv_utilization = (
            sum(agv_utilization.values()) / len(agv_utilization)
            if agv_utilization else 0.0
        )
        
        return KPIUpdate(
            timestamp=round(current_time, 2),
            
            # Production Efficiency (40%)
            order_completion_rate=round(order_completion_rate, 2),
            average_production_cycle=round(average_production_cycle, 2),
            on_time_delivery_rate=round(on_time_delivery_rate, 2),
            device_utilization=round(average_device_utilization, 2),
            
            # Quality Metrics
            first_pass_rate=round(first_pass_rate, 2),
            
            # Cost Control (30%)
            total_production_cost=round(total_production_cost, 2),
            material_costs=round(self.stats.material_costs, 2),
            energy_costs=round(self.stats.energy_costs, 2),
            maintenance_costs=round(self.stats.maintenance_costs, 2),
            scrap_costs=round(self.stats.scrap_costs, 2),
            
            # AGV Efficiency Metrics
            charge_strategy_efficiency=round(charge_strategy_efficiency, 2),
            agv_energy_efficiency=round(agv_energy_efficiency, 2),
            agv_utilization=round(average_agv_utilization, 2),
            
            # Raw Counts
            total_orders=self.stats.total_orders,
            completed_orders=self.stats.completed_orders,
            active_orders=len(self.active_orders),
            total_products=self.stats.total_products,
            active_faults=self._active_faults_count
        )

    def _publish_kpi_update(self, kpi_update: KPIUpdate):
        """Publish KPI update to MQTT."""
        try:
            if self.mqtt_client:
                if self.topic_manager:
                    topic = self.topic_manager.get_kpi_topic()
                else:
                    from config.topics import KPI_UPDATE_TOPIC
                    topic = KPI_UPDATE_TOPIC
                self.mqtt_client.publish(topic, kpi_update.model_dump_json())
                # print(f"[{self.env.now:.2f}] 📊 KPI Update published")
        except Exception as e:
            print(f"[{self.env.now:.2f}] ❌ Failed to publish KPI update: {e}")
    
    def force_kpi_update(self):
        """Force an immediate KPI update (bypasses change detection)."""
        kpi_update = self.calculate_current_kpis()
        self._publish_kpi_update(kpi_update)
        
        # Update the hash to reflect current state
        self.last_kpi_hash = (
            round(kpi_update.order_completion_rate, 2),
            round(kpi_update.average_production_cycle, 2),
            round(kpi_update.total_production_cost, 2),
            kpi_update.total_orders,
            kpi_update.completed_orders,
            kpi_update.total_products,
            kpi_update.active_faults,
            round(kpi_update.charge_strategy_efficiency, 2),
            round(kpi_update.agv_energy_efficiency, 2)
        )

    def get_final_score(self) -> Dict[str, Any]:
        """Calculate final competition score based on PRD 3.4 Section 2.8 KPIs.
        
        Since PRD 3.4 doesn't specify competition scoring weights, we use:
        - Production Efficiency: 40% (order completion, production cycle, device utilization)
        - Quality & Cost: 30% (first pass rate, total cost)
        - AGV Efficiency: 30% (charge strategy, energy efficiency, utilization)
        """
        kpis = self.calculate_current_kpis()
        
        # 生产效率评分 (40%)
        # 包含：订单完成率、加权平均生产周期、设备利用率
        
        # 生产周期评分：只有在有产品生产时才计算
        if self.stats.quality_passed_products > 0 and kpis.average_production_cycle > 0:
            # 比率越接近1越好（实际时间接近理论时间）
            production_cycle_score = min(100, 100 / max(1, kpis.average_production_cycle))
        else:
            # 没有生产任何产品，周期效率为0
            production_cycle_score = 0
        
        efficiency_components = {
            'order_completion': min(100, kpis.order_completion_rate),  # 已经是百分比
            'production_cycle': production_cycle_score,
            'device_utilization': min(100, kpis.device_utilization)  # 已经是百分比
        }
        
        # 子权重分配
        efficiency_score = (
            efficiency_components['order_completion'] * self.efficiency_weights.get('order_completion', 0.4) +
            efficiency_components['production_cycle'] * self.efficiency_weights.get('production_cycle', 0.4) +
            efficiency_components['device_utilization'] * self.efficiency_weights.get('device_utilization', 0.2)
        ) * self.weights['production_efficiency']  # 使用配置的权重
        
        # 成本控制评分 (30%)
        # 基于总生产成本，需要与基准成本比较
        if self.stats.total_products > 0:
            # 如果有生产产品，计算成本效率
            # 基准成本：使用配置中的平均材料成本
            avg_material_cost = sum(self.cost_parameters['material_cost_per_product'].values()) / len(self.cost_parameters['material_cost_per_product'])
            baseline_cost = self.stats.total_products * avg_material_cost
            actual_cost = kpis.total_production_cost
            # 成本越低越好，所以用基准成本除以实际成本
            cost_efficiency = min(100, baseline_cost / max(1, actual_cost) * 100)
        else:
            # 如果没有生产任何产品
            if kpis.total_production_cost > 0:
                # 有成本但没有产出，效率为0
                cost_efficiency = 0
            else:
                # 没有成本也没有产出，给予0分
                cost_efficiency = 0
        
        # 质量与成本评分 (30%)
        # 包含：一次通过率和总生产成本
        quality_cost_components = {
            'first_pass_rate': min(100, kpis.first_pass_rate),  # 已经是百分比
            'cost_efficiency': cost_efficiency
        }
        
        quality_cost_score = (
            quality_cost_components['first_pass_rate'] * self.quality_cost_weights.get('first_pass_rate', 0.4) +
            quality_cost_components['cost_efficiency'] * self.quality_cost_weights.get('cost_efficiency', 0.6)
        ) * self.weights['quality_cost']  # 使用配置的权重
        
        # AGV效率评分 (30%)
        # 包含：充电策略效率、AGV能效比、AGV利用率
        agv_components = {
            'charge_strategy': min(100, kpis.charge_strategy_efficiency),  # 已经是百分比
            'energy_efficiency': min(100, kpis.agv_energy_efficiency * 100),  # 0.1 tasks/s = 100分 (每秒完成0.1个任务为满分)
            'utilization': min(100, kpis.agv_utilization)  # 已经是百分比
        }
        
        # AGV效率权重
        agv_score = (
            agv_components['charge_strategy'] * self.agv_weights.get('charge_strategy', 0.3) +
            agv_components['energy_efficiency'] * self.agv_weights.get('energy_efficiency', 0.4) +
            agv_components['utilization'] * self.agv_weights.get('utilization', 0.3)
        ) * self.weights['agv_efficiency']
        
        total_score = efficiency_score + quality_cost_score + agv_score
        
        return {
            "efficiency_score": efficiency_score,
            "efficiency_components": efficiency_components,
            "quality_cost_score": quality_cost_score,
            "quality_cost_components": quality_cost_components,
            "agv_score": agv_score,
            "agv_components": agv_components,
            "total_score": total_score,
            "raw_kpis": {
                "order_completion_rate": kpis.order_completion_rate,
                "average_production_cycle": kpis.average_production_cycle,
                "device_utilization": kpis.device_utilization,
                "first_pass_rate": kpis.first_pass_rate,
                "total_production_cost": kpis.total_production_cost,
                "charge_strategy_efficiency": kpis.charge_strategy_efficiency,
                "agv_energy_efficiency": kpis.agv_energy_efficiency,
                "agv_utilization": kpis.agv_utilization
            }
        } 


================================================
File: src/game_logic/order_generator.py
================================================
# src/game_logic/order_generator.py
import random
import uuid
import simpy
from typing import Dict, List, Optional

from config.schemas import NewOrder, OrderItem, OrderPriority
from config.topics import NEW_ORDER_TOPIC
from src.utils.mqtt_client import MQTTClient
from src.simulation.entities.warehouse import RawMaterial
from src.simulation.entities.product import Product
from src.game_logic.kpi_calculator import KPICalculator
from src.utils.topic_manager import TopicManager

class OrderGenerator:
    """
    Generates orders according to PRD 2.4 specifications:
    - Generation interval: 30-60 seconds (uniform random)
    - Order quantity: 1-5 items (weighted: 40%, 30%, 20%, 7%, 3%)
    - Product distribution: P1(60%), P2(30%), P3(10%)
    - Priority distribution: Low(70%), Medium(25%), High(5%)
    """
    
    def __init__(self, env: simpy.Environment, raw_material: RawMaterial, mqtt_client: Optional[MQTTClient] = None, topic_manager: Optional[TopicManager] = None, kpi_calculator: Optional[KPICalculator] = None, **kwargs):
        self.env = env
        self.mqtt_client = mqtt_client
        self.topic_manager = topic_manager
        self.raw = raw_material
        self.kpi_calculator = kpi_calculator
        # Order generation parameters from kwargs
        self.generation_interval_range = kwargs.get('generation_interval_range', (10, 50))
        self.quantity_weights = kwargs.get('quantity_weights', {1: 40, 2: 30, 3: 20, 4: 7, 5: 3})
        self.product_distribution = kwargs.get('product_distribution', {'P1': 60, 'P2': 30, 'P3': 10})
        self.priority_distribution = kwargs.get('priority_distribution', {
            OrderPriority.LOW: 70,
            OrderPriority.MEDIUM: 25, 
            OrderPriority.HIGH: 5
        })
        
        # Theoretical production times for deadline calculation (in seconds)
        self.theoretical_production_times = kwargs.get('theoretical_production_times', {
            'P1': 160,
            'P2': 200,
            'P3': 250
        })
        
        # Priority multipliers for deadline calculation
        self.priority_multipliers = kwargs.get('priority_multipliers', {
            OrderPriority.LOW: 3.0,
            OrderPriority.MEDIUM: 2.0,
            OrderPriority.HIGH: 1.5
        })
        
        # Start the order generation process
        self.env.process(self.run())

    def run(self):
        """Main order generation loop."""
        while True:
            # Wait for next order generation
            wait_time = random.uniform(*self.generation_interval_range)
            yield self.env.timeout(wait_time)
            
            # Generate and publish new order
            order = self._generate_order()
            if order:
                self._publish_order(order)

    def _generate_order(self) -> Optional[NewOrder]:
        """Generate a single order according to PRD specifications."""
        if self.raw.is_full():
            print(f"[{self.env.now:.2f}] ❌ Raw material warehouse is full, cannot accept new order")
            return None
        
        order_id = f"order_{uuid.uuid4().hex[:8]}"
        created_at = self.env.now
        
        # Generate order items
        items = self._generate_order_items()
        
        # Determine priority
        priority = self._select_priority()
        
        # Calculate deadline based on priority and theoretical production time
        deadline = self._calculate_deadline(created_at, items, priority)
        
        for item in items:
            self.raw.create_raw_material(item.product_type, order_id)
        
        return NewOrder(
            order_id=order_id,
            created_at=created_at,
            items=items,
            priority=priority,
            deadline=deadline
        )

    def _generate_order_items(self) -> List[OrderItem]:
        """Generate order items with proper quantity and product distribution."""
        # Select order quantity based on weights
        quantity = self._weighted_choice(self.quantity_weights)
        
        items = []
        for _ in range(quantity):
            # Select product type based on distribution
            product_type = self._weighted_choice(self.product_distribution)
            
            # For simplicity, each item has quantity 1
            # In a more complex system, this could vary
            items.append(OrderItem(
                product_type=product_type,
                quantity=1
            ))
        
        return items

    def _select_priority(self) -> OrderPriority:
        """Select order priority based on distribution."""
        return self._weighted_choice(self.priority_distribution)

    def _calculate_deadline(self, created_at: float, items: List[OrderItem], priority: OrderPriority) -> float:
        """Calculate order deadline based on theoretical production time and priority."""
        # Calculate total theoretical production time
        total_time = 0
        for item in items:
            base_time = self.theoretical_production_times[item.product_type]
            total_time += base_time * item.quantity
        
        # Apply priority multiplier
        multiplier = self.priority_multipliers[priority]
        deadline = created_at + (total_time * multiplier)
        
        return deadline

    def _weighted_choice(self, weights_dict: Dict):
        """Select an item based on weighted probabilities."""
        items = list(weights_dict.keys())
        weights = list(weights_dict.values())
        return random.choices(items, weights=weights)[0]

    def _publish_order(self, order: NewOrder):
        """Publish the order to MQTT."""
        try:
            if self.mqtt_client and self.topic_manager:
                topic = self.topic_manager.get_order_topic()
                self.mqtt_client.publish(topic, order.model_dump_json())
            
            # Register order with KPI calculator
            if self.kpi_calculator:
                self.kpi_calculator.register_new_order(order)
            
            # print(f"[{self.env.now:.2f}] 📋 New order generated: {order.order_id}")
            # print(f"   - Items: {[(item.product_type, item.quantity) for item in order.items]}")
            # print(f"   - Priority: {order.priority.value}")
            # print(f"   - Deadline: {order.deadline:.1f}s (in {order.deadline - self.env.now:.1f}s)")
        except Exception as e:
            print(f"[{self.env.now:.2f}] ❌ Failed to publish order: {e}") 



================================================
File: src/simulation/factory.py
================================================
# src/simulation/factory.py
import simpy
import random
from typing import Dict, List, Tuple, Optional

from src.simulation.entities.conveyor import Conveyor, TripleBufferConveyor
from src.simulation.entities.base import BaseConveyor
from src.simulation.entities.warehouse import Warehouse, RawMaterial
from src.simulation.entities.station import Station
from src.simulation.entities.agv import AGV
from src.simulation.entities.quality_checker import QualityChecker
from src.game_logic.order_generator import OrderGenerator
from src.game_logic.fault_system import FaultSystem
from src.game_logic.kpi_calculator import KPICalculator
from src.utils.mqtt_client import MQTTClient

# Import configuration loader
from src.utils.config_loader import load_factory_config

class Factory:
    """
    The main class that orchestrates the entire factory simulation.
    """
    def __init__(self, layout_config: Dict, mqtt_client: Optional[MQTTClient] = None, no_faults: bool = False):
        self.env = simpy.Environment()
        self.layout = layout_config
        self.mqtt_client = mqtt_client
        self.no_faults_mode = no_faults # Store the flag
        
        self.stations: Dict[str, Station] = {}
        self.agvs: Dict[str, AGV] = {}
        self.conveyors: Dict[str, BaseConveyor] = {}
        
        # Warehouse attributes - will be set during device creation
        self.warehouse: Optional[Warehouse] = None
        self.raw_material: Optional[RawMaterial] = None
        
        # AGV task queue for product transportation
        self.agv_task_queue = simpy.Store(self.env)
        
        # Statistics for scrapped products
        self.scrap_stats = {
            "total_scrapped": 0,
            "scrap_by_station": {},
            "scrap_reasons": {}
        }
        
        # Initialize all_devices dictionary first
        self.all_devices = {}

        # Game logic components will be initialized dynamically
        self.order_generator: Optional[OrderGenerator] = None
        self.fault_system: Optional[FaultSystem] = None
        
        # Initialize KPI calculator early so it can be passed to devices
        self.kpi_calculator = KPICalculator(self.env, self.mqtt_client, None, self.layout)
        
        # Create devices first
        self._create_devices()
        
        # Update all_devices with created devices
        self.all_devices.update(self.stations)
        self.all_devices.update(self.agvs)
        self.all_devices.update(self.conveyors)

        if self.warehouse is not None:
            self.all_devices[self.warehouse.id] = self.warehouse

        if self.raw_material is not None:
            self.all_devices[self.raw_material.id] = self.raw_material
        
        # Create game logic systems from config
        self._create_game_logic_systems()

        # If order generator is not created, some features might not work.
        if not self.order_generator:
            print("⚠️ Order Generator not configured in layout. Order-related features will be disabled.")

        # If fault system is not created, fault features will be disabled.
        if not self.fault_system:
            print("⚠️ Fault System not configured in layout or is disabled. No faults will be generated.")
        
        # Recreate order generator with KPI calculator
        if self.order_generator:
            self._update_order_generator_with_kpi()
        
        # Update all devices with KPI calculator
        self._update_agvs_with_kpi()
        self._update_stations_with_kpi()
        
        # Setup event handlers
        self._setup_event_handlers()
        
        # Start process to update active faults count
        self.env.process(self._update_active_faults_count())
        
        # Start device status publishing
        self._start_status_publishing()
           
        self._bind_conveyors_to_stations()
        self._setup_conveyor_downstreams()

    def _create_devices(self):
        """Instantiates all devices based on the layout configuration."""
        
        for station_cfg in self.layout['stations']:
            # Quality checker station
            if station_cfg['id'] == 'QualityCheck':
                station = QualityChecker(
                    env=self.env,
                    mqtt_client=self.mqtt_client,
                    **station_cfg
                )
                print(f"[{self.env.now:.2f}] 🔍 Created QualityChecker: {station_cfg['id']}")
            else:
                # create normal station
                station = Station(
                    env=self.env,
                    mqtt_client=self.mqtt_client,
                    **station_cfg
                )
                print(f"[{self.env.now:.2f}] 🏭 Created Station: {station_cfg['id']}")
            
            self.stations[station.id] = station
        
        # create AGV
        for agv_cfg in self.layout['agvs']:
            agv = AGV(
                env=self.env,
                mqtt_client=self.mqtt_client,
                fault_system=self.fault_system,
                kpi_calculator=self.kpi_calculator,
                **agv_cfg
            )
            self.agvs[agv.id] = agv
            print(f"[{self.env.now:.2f}] 🚛 Created AGV: {agv_cfg['id']}")
        
        # create conveyor
        for conveyor_cfg in self.layout['conveyors']:
            conveyor_id = conveyor_cfg['id']
            # Common arguments for all conveyors
            common_args = {
                "env": self.env,
                "id": conveyor_id,
                "position": conveyor_cfg['position'],
                "interacting_points": conveyor_cfg['interacting_points'],
                "transfer_time": conveyor_cfg['transfer_time'],
                "mqtt_client": self.mqtt_client,
                "kpi_calculator": self.kpi_calculator
            }
            if conveyor_id == 'Conveyor_CQ':
                conveyor = TripleBufferConveyor(
                    main_capacity=conveyor_cfg['main_capacity'],
                    upper_capacity=conveyor_cfg['upper_capacity'],
                    lower_capacity=conveyor_cfg['lower_capacity'],
                    **common_args
                )
            elif conveyor_id in ['Conveyor_AB', 'Conveyor_BC']:
                conveyor = Conveyor(
                    capacity=conveyor_cfg['capacity'],
                    **common_args
                )
            else:
                raise ValueError(f"Unknown conveyor type: {conveyor_id}")
            
            self.conveyors[conveyor.id] = conveyor
            print(f"[{self.env.now:.2f}] 🚛 Created Conveyor: {conveyor_id}")
        
        # create warehouse
        for warehouse_cfg in self.layout['warehouses']:
            # Common arguments for all warehouses
            common_args = {
                "env": self.env,
                "mqtt_client": self.mqtt_client,
                **warehouse_cfg
            }
            if warehouse_cfg['id'] == 'RawMaterial':
                warehouse = RawMaterial(**common_args, kpi_calculator=self.kpi_calculator)
                self.raw_material = warehouse  # Store dedicated reference
            elif warehouse_cfg['id'] == 'Warehouse':
                warehouse = Warehouse(**common_args)
                self.warehouse = warehouse  # Store dedicated reference
            else:
                raise ValueError(f"Unknown warehouse type: {warehouse_cfg['id']}")
            
            print(f"[{self.env.now:.2f}] 🏪 Created Warehouse: {warehouse_cfg['id']}")

    def _create_game_logic_systems(self):
        """Dynamically create game logic systems like OrderGenerator and FaultSystem from config."""
        if 'order_generator' in self.layout:
            if self.raw_material:
                og_config = self.layout['order_generator']
                self.order_generator = OrderGenerator(
                    env=self.env,
                    raw_material=self.raw_material,
                    mqtt_client=self.mqtt_client,
                    kpi_calculator=None,  # Will be set later
                    **og_config
                )
                print(f"[{self.env.now:.2f}] 📝 Created OrderGenerator with config: {og_config}")
            else:
                print("⚠️ Cannot create OrderGenerator: RawMaterial device not found.")

        if 'fault_system' in self.layout and not self.no_faults_mode:
            fs_config = self.layout['fault_system']
            self.fault_system = FaultSystem(
                env=self.env,
                devices=self.all_devices,
                mqtt_client=self.mqtt_client,
                kpi_calculator=self.kpi_calculator,
                **fs_config
            )
            print(f"[{self.env.now:.2f}] 🔧 Created FaultSystem with config: {fs_config}")
        elif self.no_faults_mode:
            print("🚫 Fault System Disabled (no-faults mode).")

    def _update_order_generator_with_kpi(self):
        """Update order generator with KPI calculator reference."""
        if self.order_generator and self.kpi_calculator:
            self.order_generator.kpi_calculator = self.kpi_calculator
    
    def _update_agvs_with_kpi(self):
        """Update AGVs with KPI calculator reference."""
        if self.kpi_calculator:
            for agv in self.agvs.values():
                agv.kpi_calculator = self.kpi_calculator
    
    def _update_stations_with_kpi(self):
        """Update stations with KPI calculator reference."""
        if self.kpi_calculator:
            for station in self.stations.values():
                station.kpi_calculator = self.kpi_calculator
    
    def _setup_event_handlers(self):
        """Setup event handlers for order processing and fault handling."""
        # Force initial KPI update
        if self.kpi_calculator:
            self.kpi_calculator.force_kpi_update()

    def get_available_devices(self) -> List[str]:
        """
        Get list of devices that can currently be operated (not frozen).
        """
        if self.fault_system is None:
            print(f"[{self.env.now:.2f}] 🚫 Fault System is disabled. No available devices from fault system.")
            return []
        return self.fault_system.get_available_devices()

    def get_device_status(self, device_id: str) -> Dict:
        """Get comprehensive device status including faults."""
        if device_id in self.all_devices:
            device = self.all_devices[device_id]
            detailed_status = device.get_detailed_status()
            
            # Convert to simplified status format for compatibility
            status_dict = {
                'device_id': device_id,
                'device_type': detailed_status.device_type,
                'status': detailed_status.current_status.value,
                'symptom': detailed_status.fault_symptom,
                'temperature': detailed_status.temperature,
                'efficiency_rate': detailed_status.efficiency_rate,
                'can_operate': device.can_operate(),
                'frozen_until': detailed_status.frozen_until
            }
            
            # Add device-specific information
            if device_id in self.stations:
                status_dict.update({
                    'buffer_level': self.stations[device_id].get_buffer_level(),
                    'precision_level': detailed_status.precision_level,
                    'tool_wear_level': detailed_status.tool_wear_level
                })
            elif device_id in self.agvs:
                agv = self.agvs[device_id]
                status_dict.update({
                    'position': {'x': agv.position[0], 'y': agv.position[1]},
                    'battery_level': detailed_status.battery_level,
                    'position_accuracy': detailed_status.position_accuracy,
                    'payload': [p.id for p in agv.payload.items] if hasattr(agv, 'payload') else []
                })
            
            return status_dict
        return {}

    def _start_status_publishing(self):
        """Start processes to publish device status to MQTT."""        
        # Start factory overall status publishing
        self.env.process(self._publish_factory_status())
    
    
    def _publish_factory_status(self):
        """Publish factory overall status every 30 seconds."""
        while True:
            yield self.env.timeout(30.0)  # Publish every 30 seconds
            
            # Create factory status summary
            from config.topics import FACTORY_STATUS_TOPIC
            from config.schemas import FactoryStatus
            
            factory_status = FactoryStatus(
                timestamp=self.env.now,
                total_stations=len(self.stations),
                total_agvs=len(self.agvs),
                active_orders=len(self.kpi_calculator.active_orders),
                total_orders=self.kpi_calculator.stats.total_orders,
                completed_orders=self.kpi_calculator.stats.completed_orders,
                active_faults=len(self.fault_system.active_faults) if self.fault_system else 0,
                simulation_time=self.env.now
            )
            
            try:
                if self.mqtt_client:
                    self.mqtt_client.publish(FACTORY_STATUS_TOPIC, factory_status)
                print(f"[{self.env.now:.2f}] 📊 Published factory status: {factory_status.active_orders} active orders, {factory_status.active_faults} faults")
            except Exception as e:
                print(f"[{self.env.now:.2f}] ❌ Failed to publish factory status: {e}")

    def _publish_fault_events(self):
        """Publish enhanced fault events to make them more visible."""
        while True:
            yield self.env.timeout(1.0)  # Check for faults every 1 seconds
            
            # If there are active faults, publish them more frequently
            if self.fault_system and self.fault_system.active_faults:
                for device_id, fault in self.fault_system.active_faults.items():
                    # Create a detailed fault alert message
                    device_status = self.get_device_status(device_id)
                    
                    fault_alert = {
                        "device_id": device_id,
                        "fault_type": fault.fault_type.value,
                        "symptom": fault.symptom,
                        "duration_seconds": self.env.now - fault.start_time,
                        "device_status": device_status.get('status'),
                        "can_operate": device_status.get('can_operate', False),
                        "frozen_until": device_status.get('frozen_until'),
                        "timestamp": self.env.now
                    }
                    
                    try:
                        import json
                        if self.mqtt_client:
                            self.mqtt_client.publish(f"factory/alerts/{device_id}", json.dumps(fault_alert))
                        print(f"[{self.env.now:.2f}] 🚨 Enhanced fault alert published for {device_id}: {fault.symptom}")
                    except Exception as e:
                        print(f"[{self.env.now:.2f}] ❌ Failed to publish fault alert: {e}")


    def run(self, until: int):
        """Runs the simulation for a given duration."""
        # print(f"--- Factory simulation starting for {until} seconds ---")
        # print(f"--- Available devices: {', '.join(self.all_devices.keys())} ---")
        # print(f"--- Use 'inspect_device', 'skip_repair_time', 'request_maintenance' commands ---")
        """
        # Core simulation processes are already started in __init__:
        # - Order generation: self.order_generator.run() (auto-started)
        # - Fault injection: self.fault_system.run_fault_injection() (auto-started) 
        # - KPI updates: self.kpi_calculator.run_kpi_updates() (auto-started)
        # - MQTT publishing: self._start_status_publishing() (started in __init__)
        """
        # print(f"--- Active processes: Order Gen, Fault Injection, KPI Updates, MQTT Publishing ---")
        self.env.run(until=until)
        # print("--- Factory simulation finished ---")

    def print_final_scores(self):
        """Print final competition scores. Should be called only when simulation truly ends."""
        if self.kpi_calculator:
            final_scores = self.kpi_calculator.get_final_score()
            print(f"\n{'='*60}")
            print("🏆 最终竞赛得分")
            print(f"{'='*60}")
            print(f"生产效率得分 (40%): {final_scores['efficiency_score']:.2f}")
            print(f"  - 订单完成率: {final_scores['efficiency_components']['order_completion']:.1f}%")
            print(f"  - 生产周期效率: {final_scores['efficiency_components']['production_cycle']:.1f}%")
            print(f"  - 设备利用率: {final_scores['efficiency_components']['device_utilization']:.1f}%")
            print(f"\n质量与成本得分 (30%): {final_scores['quality_cost_score']:.2f}")
            print(f"  - 一次通过率: {final_scores['quality_cost_components']['first_pass_rate']:.1f}%")
            print(f"  - 成本效率: {final_scores['quality_cost_components']['cost_efficiency']:.1f}%")
            print(f"\nAGV效率得分 (30%): {final_scores['agv_score']:.2f}")
            print(f"  - 充电策略效率: {final_scores['agv_components']['charge_strategy']:.1f}%")
            print(f"  - 能效比: {final_scores['agv_components']['energy_efficiency']:.1f}%")
            print(f"  - AGV利用率: {final_scores['agv_components']['utilization']:.1f}%")
            print(f"\n总得分: {final_scores['total_score']:.2f}")
            print(f"{'='*60}\n")
            
            # Force a final KPI update with final scores
            self.kpi_calculator.force_kpi_update()
    
    def get_final_scores(self) -> Optional[Dict]:
        """Get final competition scores from KPI calculator."""
        if self.kpi_calculator:
            return self.kpi_calculator.get_final_score()
        return None
    
    def get_factory_stats(self) -> Dict:
        """Get comprehensive factory statistics"""
        station_stats = {}
        for station_id, station in self.stations.items():
            if hasattr(station, 'get_processing_stats'):
                station_stats[station_id] = station.get_processing_stats()
        
        agv_stats = {}
        for agv_id, agv in self.agvs.items():
            agv_stats[agv_id] = {
                "status": agv.status.value,
                "position": agv.position,
                "battery_level": getattr(agv, 'battery_level', 100.0),
                "payload_count": len(agv.payload.items)  # Use .items for SimPy Store
            }
        
        return {
            "timestamp": self.env.now,
            "stations": station_stats,
            "agvs": agv_stats,
            "scrap_stats": self.scrap_stats,
            "total_devices": len(self.all_devices),
            "active_transport_tasks": len(self.agv_task_queue.items)
        }

    def _bind_conveyors_to_stations(self):
        """Bind conveyors to stations according to the process flow."""
        # StationA → conveyor_ab
        if 'StationA' in self.stations and 'Conveyor_AB' in self.conveyors:
            self.stations['StationA'].downstream_conveyor = self.conveyors['Conveyor_AB']
        # StationB → conveyor_bc
        if 'StationB' in self.stations and 'Conveyor_BC' in self.conveyors:
            self.stations['StationB'].downstream_conveyor = self.conveyors['Conveyor_BC']
        # StationC → conveyor_cq (TripleBufferConveyor)
        if 'StationC' in self.stations and 'Conveyor_CQ' in self.conveyors:
            self.stations['StationC'].downstream_conveyor = self.conveyors['Conveyor_CQ']

    def _setup_conveyor_downstreams(self):
        """Set downstream stations for conveyors to enable auto-transfer."""
        # conveyor_ab → StationB
        if 'StationB' in self.stations and 'Conveyor_AB' in self.conveyors:
            self.conveyors['Conveyor_AB'].set_downstream_station(self.stations['StationB'])
        # conveyor_bc → StationC
        if 'StationC' in self.stations and 'Conveyor_BC' in self.conveyors:
            self.conveyors['Conveyor_BC'].set_downstream_station(self.stations['StationC'])
        # conveyor_cq → QualityCheck
        if 'QualityCheck' in self.stations and 'Conveyor_CQ' in self.conveyors:
            self.conveyors['Conveyor_CQ'].set_downstream_station(self.stations['QualityCheck'])
    
    def _update_active_faults_count(self):
        """Periodically update the active faults count in KPI calculator."""
        while True:
            # For single-line factory, just count faults from the single FaultSystem
            active_faults_count = 0
            if self.fault_system:
                active_faults_count = len(self.fault_system.active_faults)
            
            # Update KPI calculator with the count
            if self.kpi_calculator:
                self.kpi_calculator.update_active_faults_count(active_faults_count)
            
            # Wait for 1 second before next update
            yield self.env.timeout(1.0)


# Example of how to run the factory simulation
if __name__ == '__main__':
    from config.settings import MQTT_BROKER_HOST, MQTT_BROKER_PORT
    mqtt_client = MQTTClient(
        host=MQTT_BROKER_HOST,
        port=MQTT_BROKER_PORT,
        client_id="factory_test"
    )
    # 连接MQTT broker
    mqtt_client.connect()
    print(f"✅ Connected to MQTT broker at {MQTT_BROKER_HOST}:{MQTT_BROKER_PORT}")
    
    # 加载配置
    try:
        from src.utils.config_loader import load_factory_config
        layout_config = load_factory_config()
    except Exception as e:
        print(f"❌ Failed to load factory configuration: {e}")
        raise e
    
    factory = Factory(layout_config, mqtt_client)
    
    # Simple test - just create the factory and run briefly
    print(f"[{factory.env.now:.2f}] 🎉 Factory created successfully!")
    print(f"[{factory.env.now:.2f}] 📊 Stations: {list(factory.stations.keys())}")
    print(f"[{factory.env.now:.2f}] 🚛 AGVs: {list(factory.agvs.keys())}")
    agv1 = factory.agvs['AGV_1']
    factory.env.process(agv1.move_to('LP1'))

    print(f"[{factory.env.now:.2f}] 🛤️  Conveyors: {list(factory.conveyors.keys())}")
    print(f"[{factory.env.now:.2f}] 🏪 Warehouses: RawMaterial={factory.raw_material.id if factory.raw_material else None}, Warehouse={factory.warehouse.id if factory.warehouse else None}")
    
    # Test simple simulation for 30 seconds
    factory.run(until=20)


================================================
File: src/simulation/factory_multi.py
================================================
# src/simulation/factory_multi.py
import os
import simpy
from typing import Dict, List, Optional

from src.simulation.line import Line
from src.game_logic.kpi_calculator import KPICalculator
from src.utils.mqtt_client import MQTTClient
from src.simulation.entities.warehouse import Warehouse, RawMaterial
from src.game_logic.order_generator import OrderGenerator
from src.utils.topic_manager import TopicManager

class Factory:
    """
    The main class that orchestrates the entire factory simulation with multiple production lines.
    """
    def __init__(self, layout_config: Dict, mqtt_client: MQTTClient, no_faults: bool = False):
        self.env = simpy.Environment()
        self.layout = layout_config
        self.mqtt_client = mqtt_client
        self.no_faults_mode = no_faults
        
        # Read player name from environment variable
        topic_root =(
            os.getenv("TOPIC_ROOT")
            or os.getenv("USERNAME")
            or os.getenv("USER")
            or "NLDF_TEST"
        )
        self.topic_manager = TopicManager(topic_root)

        self.lines: Dict[str, Line] = {}
        self.raw_material: RawMaterial
        self.warehouse: Warehouse
        self.order_generator: OrderGenerator
        self.kpi_calculator = KPICalculator(self.env, self.mqtt_client, self.topic_manager)

        self.all_devices = {}
        self._create_warehouse_order_generator()
        self._create_production_lines()
        
        # Start process to update active faults count
        self.env.process(self._update_active_faults_count())


    def _create_production_lines(self):
        """Creates all production lines based on the layout configuration."""
        for line_config in self.layout.get('production_lines', []):
            line_name = line_config['name']
            line = Line(
                env=self.env,
                line_name=line_name,
                line_config=line_config,
                mqtt_client=self.mqtt_client,
                topic_manager=self.topic_manager,
                warehouse=self.warehouse,
                raw_material=self.raw_material,
                order_generator=self.order_generator,
                no_faults=self.no_faults_mode,
                kpi_calculator=self.kpi_calculator
            )
            self.lines[line_name] = line
            print(f"[{self.env.now:.2f}] 馃彮 Created Production Line: {line_name}")

    def _create_warehouse_order_generator(self):
        """Creates the warehouse for the factory."""
        for warehouse_cfg in self.layout.get('warehouses', []):
            common_args = {"env": self.env, "mqtt_client": self.mqtt_client, "topic_manager": self.topic_manager, **warehouse_cfg}
            if warehouse_cfg['id'] == 'RawMaterial':
                self.raw_material = RawMaterial(**common_args, kpi_calculator=self.kpi_calculator)
            elif warehouse_cfg['id'] == 'Warehouse':
                self.warehouse = Warehouse(**common_args)

            if self.raw_material:
                og_config = self.layout.get('order_generator', {})
                self.order_generator = OrderGenerator(
                    env=self.env,
                    raw_material=self.raw_material,
                    mqtt_client=self.mqtt_client,
                    topic_manager=self.topic_manager,
                    kpi_calculator=self.kpi_calculator,
                    **og_config
                )

        # Add global devices to all_devices
        if hasattr(self, 'warehouse') and self.warehouse is not None:
            self.all_devices[self.warehouse.id] = self.warehouse
        if hasattr(self, 'raw_material') and self.raw_material is not None:
            self.all_devices[self.raw_material.id] = self.raw_material

    def get_device_status(self, device_id: str) -> Dict:
        """Get comprehensive device status including faults."""
        for line in self.lines.values():
            if device_id in line.all_devices:
                # This part can be enhanced to call a method on the line object
                # which in turn calls the device. For now, direct access for simplicity.
                device = line.all_devices[device_id]
                return device.get_detailed_status() # Simplified for now
        return {}


    def _update_active_faults_count(self):
        """Periodically update the active faults count in KPI calculator."""
        while True:
            # Count total active faults across all lines
            total_active_faults = 0
            for line in self.lines.values():
                if line.fault_system:
                    total_active_faults += len(line.fault_system.active_faults)
            
            # Update KPI calculator with the total count
            if self.kpi_calculator:
                self.kpi_calculator.update_active_faults_count(total_active_faults)
            
            # Wait for 1 second before next update
            yield self.env.timeout(1.0)
    
    def run(self, until: int):
        """Runs the simulation for a given duration."""
        self.env.run(until=until)


================================================
File: src/simulation/line.py
================================================
# src/simulation/line.py
import simpy
from typing import Dict, List, Optional

from src.simulation.entities.conveyor import Conveyor, TripleBufferConveyor, BaseConveyor
from src.simulation.entities.warehouse import Warehouse, RawMaterial
from src.simulation.entities.station import Station
from src.simulation.entities.agv import AGV
from src.simulation.entities.quality_checker import QualityChecker
from src.game_logic.order_generator import OrderGenerator
from src.game_logic.fault_system import FaultSystem
from src.game_logic.kpi_calculator import KPICalculator
from src.utils.mqtt_client import MQTTClient
from src.utils.topic_manager import TopicManager

class Line:
    """
    Represents a single production line within the factory.
    """
    def __init__(self, env: simpy.Environment, line_name: str, line_config: Dict, 
                 mqtt_client: MQTTClient, topic_manager: TopicManager,
                 warehouse: Warehouse, raw_material: RawMaterial, order_generator: OrderGenerator,
                 kpi_calculator: KPICalculator,
                 no_faults: bool = False):
        self.env = env
        self.name = line_name
        self.config = line_config
        self.mqtt_client = mqtt_client
        self.topic_manager = topic_manager
        self.no_faults_mode = no_faults
        self.fault_system: Optional[FaultSystem] = None

        # Shared resources injected from Factory
        self.warehouse = warehouse
        self.raw_material = raw_material
        self.order_generator = order_generator
        self.kpi_calculator = kpi_calculator
        self.stations: Dict[str, Station] = {}
        self.agvs: Dict[str, AGV] = {}
        self.conveyors: Dict[str, BaseConveyor] = {}
        
        self.agv_task_queue = simpy.Store(self.env)
        self.all_devices = {}

        self._create_devices()
        
        self.all_devices.update(self.stations)
        self.all_devices.update(self.agvs)
        self.all_devices.update(self.conveyors)

        # Update all devices with KPI calculator
        self._update_agvs_with_kpi()
        self._update_stations_with_kpi()
        self._setup_event_handlers()

        self._create_game_logic_systems()
        self._bind_conveyors_to_stations()
        self._setup_conveyor_downstreams()

    def _create_devices(self):
        """Instantiates all devices for this line based on its configuration."""
        for station_cfg in self.config.get('stations', []):
            if station_cfg['id'] == 'QualityCheck':
                station = QualityChecker(env=self.env, mqtt_client=self.mqtt_client, topic_manager=self.topic_manager, line_id=self.name, **station_cfg)
            else:
                station = Station(env=self.env, mqtt_client=self.mqtt_client, topic_manager=self.topic_manager, line_id=self.name, **station_cfg)
            self.stations[station.id] = station

        for agv_cfg in self.config.get('agvs', []):
            # Get agv_operations for this specific AGV
            agv_operations = self.config.get('agv_operations', {}).get(agv_cfg['id'], {})
            agv = AGV(env=self.env, mqtt_client=self.mqtt_client, topic_manager=self.topic_manager, 
                     fault_system=self.fault_system, kpi_calculator=self.kpi_calculator,
                     line_id=self.name, agv_operations=agv_operations, **agv_cfg)
            self.agvs[agv.id] = agv

        for conveyor_cfg in self.config.get('conveyors', []):
            conveyor_id = conveyor_cfg['id']
            common_args = {
                "env": self.env, "id": conveyor_id, "position": conveyor_cfg['position'],
                "interacting_points": conveyor_cfg['interacting_points'],
                "transfer_time": conveyor_cfg['transfer_time'], "mqtt_client": self.mqtt_client,
                "topic_manager": self.topic_manager, "line_id": self.name, "kpi_calculator": self.kpi_calculator
            }
            if conveyor_cfg['id'] == 'Conveyor_CQ':
                conveyor = TripleBufferConveyor(**common_args, main_capacity=conveyor_cfg['main_capacity'], upper_capacity=conveyor_cfg['upper_capacity'], lower_capacity=conveyor_cfg['lower_capacity'])
            else: # Assuming 'Conveyor_AB', 'Conveyor_BC' or similar
                conveyor = Conveyor(**common_args, capacity=conveyor_cfg['capacity'])
            self.conveyors[conveyor_id] = conveyor

    def _create_game_logic_systems(self):
        """Creates game logic systems like FaultSystem for this line."""
        if 'fault_system' in self.config and not self.no_faults_mode:
            fs_config = self.config['fault_system']
            self.fault_system = FaultSystem(self.env, self.all_devices, self.mqtt_client, self.topic_manager, self.name, kpi_calculator=self.kpi_calculator, **fs_config)
    
    def _update_agvs_with_kpi(self):
        """Update AGVs with KPI calculator reference."""
        if self.kpi_calculator:
            for agv in self.agvs.values():
                agv.kpi_calculator = self.kpi_calculator
    
    def _update_stations_with_kpi(self):
        """Update stations with KPI calculator reference."""
        if self.kpi_calculator:
            for station in self.stations.values():
                station.kpi_calculator = self.kpi_calculator
    
    def _setup_event_handlers(self):
        """Setup event handlers for order processing and fault handling."""
        # Force initial KPI update
        if self.kpi_calculator:
            self.kpi_calculator.force_kpi_update()

    def _bind_conveyors_to_stations(self):
        """Bind conveyors to stations according to the process flow."""
        if 'StationA' in self.stations and 'Conveyor_AB' in self.conveyors:
            self.stations['StationA'].downstream_conveyor = self.conveyors['Conveyor_AB']
        if 'StationB' in self.stations and 'Conveyor_BC' in self.conveyors:
            self.stations['StationB'].downstream_conveyor = self.conveyors['Conveyor_BC']
        if 'StationC' in self.stations and 'Conveyor_CQ' in self.conveyors:
            self.stations['StationC'].downstream_conveyor = self.conveyors['Conveyor_CQ']

    def _setup_conveyor_downstreams(self):
        """Set downstream stations for conveyors to enable auto-transfer."""
        if 'StationB' in self.stations and 'Conveyor_AB' in self.conveyors:
            self.conveyors['Conveyor_AB'].set_downstream_station(self.stations['StationB'])
        if 'StationC' in self.stations and 'Conveyor_BC' in self.conveyors:
            self.conveyors['Conveyor_BC'].set_downstream_station(self.stations['StationC'])
        if 'QualityCheck' in self.stations and 'Conveyor_CQ' in self.conveyors:
            self.conveyors['Conveyor_CQ'].set_downstream_station(self.stations['QualityCheck'])




================================================
File: src/simulation/entities/agv.py
================================================
# simulation/entities/agv.py
import simpy
import math
from typing import Tuple, Dict, Optional, List
from src.simulation.entities.base import Vehicle, Device
from src.simulation.entities.product import Product
from src.simulation.entities.quality_checker import QualityChecker
from src.simulation.entities.station import Station
from src.simulation.entities.conveyor import Conveyor, TripleBufferConveyor
from src.simulation.entities.warehouse import RawMaterial, Warehouse
from config.schemas import DeviceStatus, AGVStatus
from src.utils.topic_manager import TopicManager
from config.path_timing import get_travel_time, is_path_available
import logging

logger = logging.getLogger(__name__)

class AGV(Vehicle):
    """
    Represents an Automated Guided Vehicle (AGV). Must be initialized with a position in path_points!

    AGVs are responsible for transporting products between stations.
    
    Attributes:
        battery_level (float): The current battery percentage (0-100).
        payload (List[any]): The list of products currently being carried.
        low_battery_threshold (float): when battery level is below this value, AGV will return to charging point automatically
        charging_point (str): Charging point name, must be in path_points
        charging_speed (float): charging speed (%/second)
        battery_consumption_per_meter (float): every meter move consumes this much battery
        battery_consumption_per_action (float): every action consumes this much battery
    """
    
    def __init__(
        self,
        env: simpy.Environment,
        id: str,
        position: Tuple[int, int],
        path_points: Dict[str, Tuple[int, int]],
        speed_mps: float,
        payload_capacity: int = 1,
        operation_time: float = 1.0,
        battery_level: float = 50.0,
        low_battery_threshold: float = 10.0,  # 低电量阈值
        charging_point: str = "P10",  # 充电点坐标(可为路径点名或坐标)
        charging_speed: float = 3.33,  # 充电速度(30秒充满)
        battery_consumption_per_meter: float = 0.1,  # 每米消耗0.1%电量
        battery_consumption_per_action: float = 0.5,  # 每次操作消耗0.5%电量
        fault_system=None, # Injected dependency
        mqtt_client=None,
        kpi_calculator=None,
        topic_manager: Optional[TopicManager] = None,
        line_id: Optional[str] = None,
        agv_operations: Optional[Dict[str, Dict]] = None
    ):
        if position not in path_points.values():
            raise ValueError(f"AGV position {position} not in path_points {path_points}")

        super().__init__(env, id, position, speed_mps, mqtt_client)
        self.topic_manager = topic_manager
        self.line_id = line_id
        self.battery_level = battery_level
        self.payload_capacity = payload_capacity
        self.payload = simpy.Store(env, capacity=payload_capacity)
        self.operation_time = operation_time
        self.fault_system = fault_system
        self.kpi_calculator = kpi_calculator
        self.current_point = list(path_points.keys())[list(path_points.values()).index(position)]
        self.path_points = path_points
        self.agv_operations = agv_operations or {}  # Store AGV-specific operations mapping
        self.target_point = None # current target point if moving
        self.estimated_time = 0.0 # estimated time to complete the task or moving to the target point
        # 充电相关属性
        self.low_battery_threshold = low_battery_threshold
        self.charging_point = charging_point
        self.charging_speed = charging_speed
        self.battery_consumption_per_meter = battery_consumption_per_meter
        self.battery_consumption_per_action = battery_consumption_per_action
        
        self.stats = {
            "total_distance": 0.0,
            "total_charge_time": 0.0,
            "forced_charge_count": 0,  # 被迫充电次数（KPI惩罚）
            "voluntary_charge_count": 0,  # 主动充电次数
            "low_battery_interruptions": 0,  # 低电量中断任务次数
            "tasks_completed": 0,
            "tasks_interrupted": 0
        }

        # Publish initial status upon creation
        self.publish_status("initialized")

    def consume_battery(self, amount: float, reason: str = "operation"):
        """消耗电量"""
        if amount <= 0:
            return
            
        old_level = self.battery_level
        self.battery_level = max(0.0, self.battery_level - amount)
        
        if old_level > self.low_battery_threshold and self.battery_level <= self.low_battery_threshold:
            msg = f"[{self.env.now:.2f}] 🔋 {self.id}: Battery low! Current battery: {self.battery_level:.1f}% (Reason: {reason})"
            # 电量首次降到阈值以下时告警
            self.publish_status(msg)
            print(msg)

    def is_battery_low(self) -> bool:
        """检查电量是否过低"""
        return self.battery_level <= self.low_battery_threshold

    def can_complete_task(self, estimated_travel_time: float = 0.0, estimated_actions: int = 0, target_point: Optional[str] = None) -> bool:
        """预估是否有足够电量完成任务"""
        # Convert travel time to estimated distance for battery calculation
        estimated_distance = estimated_travel_time * self.speed_mps #max is 20s * 2m/s = 40m
        estimated_consumption = (
            estimated_distance * self.battery_consumption_per_meter + # max is 40m * 0.1 = 4
            estimated_actions * self.battery_consumption_per_action
        )
        # 如果目标点就是充电点，不需要预留返回充电点的电量
        if target_point == self.charging_point:
            total_needed = estimated_consumption + 1.0  # 只需要1%安全余量
            return self.battery_level >= total_needed
            
        if target_point:
        # 预留回到充电点的电量 (使用路径时间表)
            return_time = get_travel_time(target_point, self.charging_point) # roughly 13s
        else:
            return_time = get_travel_time(self.current_point, self.charging_point) 
        if return_time < 0:
            # If no direct path to charging point, use fallback calculation
            return_distance = math.dist(self.position, self.path_points[self.charging_point])
            return_consumption = return_distance * self.battery_consumption_per_meter
        else:
            return_distance = return_time * self.speed_mps # roughly 26m
            return_consumption = return_distance * self.battery_consumption_per_meter # roughly 2.6
        
        total_needed = estimated_consumption + return_consumption + 3.0  # 3%安全余量
        return self.battery_level >= total_needed

    def move_to(self, target_point: str):
        """
        Move to a specific path point using AGV's independent path system.
        
        Args:
            target_point: Path point name (e.g., "P1", "P2")
            
        Returns:
            (success, feedback_message)
        """
        # Wrap the core logic in a process to make it interruptible
        self.action = self.env.process(self._move_to_process(target_point))
        try:
            result = yield self.action
            return result if result else (True, f"成功移动到{target_point}")
        except simpy.Interrupt as e:
            msg = f"Movement to {target_point} interrupted: {e.cause}"
            logger.error(f"[{self.env.now:.2f}] ⚠️  {self.id}: {msg}")
            return False, msg
            
    def _move_to_process(self, target_point: str):
        """The actual process logic for move_to, to be wrapped by self.action."""
        try:
            if not self.can_operate():
                msg = f"Can not move. AGV {self.id} is not available."
                logger.error(f"[{self.env.now:.2f}] ⚠️  {self.id}: {msg}")
                return False, msg
                
            if target_point not in self.path_points:
                msg = f"Unknown path point {target_point}"
                logger.error(f"[{self.env.now:.2f}] ❌ {self.id}: {msg}")
                return False, msg
                
            self.target_point = target_point
    
            # use path timing to get travel time
            travel_time = get_travel_time(self.current_point, target_point)
            if travel_time < 0:
                msg = f"Can not find path from {self.current_point} to {target_point}"
                print(f"[{self.env.now:.2f}] ❌ {self.id}: {msg}")
                return False, msg
                
            # check if battery is enough
            # Special case: if target is charging point, only check if we can reach it
            if target_point == self.charging_point:
                distance_to_charging = travel_time * self.speed_mps
                required_battery = distance_to_charging * self.battery_consumption_per_meter + 1.0  # 1% safety margin
                if self.battery_level < required_battery:
                    msg = f"Battery critically low ({self.battery_level:.1f}%), cannot even reach charging point"
                    print(f"[{self.env.now:.2f}] 🚨 {self.id}: {msg}")
                    return False, msg
            elif not self.can_complete_task(travel_time, 1, target_point):
                msg = f"Battery level is too low to move to {target_point}"
                print(f"[{self.env.now:.2f}] 🔋 {self.id}: {msg}")
                self.stats["tasks_interrupted"] += 1
                yield self.env.process(self.emergency_charge())
                return False, f"{msg}, emergency charging"
                
            self.set_status(DeviceStatus.MOVING, f"moving to {target_point} from {self.current_point}, estimated time: {travel_time:.1f}s")
            print(f"[{self.env.now:.2f}] 🚛 {self.id}: move to path point {target_point} {self.path_points[target_point]} (estimated time: {travel_time:.1f}s)")
            
            # wait for move to complete
            self.estimated_time = travel_time
            yield self.env.timeout(travel_time)
            
            # update position and consume battery
            self.position = self.path_points[target_point]
            self.current_point = target_point
            self.target_point = None
            self.estimated_time = 0.0
            
            # calculate battery consumption based on travel time
            distance = travel_time * self.speed_mps
            self.consume_battery(distance * self.battery_consumption_per_meter, f"移动到{target_point}")
            self.consume_battery(self.battery_consumption_per_action, "路径点操作")
            
            # update statistics
            self.stats["total_distance"] += distance
            self.stats["tasks_completed"] += 1
            
            # Report task completion, transport time, and energy cost to KPI calculator
            if self.kpi_calculator:
                self.kpi_calculator.register_agv_task_complete(self.id, self.line_id)
                self.kpi_calculator.update_agv_transport_time(self.id, self.line_id, travel_time)
                # Add energy cost for AGV movement
                self.kpi_calculator.add_energy_cost(f"AGV_{self.id}", self.line_id, travel_time, is_peak_hour=False)
            
            print(f"[{self.env.now:.2f}] ✅ {self.id}: 到达 {target_point}, 电量: {self.battery_level:.1f}%")
            
            # Before setting to IDLE, check for pending faults
            if self._check_and_trigger_pending_fault():
                return True, f"Arrived at {target_point}, but triggered fault"

            self.set_status(DeviceStatus.IDLE, f"arrived at {target_point}")
            return True, f"Successfully arrived at path point {target_point}, remaining battery: {self.battery_level:.1f}%"
        
        finally:
            self.action = None
    
    def get_point_operations(self, point: str) -> Optional[Dict]:
        """Get the allowed operations and device info for a specific path point."""
        ops = self.agv_operations.get(point)
        if not self.agv_operations:
            print(f"DEBUG: {self.id} has no agv_operations configured")
        elif point not in self.agv_operations:
            print(f"DEBUG: {self.id} has no operations defined for point {point}")
            print(f"DEBUG: Available points: {list(self.agv_operations.keys())}")
        return ops
    
    def load_from(self, device:Device, buffer_type=None, product_id: Optional[str] = None):
        """AGV从指定设备/缓冲区取货，支持多种设备类型和buffer_type。返回(成功,反馈信息,产品对象)
        
        注意：product_id 参数在warehouse以外设备已废弃，只能取第一个产品（FIFO）
        """
        if not self.can_operate() or self.is_payload_full():
            msg = f"Can not load. AGV {self.id} is not available or payload is full."
            logger.error(f"[{self.env.now:.2f}] ⚠️  {self.id}: {msg}")
            return False, msg, None
        
        # check battery level
        if self.is_battery_low():
            return False, f"{self.id} battery level is too low ({self.battery_level:.1f}%), can not load", None
            
        product = None
        feedback = ""
        success = False
        
        try:
            # QualityChecker (先检查子类)
            if isinstance(device, QualityChecker):
                # 根据buffer_type选择合适的buffer
                if buffer_type == "buffer":
                    target_buffer = device.buffer
                    buffer_name = "buffer"
                elif buffer_type == "output_buffer" or buffer_type is None:
                    # QualityChecker默认从output_buffer取货
                    target_buffer = device.output_buffer
                    buffer_name = "output_buffer"
                else:
                    feedback = f"QualityChecker不支持的buffer类型: {buffer_type}"
                    return False, feedback, None
                
                if len(target_buffer.items) == 0:
                    feedback = f"{device.id} {buffer_name}为空，无法取货"
                    return False, feedback, None
                    
                # 统一使用 pop() 方法，只能取第一个产品
                product = yield self.env.process(device.pop(buffer_type))
                success = True
                
            elif isinstance(device, RawMaterial):
                if len(device.buffer.items) == 0:
                    feedback = f"{device.id} buffer为空，无法取货"
                    return False, feedback, None
                try:
                    print(f"TEST: agv load from raw material with product_id {product_id}")
                    product = yield self.env.process(device.pop(product_id))
                    success = True
                except ValueError as e:
                    # 处理正在加工中的产品不能取的情况
                    feedback = str(e)
                    return False, feedback, None
            # Station (父类)
            elif isinstance(device, Station):
                if len(device.buffer.items) == 0:
                    feedback = f"{device.id} buffer为空，无法取货"
                    return False, feedback, None

                # 统一使用 pop() 方法，只能取第一个产品
                try:
                    product = yield self.env.process(device.pop())
                    success = True
                except ValueError as e:
                    # 处理正在加工中的产品不能取的情况
                    feedback = str(e)
                    return False, feedback, None
                
            # TripleBufferConveyor
            elif isinstance(device, TripleBufferConveyor):
                buffer_name = buffer_type if buffer_type else "main"
                if device.is_empty(buffer_name):
                    feedback = f"{device.id} {buffer_name}缓冲区为空，无法取货"
                    return False, feedback, None
                # 统一使用 pop() 方法，只能取第一个产品
                product = yield self.env.process(device.pop(buffer_name))
                success = True
                
            # Conveyor
            elif isinstance(device, Conveyor):
                if device.is_empty():
                    feedback = f"{device.id}缓冲区为空，无法取货"
                    return False, feedback, None

                # 统一使用 pop() 方法，只能取第一个产品
                product = yield self.env.process(device.pop())
                success = True
                
            else:
                feedback = f"不支持的设备类型: {type(device).__name__}"
                logger.error(feedback)
                return False, feedback, None
                
            # 成功取货后的操作
            if success and product:
                buffer_desc = f" {buffer_type}" if buffer_type else ""
                product.add_history(self.env.now, f"Loaded onto {self.id} from {device.id}")
                
                self.set_status(DeviceStatus.INTERACTING, f"loading from {device.id}{buffer_desc}")
                yield self.env.timeout(self.operation_time)
                yield self.payload.put(product)
                self.consume_battery(self.battery_consumption_per_action, "取货操作")
                feedback = f"已从{device.id}{buffer_desc}取出产品{product.id}并装载到AGV，剩余电量: {self.battery_level:.1f}%"
                
        except Exception as e:
            feedback = f"取货异常: {str(e)}"
            success = False
        
        finally:
            self.set_status(DeviceStatus.IDLE)

        return success, feedback, product

    def unload_to(self, device, buffer_type=None):
        """AGV将产品卸载到指定设备/缓冲区，支持多种设备类型和buffer_type。返回(成功,反馈信息,产品对象)"""
        # check if agv can operate
        if not self.can_operate():
                msg = f"Can not unload. AGV {self.id} is not available."
                logger.error(f"[{self.env.now:.2f}] ⚠️  {self.id}: {msg}")
                return False, msg, None
        
        if device.is_full():
            msg = f"Can not unload. {device.id} is full."
            logger.error(f"[{self.env.now:.2f}] ⚠️  {self.id}: {msg}")
            return False, msg, None

        
        # Validate operation against AGV operations mapping
        point_ops = self.get_point_operations(self.current_point)
        if point_ops:
            # Check if device matches
            if point_ops.get('device') != device.id:
                msg = f"[{self.env.now:.2f}] ❌ {self.id}: Cannot unload to {device.id} at {self.current_point}. Expected device: {point_ops.get('device')}"
                logger.error(msg)
                return False, msg, None
            # Check if unload operation is allowed
            if 'unload' not in point_ops.get('operations', []):
                msg = f"[{self.env.now:.2f}] ❌ {self.id}: Unload operation not allowed at {self.current_point}"
                logger.error(msg)
                return False, msg, None
            # Use buffer from mapping if not specified
            if buffer_type is None and 'buffer' in point_ops:
                buffer_type = point_ops['buffer']

        # 检查电量
        if self.is_battery_low():
            return False, f"{self.id}电量过低({self.battery_level:.1f}%)，无法执行卸载操作", None
            
        product = None
        feedback = ""
        success = False
        
        try:
            # Check if AGV has products
            if len(self.payload.items) == 0:
                return False, "AGV货物为空，无法卸载", None
            
            self.set_status(DeviceStatus.INTERACTING, f"unloading to {device.id}")
            
            # Get product from AGV
            product = yield self.payload.get()
            
            # 检查产品移动是否符合工艺路线
            if hasattr(product, 'next_move_checker') and hasattr(product, 'update_location'):
                # 检查移动是否合法
                can_move, move_reason = product.next_move_checker(self.env.now, device.id)
                if not can_move:
                    feedback = f"产品移动违反工艺路线: {move_reason}"
                    yield self.payload.put(product)  # 放回产品
                    return False, feedback, product
            
            # Try to unload to device
            # QualityChecker (Check subclass first)
            if isinstance(device, QualityChecker):
                if buffer_type == "output_buffer":
                    # Default use output_buffer
                    success = yield self.env.process(device.add_product_to_outputbuffer(product))
                else:
                    success = yield self.env.process(device.add_product_to_buffer(product))
                        
            # Station (父类)
            elif isinstance(device, Station) or isinstance(device, Warehouse):
                success = yield self.env.process(device.add_product_to_buffer(product))
                    
            # TripleBufferConveyor (先检查子类)
            elif isinstance(device, TripleBufferConveyor):
                buffer_type = buffer_type if buffer_type else "main"
                # SimPy push()会自动阻塞直到有空间，无需手动检查is_full
                yield device.push(product, buffer_type)
                success = True
                
            # Conveyor (父类)
            elif isinstance(device, Conveyor):
                # SimPy push()会自动阻塞直到有空间，无需手动检查is_full
                yield device.push(product)
                success = True
                
            else:
                feedback = f"不支持的设备类型: {type(device).__name__}"
            
            # 统一处理结果
            if success:
                # 更新产品位置
                if hasattr(product, 'update_location'):
                    location_updated = product.update_location(device.id, self.env.now)
                    if not location_updated:
                        print(f"[{self.env.now:.2f}] ⚠️  {self.id}: 产品位置更新失败，但卸载成功")
                
                yield self.env.timeout(self.operation_time)
                self.consume_battery(self.battery_consumption_per_action, "卸载操作")
                buffer_desc = f" {buffer_type}" if buffer_type else ""
                feedback = f"已将产品{product.id}卸载到{device.id}{buffer_desc}，剩余电量: {self.battery_level:.1f}%"
            else:
                # 失败时放回产品
                yield self.payload.put(product)
                
        except Exception as e:
            feedback = f"卸载异常: {str(e)}"
            # 异常时尝试放回产品
            if product and len(self.payload.items) < self.payload_capacity:
                yield self.payload.put(product)
            success = False
            
        finally:
            self.set_status(DeviceStatus.IDLE)
            
        return success, feedback, product

    def charge_battery(self, target_level: float = 100.0, message: Optional[str] = None, is_emergency: bool = False):
        """Charge battery to target level. Returns (success, feedback_message)"""
        if self.status == DeviceStatus.CHARGING:
            msg = f"already charging"
            print(f"[{self.env.now:.2f}] 🔋 {self.id}: {msg}")
            return True, msg
            
        if self.battery_level >= target_level:
            msg = f"battery level is enough ({self.battery_level:.1f}%)"
            print(f"[{self.env.now:.2f}] 🔋 {self.id}: {msg}")
            return True, msg
            
        # move to charging point
        if self.current_point != self.charging_point:
            # Note: move_to already records transport time to KPI
            yield self.env.process(self.move_to(self.charging_point))
            
        # start charging
        self.set_status(DeviceStatus.CHARGING, message)
        
        charge_needed = target_level - self.battery_level
        charge_time = charge_needed / self.charging_speed
        
        print(f"[{self.env.now:.2f}] 🔋 {self.id}: start charging ({self.battery_level:.1f}% → {target_level:.1f}%, estimated {charge_time:.1f}s)")
        
        yield self.env.timeout(charge_time)
        
        # charging completed
        self.battery_level = target_level
        
        # update statistics
        self.stats["total_charge_time"] += charge_time
        
        # Report charge event with duration to KPI calculator
        if self.kpi_calculator and hasattr(self, '_charge_start_time'):
            actual_charge_duration = self.env.now - self._charge_start_time
            is_active = getattr(self, '_is_active_charge', False)
            self.kpi_calculator.register_agv_charge(self.id, self.line_id, is_active, actual_charge_duration)
            # Add energy cost for charging (charging typically uses more power)
            self.kpi_calculator.add_energy_cost(f"AGV_{self.id}_charging", self.line_id, charge_time, is_peak_hour=False)
            # Clean up temporary attributes
            if hasattr(self, '_charge_start_time'):
                del self._charge_start_time
            if hasattr(self, '_is_active_charge'):
                del self._is_active_charge
        
        print(f"[{self.env.now:.2f}] ✅ {self.id}: 充电完成，当前电量: {self.battery_level:.1f}%")

        # Before setting to IDLE, check for pending faults
        if self._check_and_trigger_pending_fault():
            return True, f"充电完成到 {target_level:.1f}%，但触发了故障"

        self.set_status(DeviceStatus.IDLE, f"charged to {target_level:.1f}%")
        return True, f"充电完成，当前电量: {self.battery_level:.1f}%"

    def emergency_charge(self):
        """Emergency charging when battery is critically low."""
        print(f"[{self.env.now:.2f}] 🚨 {self.id}: emergency charging started")
        self.stats["forced_charge_count"] += 1
        self.stats["low_battery_interruptions"] += 1
        
        # Report to KPI calculator
        if self.kpi_calculator:
            # Note: charge_duration will be calculated and reported after charging completes
            self._charge_start_time = self.env.now
        
        # charge to safe level
        yield self.env.process(self.charge_battery(50.0, "emergency charging to 50%", is_emergency=True))

    def voluntary_charge(self, target_level: float = 80.0):
        """Voluntary charging to maintain good battery level. Returns (success, feedback_message)"""
        target_level = float(target_level)
        print(f"[{self.env.now:.2f}] 🔋 {self.id}: voluntary charging")
        self.stats["voluntary_charge_count"] += 1
        
        # Report to KPI calculator
        if self.kpi_calculator:
            # Note: charge_duration will be calculated and reported after charging completes
            self._charge_start_time = self.env.now
            self._is_active_charge = True
        
        self.action = self.env.process(self.charge_battery(target_level, f"voluntary charging to {target_level:.1f}%"))
        try:
            result = yield self.action
            return result if result else (True, f"充电完成到 {target_level:.1f}%")
        except simpy.Interrupt as e:
            msg = f"Charging interrupted: {e.cause}"
            print(f"[{self.env.now:.2f}] ⚠️  {self.id}: {msg}")
            return False, msg
        finally:
            self.action = None

    def auto_charge_if_needed(self):
        """auto check and charge if needed (background process)"""
        while True:
            # check every 5 seconds
            yield self.env.timeout(5.0)
            
            # if battery is low and not charging, start emergency charging
            if self.is_battery_low() and self.status != DeviceStatus.CHARGING:
                print(f"[{self.env.now:.2f}] 🔋 {self.id}: battery is low, start emergency charging")
                yield self.env.process(self.emergency_charge())

    def get_battery_status(self) -> dict:
        """获取电池状态信息"""
        return {
            "battery_level": self.battery_level,
            "is_charging": self.status == DeviceStatus.CHARGING,
            "is_low_battery": self.is_battery_low(),
            "charging_point": self.charging_point,
            "can_operate": not self.is_battery_low(),
            "stats": self.stats.copy()
        }

    def get_charging_stats(self) -> dict:
        """获取充电相关统计数据（用于KPI计算）"""
        return {
            "total_charge_time": self.stats["total_charge_time"],
            "forced_charge_count": self.stats["forced_charge_count"],
            "voluntary_charge_count": self.stats["voluntary_charge_count"],
            "low_battery_interruptions": self.stats["low_battery_interruptions"],
            "tasks_completed": self.stats["tasks_completed"],
            "tasks_interrupted": self.stats["tasks_interrupted"],
            "charge_efficiency": (
                self.stats["voluntary_charge_count"] / 
                max(1, self.stats["forced_charge_count"] + self.stats["voluntary_charge_count"])
            ) * 100  # 主动充电比例
        }

    def get_current_payload(self) -> List[Product]:
        """获取当前载货列表"""
        return list(self.payload.items)

    def is_payload_full(self) -> bool:
        """检查载货是否已满"""
        return len(self.payload.items) >= self.payload_capacity

    def is_payload_empty(self) -> bool:
        """检查载货是否为空"""
        return len(self.payload.items) == 0

    def get_available_path_points(self) -> List[str]:
        """获取可用的路径点列表"""
        return list(self.path_points.keys())

    def get_path_point_position(self, point_name: str) -> Optional[Tuple[int, int]]:
        """获取路径点的坐标"""
        return self.path_points.get(point_name)

    def _check_and_trigger_pending_fault(self) -> bool:
        """
        Checks if a fault is pending for this AGV and triggers it.
        This is called internally just before the AGV becomes IDLE.
        Returns True if a fault was triggered, False otherwise.
        """
        if self.fault_system and self.id in self.fault_system.pending_agv_faults:
            fault_type = self.fault_system.pending_agv_faults.pop(self.id)
            print(f"[{self.env.now:.2f}] 💥 AGV {self.id} is idle, triggering pending fault: {fault_type.value}")
            self.fault_system._inject_fault_now(self.id, fault_type)
            return True
        return False

    def __repr__(self) -> str:
        return f"AGV(id='{self.id}', battery={self.battery_level:.1f}%, payload={len(self.payload.items)}/{self.payload_capacity})"

    def set_status(self, new_status: DeviceStatus, message: Optional[str] = None):
        """Overrides the base method to publish status on change."""
        if self.status == new_status:
            return  # Avoid redundant publications
        
        # Track fault time for KPI
        if self.kpi_calculator:
            # If transitioning to FAULT status, record the start time
            if new_status == DeviceStatus.FAULT and self.status != DeviceStatus.FAULT:
                self._fault_start_time = self.env.now
            # If transitioning from FAULT to any other status, record the fault duration
            elif self.status == DeviceStatus.FAULT and new_status != DeviceStatus.FAULT:
                if hasattr(self, '_fault_start_time'):
                    fault_duration = self.env.now - self._fault_start_time
                    self.kpi_calculator.update_agv_fault_time(self.id, self.line_id, fault_duration)
                    del self._fault_start_time
        
        super().set_status(new_status)
        self.publish_status(message)


    def publish_status(self, message: Optional[str] = None):
        """Publishes the current AGV status to the MQTT broker."""
        if not self.mqtt_client:
            return

        status_payload = AGVStatus(
            timestamp=self.env.now,
            source_id=self.id,
            status=self.status,
            speed_mps=self.speed_mps,
            current_point=self.current_point,
            target_point=self.target_point,
            estimated_time=self.estimated_time,
            position={'x': self.position[0], 'y': self.position[1]},
            payload=[p.id for p in self.payload.items] if self.payload else [],
            battery_level=self.battery_level,
            message=message
        )
        if self.topic_manager and self.line_id:
            topic = self.topic_manager.get_agv_status_topic(self.line_id, self.id)
        else:
            from config.topics import get_agv_status_topic
            topic = get_agv_status_topic(self.id)
        self.mqtt_client.publish(topic, status_payload.model_dump_json(), retain=False)


================================================
File: src/simulation/entities/base.py
================================================
# simulation/entities/base.py
import simpy
import random
from abc import ABC, abstractmethod
from enum import Enum
from typing import Tuple, Optional
from dataclasses import dataclass

from config.schemas import DeviceStatus, DeviceDetailedStatus
from src.utils.topic_manager import TopicManager
from config.topics import DEVICE_ALERT_TOPIC

class Device:
    """
    Base class for all simulated devices in the factory.
    Simplified for a basic fault model.
    """
    def __init__(self, env: simpy.Environment, id: str, position: Tuple[int, int], device_type: str = "generic", mqtt_client=None, interacting_points: list = [], topic_manager: Optional[TopicManager] = None, line_id: Optional[str] = None):
        if not isinstance(env, simpy.Environment):
            raise ValueError("env must be a valid simpy.Environment object.")
        
        self.env = env
        self.id = id
        self.device_type = device_type
        self.position = position
        self.mqtt_client = mqtt_client
        self.interacting_points = interacting_points if interacting_points is not None else []
        self.topic_manager = topic_manager
        self.line_id = line_id
        
        # 设备状态和故障相关属性
        self.status = DeviceStatus.IDLE
        self.fault_symptom = None
        self.action: Optional[simpy.Process] = None # Stores the current action process
        
        # 性能指标
        self.performance_metrics = type('PerformanceMetrics', (), {
            'efficiency_rate': 100.0,
            'error_rate': 0.0,
            'uptime': 100.0
        })()
        
        # 设备特定属性（可被子类扩展）
        self._specific_attributes = {
            'temperature': random.uniform(20.0, 25.0),
            'vibration_level': random.uniform(0.0, 5.0),
            'power_consumption': random.uniform(80.0, 120.0)
        }

    def set_status(self, new_status: DeviceStatus, message: Optional[str] = None):
        """设置设备状态"""
        if self.status != new_status:
            old_status = self.status
            self.status = new_status
            log_message = f"[{self.env.now:.2f}] 🔄 {self.id}: 状态变更 {old_status.value} → {new_status.value}"
            if message:
                log_message += f" ({message})"
            print(log_message)

    def can_operate(self) -> bool:
        """检查设备是否可以操作"""
        # 检查冻结状态
        return self.status not in [DeviceStatus.FAULT, DeviceStatus.MAINTENANCE, DeviceStatus.BLOCKED]

    def get_detailed_status(self) -> DeviceDetailedStatus:
        """获取设备详细状态"""
        return DeviceDetailedStatus(
            device_id=self.id,
            device_type=self.device_type,
            current_status=self.status,
            temperature=self._specific_attributes.get('temperature', 25.0),
            vibration_level=self._specific_attributes.get('vibration_level', 0.0),
            power_consumption=self._specific_attributes.get('power_consumption', 100.0),
            efficiency_rate=getattr(self.performance_metrics, 'efficiency_rate', 100.0),
            cycle_count=0,  # 简化实现
            last_maintenance_time=0.0,  # 简化实现
            operating_hours=self.env.now / 3600.0,  # 转换为小时
            fault_symptom=self.fault_symptom,
            frozen_until=None,  # 简化故障系统不使用冻结机制
            precision_level=self._specific_attributes.get('precision_level', 100.0),
            tool_wear_level=self._specific_attributes.get('tool_wear_level', 0.0),
            lubricant_level=self._specific_attributes.get('lubricant_level', 100.0),
            battery_level=self._specific_attributes.get('battery_level', 100.0),
            position_accuracy=self._specific_attributes.get('position_accuracy', 100.0),
            load_weight=self._specific_attributes.get('load_weight', 0.0)
        )
    
    def _get_fault_topic(self) -> str:
        """Generates the correct fault topic based on context."""
        if self.topic_manager and self.line_id:
            return self.topic_manager.get_fault_alert_topic(self.line_id)
        else:
            return DEVICE_ALERT_TOPIC

    def report_buffer_full(self, buffer_name: str):
        """报告缓冲区满"""
        topic = self._get_fault_topic()
        payload = {
            "event_type": "buffer_full",
            "data": {
                "device_id": self.id,
                "buffer_name": buffer_name,
                "timestamp": self.env.now,
                "severity": "warning"
            }
        }
        self._publish_fault_event(topic, payload)
        print(f"[{self.env.now:.2f}] 📦 {self.id}: 缓冲区满告警 ({buffer_name})")

    def _publish_fault_event(self, topic: str, payload: dict):
        """发布故障事件到MQTT"""
        if self.mqtt_client:
            self.mqtt_client.publish(topic, payload)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(id='{self.id}', status='{self.status.value}')"

    def recover(self):
        """Default recovery logic."""
        # 只有当设备处于FAULT状态时才恢复
        # 避免覆盖其他合法状态（如BLOCKED）
        if self.status == DeviceStatus.FAULT:
            self.set_status(DeviceStatus.IDLE)

class Vehicle(Device):
    """
    Base class for mobile entities like AGVs.
    """
    def __init__(self, env: simpy.Environment, id: str, position: Tuple[int, int], speed_mps: float, mqtt_client=None):
        super().__init__(env, id, position, "vehicle", mqtt_client)
        self.speed_mps = speed_mps

class BaseConveyor(Device, ABC):
    """
    Abstract base class for different types of conveyors.
    """
    def __init__(self, env: simpy.Environment, id: str, position: Tuple[int, int], transfer_time: float, line_id: Optional[str] = None, interacting_points: list = [], topic_manager: Optional[TopicManager] = None, mqtt_client=None):
        super().__init__(env, id, position, "conveyor", mqtt_client, interacting_points)

    @abstractmethod
    def push(self, product):
        """Add a product to the conveyor."""
        pass

    @abstractmethod
    def pop(self):
        """Remove a product from the conveyor."""
        pass

    @abstractmethod
    def is_full(self):
        """Check if the conveyor is full."""
        pass

    @abstractmethod
    def is_empty(self):
        """Check if the conveyor is empty."""
        pass

    @abstractmethod
    def get_buffer(self):
        """Get the internal buffer of the conveyor."""
        pass

    @abstractmethod
    def set_downstream_station(self, station):
        """Set the station that receives products from this conveyor."""
        pass


================================================
File: src/simulation/entities/conveyor.py
================================================
# simulation/entities/conveyor.py
import simpy
from typing import Optional
from src.simulation.entities.base import BaseConveyor
from src.simulation.entities.product import Product
from typing import Tuple
from src.utils.topic_manager import TopicManager
from config.schemas import DeviceStatus, ConveyorStatus
from config.topics import get_conveyor_status_topic

class Conveyor(BaseConveyor):
    """
    Conveyor with limited capacity, simulating a production line conveyor belt.
    Now uses simpy.Store for event-driven simulation and supports auto-transfer.
    """
    def __init__(self, env, id, capacity, position: Tuple[int, int], interacting_points: list, transfer_time: float =5.0, mqtt_client=None, kpi_calculator=None, topic_manager: Optional[TopicManager] = None, line_id: Optional[str] = None):
        super().__init__(env, id, position, transfer_time, line_id, interacting_points, topic_manager, mqtt_client)
        self.capacity = capacity
        self.buffer = simpy.Store(env, capacity=capacity)
        self.downstream_station = None  # 下游工站引用
        self.action = None  # 保留但不使用，兼容 fault system 接口
        self.transfer_time = transfer_time # 模拟搬运时间
        self.topic_manager = topic_manager
        self.line_id = line_id
        self.main_process = None  # 主运行进程
        self.active_processes = {}  # Track active transfer processes per product
        self.product_start_times = {}  # Track when each product started transfer
        self.product_elapsed_times = {}  # Track elapsed time before interruption
        
        # 阻塞管理
        self.blocked_leader_process = None  # 正在等待下游的领头产品进程
        self.kpi_calculator = kpi_calculator  # KPI calculator dependency
        
        # 传送带默认状态为工作中
        self.status = DeviceStatus.WORKING
        self.publish_status("Conveyor initialized")
               # Initialize device utilization tracking
        if self.kpi_calculator:
            self.kpi_calculator.update_device_utilization(self.id, self.line_id, 0.0)
        
        # Start background process to update total time for utilization calculation
        self.env.process(self._update_total_time())

    def publish_status(self, message: Optional[str] = None):
        """直接发布传送带状态，不通过set_status"""
        if not self.mqtt_client or not self.mqtt_client.is_connected():
            return

        status_data = ConveyorStatus(
            timestamp=self.env.now,
            source_id=self.id,
            status=self.status,
            buffer=[p.id for p in self.buffer.items],
            message=message,
            upper_buffer=None,
            lower_buffer=None
        )
        if self.topic_manager and self.line_id:
            topic = self.topic_manager.get_conveyor_status_topic(self.line_id, self.id)
        else:
            topic = get_conveyor_status_topic(self.id)
        self.mqtt_client.publish(topic, status_data.model_dump_json(), retain=False)

    def set_downstream_station(self, station):
        """Set the downstream station for auto-transfer."""
        self.downstream_station = station
        if self.main_process is None:
            self.main_process = self.env.process(self.run())

    def push(self, product):
        """Put a product on the conveyor (may block if full)."""
        result = self.buffer.put(product)
        print(f"[{self.env.now:.2f}] [DEBUG] Conveyor {self.id}: push {product.id}, buffer={len(self.buffer.items)}/{self.capacity}")
        # 产品添加后发布状态
        self.publish_status()
        return result

    def pop(self):
        """Remove and return a product from the conveyor (may block if empty)."""
        product = yield self.buffer.get()
        print(f"[{self.env.now:.2f}] [DEBUG] Conveyor {self.id}: pop {product.id}, buffer={len(self.buffer.items)}/{self.capacity}")
        
        # 如果该产品有对应的处理进程，中断并删除它
        if product.id in self.active_processes:
            process = self.active_processes[product.id]
            if process.is_alive:
                process.interrupt("Product removed by AGV")
                print(f"[{self.env.now:.2f}] 🚫 Conveyor {self.id}: Interrupted process for product {product.id} (taken by AGV)")
            del self.active_processes[product.id]
            
            # 清理该产品的时间记录
            if product.id in self.product_start_times:
                del self.product_start_times[product.id]
            if product.id in self.product_elapsed_times:
                del self.product_elapsed_times[product.id]
        
        # 产品移除后发布状态
        self.publish_status()
        return product

    def get_buffer(self):
        return self.buffer

    def is_full(self):
        return len(self.buffer.items) >= self.capacity

    def is_empty(self):
        return len(self.buffer.items) == 0

    def peek(self):
        if self.buffer.items:
            return self.buffer.items[0]
        return None
    
    def _update_total_time(self):
        """Background process to update total time for KPI utilization calculation"""
        while True:
            yield self.env.timeout(10.0)  # Update every 10 seconds
            if self.kpi_calculator:
                self.kpi_calculator.update_device_utilization(self.id, self.line_id, self.env.now)

    def run(self):
        """Main operational loop for the conveyor. This should NOT be interrupted by faults."""
        while True:
            # 等待设备可操作且buffer有产品
            yield self.env.process(self._wait_for_ready_state())
            
            # 检查是否应该解除阻塞状态
            if self.status == DeviceStatus.BLOCKED:
                # 如果下游工站恢复正常或者没有正在等待的领头进程，解除阻塞
                if self.downstream_station and self.downstream_station.can_operate():
                    if self.blocked_leader_process is None or not self.blocked_leader_process.is_alive:
                        print(f"[{self.env.now:.2f}] 🔓 Conveyor {self.id}: Downstream recovered or no leader waiting, unblocking")
                        self._unblock_all_products()
            
            # 检查buffer中的每个产品，如果还没有处理进程就启动一个
            for item in list(self.buffer.items):  # 使用list避免迭代时修改
                if item.id not in self.active_processes:
                    # 只有在非阻塞状态下才为新产品启动处理进程
                    if self.status != DeviceStatus.BLOCKED:
                        # 为这个产品启动一个处理进程
                        process = self.env.process(self.process_single_item(item))
                        self.active_processes[item.id] = process
                    else:
                        # 如果是阻塞状态，检查这个产品是否是第一个（领头产品）
                        if len(self.buffer.items) > 0 and self.buffer.items[0].id == item.id:
                            # 这是领头产品，允许启动进程
                            process = self.env.process(self.process_single_item(item))
                            self.active_processes[item.id] = process
                            print(f"[{self.env.now:.2f}] 👑 Conveyor {self.id}: Starting process for leader product {item.id} despite blocked status")
            
            # 清理已完成的进程
            completed_ids = []
            for product_id, process in self.active_processes.items():
                if not process.is_alive:
                    completed_ids.append(product_id)
            for product_id in completed_ids:
                del self.active_processes[product_id]
            
            yield self.env.timeout(0.1)

    def _wait_for_ready_state(self):
        """等待设备处于可操作状态且buffer有产品"""
        while True:
            # 如果没有下游站点，等待
            if self.downstream_station is None:
                yield self.env.timeout(1)
                continue
            
            # 如果buffer为空，等待
            if len(self.buffer.items) == 0 or not self.can_operate():
                yield self.env.timeout(0.1)
                continue

            # 设备可操作且有产品，返回
            return
        
    def process_single_item(self, product):
        """Process a single item with timeout-get-put pattern. This CAN be interrupted by faults."""
        actual_product = None
        try:
            # 检查下游站点是否存在
            if self.downstream_station is None:
                return
            
            # 如果当前是blocked状态且不是领头产品，不应该继续
            if self.status == DeviceStatus.BLOCKED:
                is_leader = len(self.buffer.items) > 0 and self.buffer.items[0].id == product.id
                if not is_leader:
                    print(f"[{self.env.now:.2f}] 🚫 Conveyor {self.id}: Product {product.id} blocked at start, not leader")
                    return
            
            self.set_status(DeviceStatus.WORKING)
            self.publish_status()
            
            print(f"[{self.env.now:.2f}] 📋 Conveyor {self.id}: Added {product.id} to processing order, current order: {[p.id for p in self.buffer.items]}")
            
            # 计算剩余传输时间（处理中断后恢复的情况）
            if product.id in self.product_elapsed_times:
                # 恢复传输：使用之前记录的已传输时间
                elapsed_time = self.product_elapsed_times[product.id]
                remaining_time = max(0, self.transfer_time - elapsed_time)
                msg = f"[{self.env.now:.2f}] Conveyor {self.id}: {product.id} resume transferring, elapsed {elapsed_time:.1f}s, remaining {remaining_time:.1f}s"
            else:
                # 第一次开始传输
                remaining_time = self.transfer_time
                msg = f"[{self.env.now:.2f}] Conveyor {self.id}: {product.id} start transferring, need {remaining_time:.1f}s"
            
            self.product_start_times[product.id] = self.env.now
            print(msg)
            self.publish_status(msg)     

            # Track start of working time for KPI
            working_start_time = self.env.now
            yield self.env.timeout(remaining_time)
            is_first_product = self.buffer.items[0].id == product.id
            # Report energy cost and working time for this transfer
            if self.kpi_calculator:
                self.kpi_calculator.add_energy_cost(self.id, self.line_id, remaining_time, is_peak_hour=False)
                # Working time is already tracked in add_energy_cost
            
            # 传输完成，从buffer获取产品（get）
            actual_product = yield self.buffer.get()

            # 确保获取的是正确的产品
            if actual_product.id != product.id:
                # 如果不是预期的产品，放回去
                yield self.buffer.put(actual_product)
                msg = f"[{self.env.now:.2f}] Conveyor {self.id}: unexpected product order, retrying"
                print(msg)
                self.publish_status(msg)
                return
            
            self.publish_status()
            
            # 使用处理顺序信息
            if is_first_product:
                # 这是最前面的产品，设为领头进程
                self.blocked_leader_process = self.env.active_process
                print(f"[{self.env.now:.2f}] 🎯 Conveyor {self.id}: {actual_product.id} is the leader product (first in order)")
                
                downstream_full = self.downstream_station.is_full()
                print(f"[{self.env.now:.2f}] 🔍 Conveyor {self.id}: Downstream buffer {len(self.downstream_station.buffer.items)}/{self.downstream_station.buffer.capacity}, full={downstream_full}, can opeatate:{self.downstream_station.can_operate()}")
                    
                if (downstream_full or not self.downstream_station.can_operate()) and self.status != DeviceStatus.BLOCKED:
                    # 下游已满或下游工站不可操作，阻塞其他产品
                    self._block_all_products()
                    
                while not self.downstream_station.can_operate():
                    yield self.env.timeout(0.1)
                # 尝试放入下游（可能会阻塞）
                print(f"[{self.env.now:.2f}] ⏳ Conveyor {self.id}: Leader {actual_product.id} trying to put to downstream...")
                yield self.downstream_station.buffer.put(actual_product)
                
                # 成功放入，如果之前是阻塞状态，现在解除
                if self.status == DeviceStatus.BLOCKED and self.downstream_station.can_operate():
                    self._unblock_all_products()
                    
            else:
                # 不是第一个产品
                print(f"[{self.env.now:.2f}] 📦 Conveyor {self.id}: {actual_product.id} is NOT the leader product (order: {[p.id for p in self.buffer.items]})")
                
                # 非领头产品需要等待，直到轮到它或者传送带解除阻塞
                while self.status == DeviceStatus.BLOCKED:
                    print(f"[{self.env.now:.2f}] ⏳ Conveyor {self.id}: {actual_product.id} waiting for its turn or unblock...")
                    yield self.env.timeout(0.1)
                
                # 现在可以尝试放入下游
                yield self.downstream_station.buffer.put(actual_product)
            
            actual_product.update_location(self.downstream_station.id, self.env.now)
            msg = f"[{self.env.now:.2f}] Conveyor {self.id}: moved product {actual_product.id} to {self.downstream_station.id}"
            print(msg)
            self.publish_status(msg)
            
            # 清理传输时间记录
            if actual_product.id in self.product_start_times:
                del self.product_start_times[actual_product.id]
            if actual_product.id in self.product_elapsed_times:
                del self.product_elapsed_times[actual_product.id]
                
        except simpy.Interrupt as e:
            print(f"[{self.env.now:.2f}] 🚫 Conveyor {self.id}: Interrupted by{e}: {e.cause}")
            interrupt_reason = str(e.cause) if hasattr(e, 'cause') else "Unknown"
            
            # 如果是AGV取走产品的中断，直接返回
            if "Product removed by AGV" in interrupt_reason:
                print(f"[{self.env.now:.2f}] 🚚 Conveyor {self.id}: Product {product.id} was taken by AGV, stopping process")
                # 时间记录已经在pop()中清理了，这里不需要再清理
                return
            
            # 记录中断时已经传输的时间（阻塞和故障都需要）
            if product.id in self.product_start_times:
                start_time = self.product_start_times[product.id]
                elapsed_before_interrupt = self.env.now - start_time
                self.product_elapsed_times[product.id] = self.product_elapsed_times.get(product.id, 0) + elapsed_before_interrupt
                del self.product_start_times[product.id]
                print(f"[{self.env.now:.2f}] 💾 Conveyor {self.id}: 产品 {product.id} 中断前已传输 {elapsed_before_interrupt:.1f}s，剩余 {self.transfer_time - self.product_elapsed_times.get(product.id, 0):.1f}s")
            
            # 根据中断原因处理
            if "Downstream blocked" in interrupt_reason:
                # 这是阻塞中断
                print(f"[{self.env.now:.2f}] ⏸️ Conveyor {self.id}: Product {product.id} paused due to downstream blockage")
                # 阻塞状态已经由_block_all_products设置，这里不需要重复设置
                    
            else:
                # 这是故障中断
                print(f"[{self.env.now:.2f}] ⚠️ Conveyor {self.id}: Processing of product {product.id} was interrupted by fault")
                
                # 如果产品已经取出，说明已完成传输，应该放入下游
                if actual_product and actual_product not in self.buffer.items and self.downstream_station:
                    # 产品已完成传输，直接放入下游
                    print(f"[{self.env.now:.2f}] 📦 Conveyor {self.id}: Product {actual_product.id} already transferred, putting to downstream")
                    yield self.downstream_station.buffer.put(actual_product)
                    
                    # 更新产品位置
                    actual_product.update_location(self.downstream_station.id, self.env.now)
                    msg = f"[{self.env.now:.2f}] Conveyor {self.id}: moved product {actual_product.id} to {self.downstream_station.id} (during fault interrupt)"
                    print(msg)
                    
                    # 清理时间记录
                    if actual_product.id in self.product_start_times:
                        del self.product_start_times[actual_product.id]
                    if actual_product.id in self.product_elapsed_times:
                        del self.product_elapsed_times[actual_product.id]
                else:
                    # 产品还在传输中，中断是合理的
                    print(f"[{self.env.now:.2f}] 🔄 Conveyor {self.id}: Product {product.id} interrupted during transfer")
                
                # 设置故障状态
                self.set_status(DeviceStatus.FAULT)
                self.publish_status()
            
        finally:
            self.publish_status()

    def recover(self):
        """Custom recovery logic for the conveyor."""
        # 清理不在buffer中的产品的时间记录
        products_in_buffer = {p.id for p in self.buffer.items}
        
        # 清理start_times
        expired_products = [pid for pid in self.product_start_times if pid not in products_in_buffer]
        for pid in expired_products:
            del self.product_start_times[pid]
            print(f"[{self.env.now:.2f}] 🗑️ Conveyor {self.id}: 清理过期产品 {pid} 的开始时间记录")
        
        # 清理elapsed_times
        expired_elapsed = [pid for pid in self.product_elapsed_times if pid not in products_in_buffer]
        for pid in expired_elapsed:
            del self.product_elapsed_times[pid]
            print(f"[{self.env.now:.2f}] 🗑️ Conveyor {self.id}: 清理过期产品 {pid} 的已传输时间记录")
        
        # 恢复后，它应该继续工作，而不是空闲
        self.set_status(DeviceStatus.WORKING)
        msg = f"[{self.env.now:.2f}] ✅ Conveyor {self.id} is recovered."
        print(msg)
        self.publish_status(msg)
        
    def interrupt_all_processing(self):
        """Interrupt all active product processing. Called by fault system."""
        interrupted_count = 0
        for product_id, process in list(self.active_processes.items()):
            if process.is_alive:
                process.interrupt("Fault injected")
                interrupted_count += 1
        print(f"[{self.env.now:.2f}] 🚫 Conveyor {self.id}: Interrupted {interrupted_count} product processes")
        return interrupted_count
    
    def _block_all_products(self, reason="Downstream blocked"):
        """阻塞所有产品处理（除了正在等待的领头产品）"""
        if self.status == DeviceStatus.BLOCKED:
            print(f"[{self.env.now:.2f}] [DEBUG] Conveyor {self.id}: already blocked, skip")
            return  # 已经处于阻塞状态
        
        # 设置阻塞状态
        self.set_status(DeviceStatus.BLOCKED)
        self.publish_status("Conveyor blocked - downstream full")
        
        # 中断所有非领头的活跃进程（与interrupt_all_processing类似）
        blocked_count = 0
        for product_id, process in list(self.active_processes.items()):
            if process != self.blocked_leader_process and process.is_alive:
                process.interrupt(reason)
                blocked_count += 1
        
        print(f"[{self.env.now:.2f}] 🚧 Conveyor {self.id}: Blocked {blocked_count} products due to downstream blockage")
    
    def _unblock_all_products(self):
        """解除阻塞，允许产品继续处理"""
        if self.status != DeviceStatus.BLOCKED:
            print(f"[{self.env.now:.2f}] [DEBUG] Conveyor {self.id}: not blocked, skip unblock")
            return  # 不在阻塞状态
        
        self.set_status(DeviceStatus.WORKING)
        self.publish_status("Conveyor unblocked - resuming operation")
        self.blocked_leader_process = None
        
        print(f"[{self.env.now:.2f}] ✅ Conveyor {self.id}: Unblocked, products can resume")

class TripleBufferConveyor(BaseConveyor):
    """
    Conveyor with three buffers:
    - main_buffer: for direct transfer to QualityCheck (auto-transfer)
    - upper_buffer: for P3 products, AGV pickup
    - lower_buffer: for P3 products, AGV pickup
    All buffers use simpy.Store for event-driven simulation.
    """
    def __init__(self, env, id, main_capacity, upper_capacity, lower_capacity, position: Tuple[int, int], transfer_time: float =5.0, mqtt_client=None, interacting_points: list = [], kpi_calculator=None, topic_manager: Optional[TopicManager] = None, line_id: Optional[str] = None):
        super().__init__(env, id, position, transfer_time, line_id, interacting_points, topic_manager, mqtt_client)
        self.topic_manager = topic_manager
        self.line_id = line_id
        self.main_buffer = simpy.Store(env, capacity=main_capacity)
        self.upper_buffer = simpy.Store(env, capacity=upper_capacity)
        self.lower_buffer = simpy.Store(env, capacity=lower_capacity)
        self.kpi_calculator = kpi_calculator  # KPI calculator dependency
        self.downstream_station = None  # QualityCheck
        self.action = None  # 保留但不使用，兼容 fault system 接口
        self.transfer_time = transfer_time # 模拟搬运时间
        self.main_process = None  # 主运行进程
        self.active_processes = {}  # Track active transfer processes per product
        self.product_start_times = {}  # Track when each product started transfer
        self.product_elapsed_times = {}  # Track elapsed time before interruption
        
        # 阻塞管理
        self.blocked_leader_process = None  # 正在等待下游的领头产品进程
        
        # 传送带默认状态为工作中
        self.status = DeviceStatus.WORKING
        self.publish_status("Conveyor initialized")
        
        # Initialize device utilization tracking
        if self.kpi_calculator:
            self.kpi_calculator.update_device_utilization(self.id, self.line_id, 0.0)
        
        # Start background process to update total time for utilization calculation
        self.env.process(self._update_total_time())

    def _should_be_blocked(self):
        """检查三缓冲传送带是否应该处于阻塞状态"""
        # 所有缓冲区都满才算真正阻塞
        return self.is_full("main") and self.is_full("upper") and self.is_full("lower") and self.downstream_station and not self.downstream_station.can_operate()

    def publish_status(self, message: Optional[str] = None):
        """发布当前传送带状态到MQTT"""
        if not self.mqtt_client or not self.mqtt_client.is_connected():
            return

        # 只发布，不修改状态
        status_data = ConveyorStatus(
            timestamp=self.env.now,
            source_id=self.id,
            status=self.status,
            buffer=[p.id for p in self.main_buffer.items],
            upper_buffer=[p.id for p in self.upper_buffer.items],
            lower_buffer=[p.id for p in self.lower_buffer.items],
            message=message,
        )
        if self.topic_manager and self.line_id:
            topic = self.topic_manager.get_conveyor_status_topic(self.line_id, self.id)
        else:
            topic = get_conveyor_status_topic(self.id)
        self.mqtt_client.publish(topic, status_data.model_dump_json(), retain=False)

    def set_downstream_station(self, station):
        """Set the downstream station for auto-transfer from main_buffer."""
        self.downstream_station = station
        if self.main_process is None:
            self.main_process = self.env.process(self.run())

    def push(self, product, buffer_type="main"):
        """Put product into specified buffer. buffer_type: 'main', 'upper', 'lower'."""
        result = self.get_buffer(buffer_type).put(product)
        print(f"[{self.env.now:.2f}] [DEBUG] TripleBufferConveyor {self.id}: push {product.id} to {buffer_type} buffer, buffer={len(self.get_buffer(buffer_type).items)}/{self.get_buffer(buffer_type).capacity}")
        # 产品添加后发布状态
        self.publish_status()
        return result

    def get_buffer(self, buffer_type="main"):
        if buffer_type == "main":
            return self.main_buffer
        elif buffer_type == "upper":
            return self.upper_buffer
        elif buffer_type == "lower":
            return self.lower_buffer
        else:
            raise ValueError("buffer_type must be 'main', 'upper', or 'lower'")

    def pop(self, buffer_type="main"):
        """Get product from specified buffer."""
        product = yield self.get_buffer(buffer_type).get()
        print(f"[{self.env.now:.2f}] [DEBUG] TripleBufferConveyor {self.id}: pop {product.id} from {buffer_type} buffer, buffer={len(self.get_buffer(buffer_type).items)}/{self.get_buffer(buffer_type).capacity}")
        
        # 如果是从main_buffer取出且该产品有对应的处理进程，中断并删除它
        if buffer_type == "main" and product.id in self.active_processes:
            process = self.active_processes[product.id]
            if process.is_alive:
                process.interrupt("Product removed by AGV")
                print(f"[{self.env.now:.2f}] 🚫 TripleBufferConveyor {self.id}: Interrupted process for product {product.id} (taken by AGV from {buffer_type})")
            del self.active_processes[product.id]
            
            # 清理该产品的时间记录
            if product.id in self.product_start_times:
                del self.product_start_times[product.id]
            if product.id in self.product_elapsed_times:
                del self.product_elapsed_times[product.id]
        
        # 产品移除后发布状态
        self.publish_status()
        return product

    def is_full(self, buffer_type="main"):
        if buffer_type == "main":
            return len(self.main_buffer.items) >= self.main_buffer.capacity
        elif buffer_type == "upper":
            return len(self.upper_buffer.items) >= self.upper_buffer.capacity
        elif buffer_type == "lower":
            return len(self.lower_buffer.items) >= self.lower_buffer.capacity
        else:
            raise ValueError("buffer_type must be 'main', 'upper', or 'lower'")

    def is_empty(self, buffer_type="main"):
        if buffer_type == "main":
            return len(self.main_buffer.items) == 0
        elif buffer_type == "upper":
            return len(self.upper_buffer.items) == 0
        elif buffer_type == "lower":
            return len(self.lower_buffer.items) == 0
        else:
            raise ValueError("buffer_type must be 'main', 'upper', or 'lower'")

    def run(self):
        """Main operational loop for the triple buffer conveyor. This should NOT be interrupted by faults."""
        
        while True:
            # 等待设备可操作且buffer有产品
            yield self.env.process(self._wait_for_ready_state())
            
            # 检查是否应该解除阻塞状态
            if self.status == DeviceStatus.BLOCKED:
                # 如果下游工站恢复正常或者没有正在等待的领头进程，解除阻塞
                if self.downstream_station and self.downstream_station.can_operate() and not self.downstream_station.is_full():
                    if self.blocked_leader_process is None or not self.blocked_leader_process.is_alive:
                        print(f"[{self.env.now:.2f}] 🔓 TripleBufferConveyor {self.id}: Downstream recovered or no leader waiting, unblocking")
                        self._unblock_all_products()
            
            # 检查main_buffer中的每个产品，如果还没有处理进程就启动一个
            for item in list(self.main_buffer.items):  # 使用list避免迭代时修改
                if item.id not in self.active_processes:
                    # 只有在非阻塞状态下才为新产品启动处理进程
                    if self.status != DeviceStatus.BLOCKED:
                        # 为这个产品启动一个处理进程
                        process = self.env.process(self.process_single_item(item))
                        self.active_processes[item.id] = process
                    else:
                        # 如果是阻塞状态，检查这个产品是否是第一个（领头产品）
                        if len(self.main_buffer.items) > 0 and self.main_buffer.items[0].id == item.id:
                            # 这是领头产品，允许启动进程
                            process = self.env.process(self.process_single_item(item))
                            self.active_processes[item.id] = process
                            print(f"[{self.env.now:.2f}] 👑 TripleBufferConveyor {self.id}: Starting process for leader product {item.id} despite blocked status")
            
            # 清理已完成的进程
            completed_ids = []
            for product_id, process in self.active_processes.items():
                if not process.is_alive:
                    completed_ids.append(product_id)
            for product_id in completed_ids:
                del self.active_processes[product_id]
            
            yield self.env.timeout(0.1)  # 短暂等待后再检查
    
    def _wait_for_ready_state(self):
        """等待设备处于可操作状态且buffer有产品"""
        while True:
            
            # 如果没有下游站点，等待
            if self.downstream_station is None:
                yield self.env.timeout(1)
                continue
            # 如果main_buffer为空，等待
            if len(self.main_buffer.items) == 0 or not self.can_operate():
                yield self.env.timeout(0.1)
                continue
            return
    
    def process_single_item(self, product):
        """Process a single item from main_buffer with timeout-get-put pattern. This CAN be interrupted by faults."""
        actual_product = None
        try:
            # 检查下游站点是否存在
            if self.downstream_station is None:
                return
            
            # 如果当前是blocked状态且不是领头产品，不应该继续
            if self.status == DeviceStatus.BLOCKED:
                is_leader = len(self.main_buffer.items) > 0 and self.main_buffer.items[0].id == product.id
                if not is_leader:
                    print(f"[{self.env.now:.2f}] 🚫 TripleBufferConveyor {self.id}: Product {product.id} blocked at start, not leader")
                    return
            
            self.set_status(DeviceStatus.WORKING)
            self.publish_status()
            
             # 计算剩余传输时间（处理中断后恢复的情况）
            if product.id in self.product_elapsed_times:
                # 恢复传输：使用之前记录的已传输时间
                elapsed_time = self.product_elapsed_times[product.id]
                remaining_time = max(0, self.transfer_time - elapsed_time)
                msg = f"[{self.env.now:.2f}] Conveyor {self.id}: {product.id} resume transferring, elapsed {elapsed_time:.1f}s, remaining {remaining_time:.1f}s"
            else:
                # 第一次开始传输
                remaining_time = self.transfer_time
                msg = f"[{self.env.now:.2f}] Conveyor {self.id}: {product.id} start transferring, need {remaining_time:.1f}s"
            print(msg)
            self.publish_status(msg)
            self.product_start_times[product.id] = self.env.now
            
            # 进行timeout（模拟搬运时间）
            # Track start of working time for KPI
            working_start_time = self.env.now
            yield self.env.timeout(remaining_time)
            
            is_first_product = self.main_buffer.items[0].id == product.id

            # Report energy cost and working time for this transfer
            if self.kpi_calculator:
                self.kpi_calculator.add_energy_cost(self.id, self.line_id, self.transfer_time, is_peak_hour=False)
                # Working time is already tracked in add_energy_cost
            
            # 获取产品
            actual_product = yield self.main_buffer.get()

            # 确保获取的是正确的产品
            if actual_product.id != product.id:
                # 如果不是预期的产品，放回去
                yield self.main_buffer.put(actual_product)
                msg = f"[{self.env.now:.2f}] TripleBufferConveyor {self.id}: unexpected product order, retrying"
                print(msg)
                self.publish_status(msg)
                return
            
            self.publish_status()
            
            target_buffer = self._determine_target_buffer_for_product(product)
            # 根据目标buffer类型决定处理
            if target_buffer in ["upper", "lower"]:
                # P3产品返工路径：选择最优的side buffer
                chosen_buffer = self._choose_optimal_side_buffer()
                buffer_name = "upper_buffer" if chosen_buffer == self.upper_buffer else "lower_buffer"
                actual_product.add_history(self.env.now, f"Moved to {buffer_name} of {self.id} for rework")
                msg = f"[{self.env.now:.2f}] TripleBufferConveyor {self.id}: moved product {actual_product.id} to {buffer_name}"
            else:
                chosen_buffer = self.downstream_station.buffer
                buffer_name = self.downstream_station.id+"_buffer"
                msg = f"[{self.env.now:.2f}] TripleBufferConveyor {self.id}: moved product {actual_product.id} to {self.downstream_station.id}"
            print(msg)
            self.publish_status(msg)
            
            if is_first_product:
                # 这是最前面的产品，设为领头进程
                self.blocked_leader_process = self.env.active_process
                print(f"[{self.env.now:.2f}] 🎯 Conveyor {self.id}: {actual_product.id} is the leader product (first in order)")
                
                print(f"[{self.env.now:.2f}] 🔍 Conveyor {self.id}: {buffer_name} buffer {len(chosen_buffer.items)}/{chosen_buffer.capacity}, can opeatate:{self.downstream_station.can_operate()}")
                
                if buffer_name == "upper_buffer" or buffer_name == "lower_buffer":
                    if len(chosen_buffer.items) >= chosen_buffer.capacity and self.status != DeviceStatus.BLOCKED:
                        # 下游已满或下游工站不可操作，阻塞其他产品
                        self._block_all_products()
                    while len(chosen_buffer.items) >= chosen_buffer.capacity:
                        yield self.env.timeout(0.1)
                else:
                    if (len(chosen_buffer.items) >= chosen_buffer.capacity or not self.downstream_station.can_operate()) and self.status != DeviceStatus.BLOCKED:
                        # 下游已满，阻塞其他产品
                        self._block_all_products()
                    while len(chosen_buffer.items) >= chosen_buffer.capacity or not self.downstream_station.can_operate():
                        yield self.env.timeout(1)
                    
                yield chosen_buffer.put(actual_product)

                # 成功放入，如果之前是阻塞状态，现在解除
                if self.status == DeviceStatus.BLOCKED:
                    self._unblock_all_products()
                    
            else:
                # 不是第一个产品
                print(f"[{self.env.now:.2f}] 📦 Conveyor {self.id}: {actual_product.id} is NOT the leader product (order: {[p.id for p in self.main_buffer.items]})")
                
                # 非领头产品需要等待，直到轮到它或者传送带解除阻塞
                while self.status == DeviceStatus.BLOCKED:
                    print(f"[{self.env.now:.2f}] ⏳ Conveyor {self.id}: {actual_product.id} waiting for its turn or unblock...")
                    yield self.env.timeout(0.1)
                
                # 现在可以尝试放入下游
                yield chosen_buffer.put(actual_product)

            if not target_buffer in ["upper", "lower"]:
                actual_product.update_location(self.downstream_station.id, self.env.now)

            # 清理时间记录
            if actual_product and actual_product.id in self.product_start_times:
                del self.product_start_times[actual_product.id]
            if actual_product and actual_product.id in self.product_elapsed_times:
                del self.product_elapsed_times[actual_product.id]

        except simpy.Interrupt as e:
            interrupt_reason = str(e.cause) if hasattr(e, 'cause') else "Unknown"
            
            # 如果是AGV取走产品的中断，直接返回
            if "Product removed by AGV" in interrupt_reason:
                print(f"[{self.env.now:.2f}] 🚚 TripleBufferConveyor {self.id}: Product {product.id} was taken by AGV, stopping process")
                # 时间记录已经在pop()中清理了，这里不需要再清理
                return
            
            print(f"[{self.env.now:.2f}] ⚠️ TripleBufferConveyor {self.id}: Processing of product {product.id} was interrupted:{interrupt_reason}")
            
            # 记录中断时已经传输的时间（阻塞和故障都需要）
            if product.id in self.product_start_times:
                start_time = self.product_start_times[product.id]
                elapsed_before_interrupt = self.env.now - start_time
                self.product_elapsed_times[product.id] = self.product_elapsed_times.get(product.id, 0) + elapsed_before_interrupt
                del self.product_start_times[product.id]
                print(f"[{self.env.now:.2f}] 💾 Conveyor {self.id}: 产品 {product.id} 中断前已传输 {elapsed_before_interrupt:.1f}s，剩余 {self.transfer_time - self.product_elapsed_times.get(product.id, 0):.1f}s")
            
        finally:
            self.publish_status()

    def _determine_target_buffer_for_product(self, product):
        """根据产品类型和工艺状态确定目标buffer"""
        if product.product_type != "P3":
            print(f"[{self.env.now:.2f}] 🔍 TripleBufferConveyor {self.id}: P1/P2产品 {product.id} 直接进入下游工站buffer")
            return "main"
        
        # P3产品的特殊逻辑：基于访问次数判断
        stationc_visits = product.visit_count.get("StationC", 0)
        
        print(f"[{self.env.now:.2f}] 🔍 TripleBufferConveyor {self.id}: P3产品 {product.id} StationC处理次数={stationc_visits}")
        
        if stationc_visits == 1:  # 第一次完成StationC处理
            print(f"[{self.env.now:.2f}] 🔄 TripleBufferConveyor {self.id}: P3产品 {product.id} 第一次在StationC处理完成，需要返工到StationB")
            return "upper"  # 返工到side buffer
        elif stationc_visits >= 2:  # 第二次及以后完成StationC处理
            print(f"[{self.env.now:.2f}] ✅ TripleBufferConveyor {self.id}: P3产品 {product.id} 第二次处理完成，继续主流程")
            return "main"   # 进入主流程
        else:
            print(f"[{self.env.now:.2f}] ⚠️ TripleBufferConveyor {self.id}: P3产品 {product.id} 未处理过，继续主流程")
            return "main"   # 默认主流程
    
    def _choose_optimal_side_buffer(self):
        """选择最优的side buffer（upper或lower）"""
        if self.downstream_station is None:
            return self.upper_buffer  # 默认返回upper
        
        if self.upper_buffer.capacity - len(self.upper_buffer.items) >= self.lower_buffer.capacity - len(self.lower_buffer.items):
            if self.is_full("upper") and self.is_full("lower"):
                self.report_buffer_full("upper_buffer and lower_buffer are full")
            return self.upper_buffer
        else:
            return self.lower_buffer
        
    def recover(self):
        """Custom recovery logic for the TripleBufferConveyor."""
        print(f"[{self.env.now:.2f}] ✅ TripleBufferConveyor {self.id} is recovering.")
        # 恢复后，它应该继续工作，而不是空闲
    
    def _update_total_time(self):
        """Background process to update total time for KPI utilization calculation"""
        while True:
            yield self.env.timeout(10.0)  # Update every 10 seconds
            if self.kpi_calculator:
                self.kpi_calculator.update_device_utilization(self.id, self.line_id, self.env.now)
        self.set_status(DeviceStatus.WORKING)
        self.publish_status()
        
    def interrupt_all_processing(self):
        """Interrupt all active product processing. Called by fault system."""
        interrupted_count = 0
        for product_id, process in list(self.active_processes.items()):
            if process.is_alive:
                process.interrupt("Fault injected")
                interrupted_count += 1
        print(f"[{self.env.now:.2f}] 🚫 TripleBufferConveyor {self.id}: Interrupted {interrupted_count} product processes")
        return interrupted_count

    def _block_all_products(self, reason="Downstream or side buffer blocked"):
        """阻塞所有产品处理（除了正在等待的领头产品）"""
        if self.status == DeviceStatus.BLOCKED:
            print(f"[{self.env.now:.2f}] [DEBUG] TripleBufferConveyor {self.id}: already blocked, skip")
            return  # 已经处于阻塞状态
        
        # 设置阻塞状态
        self.set_status(DeviceStatus.BLOCKED)
        self.publish_status("Conveyor blocked - downstream or side buffer full")
        
        # 中断所有非领头的活跃进程（与interrupt_all_processing类似）
        blocked_count = 0
        for product_id, process in list(self.active_processes.items()):
            if process != self.blocked_leader_process and process.is_alive:
                process.interrupt(reason)
                blocked_count += 1
        
        print(f"[{self.env.now:.2f}] 🚧 Conveyor {self.id}: Blocked {blocked_count} products due to downstream blockage")

    def _unblock_all_products(self):
        """解除阻塞，允许产品继续处理"""
        if self.status != DeviceStatus.BLOCKED:
            print(f"[{self.env.now:.2f}] [DEBUG] TripleBufferConveyor {self.id}: not blocked, skip unblock")
            return  # 不在阻塞状态
        
        self.set_status(DeviceStatus.WORKING)
        self.publish_status("Conveyor unblocked - resuming operation")
        self.blocked_leader_process = None
        
        print(f"[{self.env.now:.2f}] ✅ Conveyor {self.id}: Unblocked, products can resume")


================================================
File: src/simulation/entities/product.py
================================================
# src/simulation/entities/product.py
import uuid
import random
from typing import List, Tuple, Dict, Optional
from enum import Enum
from dataclasses import dataclass

class QualityStatus(Enum):
    """产品质量状态"""
    UNKNOWN = "unknown"          # 未检测
    MAJOR_DEFECT = "major_defect"  # 严重缺陷，需返工
    SCRAP = "scrap"             # 报废

class Product:
    """
    Represents a single product unit being manufactured in the factory.
    
    Attributes:
        id (str): A unique identifier for the product instance.
        product_type (str): The type of the product (e.g., 'P1', 'P2').
        order_id (str): The ID of the order this product belongs to.
        history (List[Tuple[float, str]]): A log of events for this product.
        quality_status (QualityStatus): Current quality status
        quality_score (float): Quality score
        processing_stations (List[str]): Records of stations processed
        rework_count (int): 返工次数
        inspection_count (int): 检测次数
        current_location (str): 当前所在位置
        process_step (int): 当前工艺步骤索引
        visit_count (Dict[str, int]): 跟踪访问每个工站的次数
        
    """
    
    # 产品工艺路线定义 - 定义每种产品类型的标准加工顺序
    PROCESS_ROUTES = {
        "P1": ["RawMaterial", "StationA", "StationB", "StationC", "QualityCheck", "Warehouse"],
        "P2": ["RawMaterial", "StationA", "StationB", "StationC", "QualityCheck", "Warehouse"],  
        "P3": ["RawMaterial", "StationA", "StationB", "StationC", "StationB", "StationC", "QualityCheck", "Warehouse"]
    }
    
    def __init__(self, product_type: str, order_id: str):
        self.id: str = f"prod_{product_type[1]}_{uuid.uuid4().hex[:8]}"
        self.product_type: str = product_type
        self.order_id: str = order_id
        self.history: List[Tuple[float, str]] = []
        
        # 质量相关属性
        self.quality_status: QualityStatus = QualityStatus.UNKNOWN
        self.processing_stations: List[str] = []
        self.rework_count: int = 0
        self.inspection_count: int = 0
        
        # 移动控制相关属性
        self.current_location: str = "RawMaterial"  # 初始位置在原料仓库
        self.process_step: int = 0  # 当前在工艺路线中的步骤索引
        self.visit_count: Dict[str, int] = {}  # 跟踪访问每个工站的次数
        
        # 质量评分系统
        self.quality_score: float = random.uniform(0.85, 0.95)  # 当前质量分数
        self.quality_factors: Dict[str, float] = {  # 质量影响因素
            "processing_defects": 0.0,  # 加工缺陷累积
            "rework_improvement": 0.0,  # 返工改善
            "handling_damage": 0.0      # 搬运损伤
        }
        
    def __repr__(self) -> str:
        return f"Product(id='{self.id}', type='{self.product_type}', location='{self.current_location}', quality='{self.quality_status.value}')"


    def add_history(self, timestamp: float, event: str):
        """Adds a new event to the product's history log."""
        self.history.append((timestamp, event))
        
    def next_move_checker(self, timestamp: float, target_location: str) -> Tuple[bool, str]:
        """
        检查下一个move是否符合当前产品的station orderpolicy
        
        Args:
            timestamp: 当前时间戳
            target_location: 目标位置
            
        Returns:
            Tuple[bool, str]: (是否允许移动, 说明信息)
        """
        # 获取当前产品的工艺路线
        route = self.PROCESS_ROUTES.get(self.product_type)
        if not route:
            return False, f"未知产品类型: {self.product_type}"
        
        # 检查当前位置是否在路线中
        if self.current_location not in route:
            return False, f"当前位置 {self.current_location} 不在工艺路线中"
        
        current_index = route.index(self.current_location)
        
        # 处理特殊情况：P3产品的返工逻辑
        if self._is_p3_rework_move(target_location, current_index):
            return True, f"P3产品从 {self.current_location} 返工到 {target_location}"
        
        # 标准顺序检查：只能前进到下一个工站
        if current_index >= len(route) - 1:
            return False, f"产品已到达最终位置"
        
        expected_next = route[current_index + 1]
        
        if target_location == expected_next:
            return True, f"允许从 {self.current_location} 移动到 {target_location}"
        
        # 检查是否为质检返工移动
        if self.rework_count > 0:
            # 返工时允许从QualityCheck回到StationC
            if self.current_location == "QualityCheck" and target_location.startswith("StationC"):
                return True, f"质检返工移动：从 {self.current_location} 返回到 {target_location}"
            # 返工完成后可以再次去质检
            elif target_location == "QualityCheck" and self.current_location in route:
                return True, f"返工后再次质检：从 {self.current_location} 到 {target_location}"
        
        # 其他情况均不允许
        return False, f"不允许的移动：从 {self.current_location} 到 {target_location}，期望下一站: {expected_next}"
    
    def _is_p3_rework_move(self, target_location: str, current_index: int) -> bool:
        """检查是否为P3产品的标准工艺流程移动（非质检返工）"""
        if self.product_type != "P3" or self.current_location != "StationC":
            return False
            
        stationc_visits = self.visit_count.get("StationC", 0)
        
        # P3标准工艺：第一次在StationC后需要去StationB
        if stationc_visits == 1 and target_location == "StationB" and self.rework_count == 0:
            return True
        
        # P3标准工艺：第二次在StationC后可以去质检
        if stationc_visits == 2 and target_location == "QualityCheck":
            return True
            
        return False
    
    def update_location(self, new_location: str, timestamp: float) -> bool:
        """
        更新产品位置（应在移动检查通过后调用）
        
        Args:
            new_location: 新位置
            timestamp: 时间戳
            
        Returns:
            bool: 更新是否成功
        """
        # 更新位置
        old_location = self.current_location
        self.current_location = new_location
        
        # 注意：访问次数已在 process_at_station 中更新，这里不再更新
        # 避免重复计数
        
        # 更新工艺步骤索引
        route = self.PROCESS_ROUTES[self.product_type]
        if new_location in route:
            self.process_step = route.index(new_location)
        
        # 搬运过程可能造成损伤
        if old_location != "RawMaterial" and new_location != "Warehouse":
            damage_probability = 0.05  # 5%概率
            if random.random() < damage_probability:
                damage_impact = random.uniform(0.01, 0.03)  # 1-3%的质量损失
                self.quality_factors["handling_damage"] += damage_impact
                self._update_quality_score()
                self.add_history(timestamp, f"Handling damage during transport: -{damage_impact:.2%}")
        
        # 记录历史
        self.add_history(timestamp, f"Moved from {old_location} to {new_location}")
        
        print(f"[{timestamp:.2f}] 📦 {self.id}: 成功移动 {old_location} → {new_location}")
        return True
    
    def get_next_expected_location(self) -> Optional[str]:
        """获取下一个期望的位置"""
        route = self.PROCESS_ROUTES.get(self.product_type)
        if not route or self.current_location not in route:
            return None
        
        current_index = route.index(self.current_location)
        
        # 处理P3标准工艺流程（非质检返工）
        if self.product_type == "P3" and self.current_location == "StationC" and self.rework_count == 0:
            stationc_visits = self.visit_count.get("StationC", 0)
            if stationc_visits == 1:  # 第一次在StationC
                return "StationB"  # 需要返回StationB
            elif stationc_visits == 2:  # 第二次在StationC  
                return "QualityCheck"  # 可以去质检站
        
        # 标准情况：返回下一个位置
        if current_index < len(route) - 1:
            return route[current_index + 1]
        
        return None  # 已经到达最终位置
    
    def get_process_completion_percentage(self) -> float:
        """获取工艺完成百分比"""
        route = self.PROCESS_ROUTES.get(self.product_type)
        if not route or self.current_location not in route:
            return 0.0
        
        total_steps = len(route) - 1  # 减去起始位置
        current_index = route.index(self.current_location)
        return (current_index / total_steps) * 100.0
        
    def process_at_station(self, station_id: str, timestamp: float):
        """记录在工站的处理（不进行移动检查，假设产品已经在该工站）"""
        # 记录调试信息
        old_count = self.visit_count.get(station_id, 0)
        
        self.processing_stations.append(station_id)
        self.add_history(timestamp, f"Processed at {station_id}")
            
        # 加工过程可能引入缺陷
        if station_id.startswith("Station"):
            # 每次加工有概率引入小缺陷
            defect_probability = 0.1  # 10%概率
            if random.random() < defect_probability:
                defect_impact = random.uniform(0.02, 0.05)  # 2-5%的质量损失
                self.quality_factors["processing_defects"] += defect_impact
                self._update_quality_score()
                self.add_history(timestamp, f"Processing defect at {station_id}: -{defect_impact:.2%}")
        
        # 更新访问计数（重要：用于P3产品的流程控制）
        self.visit_count[station_id] = self.visit_count.get(station_id, 0) + 1
        
        print(f"[{timestamp:.2f}] 📊 {self.id}: {station_id} 访问次数: {old_count} → {self.visit_count[station_id]}")
        
    def start_inspection(self, timestamp: float):
        """开始质量检测"""
        self.inspection_count += 1
        self.add_history(timestamp, f"Quality inspection started (#{self.inspection_count})")
        
    def complete_inspection(self, timestamp: float, result: QualityStatus):
        """完成质量检测"""
        self.quality_status = result
        self.add_history(timestamp, f"Quality inspection completed: {result.value}")
        
    def start_rework(self, timestamp: float, target_station: str):
        """开始返工（质检不合格导致）"""
        self.rework_count += 1
        self.quality_status = QualityStatus.UNKNOWN  # 返工后重新检测
        
        # 返工改善质量：只允许一次返工，修复70%的加工缺陷
        if self.rework_count == 1:
            actual_improvement = self.quality_factors["processing_defects"] * 0.7
        else:
            actual_improvement = 0  # 不允许第二次返工
        
        if actual_improvement > 0:
            self.quality_factors["rework_improvement"] += actual_improvement
            self.quality_factors["processing_defects"] = max(0, self.quality_factors["processing_defects"] - actual_improvement)
            self._update_quality_score()
            self.add_history(timestamp, f"Rework #{self.rework_count} -> {target_station}, quality improved by {actual_improvement:.2%}")
        else:
            self.add_history(timestamp, f"Rework #{self.rework_count} -> {target_station}, no improvement possible")
        
        self.add_history(timestamp, f"Marked for rework to {target_station}")
        
    def get_quality_summary(self) -> Dict:
        """获取质量摘要信息"""
        return {
            "id": self.id,
            "product_type": self.product_type,
            "quality_status": self.quality_status.value,
            "quality_score": round(self.quality_score, 2),
            "rework_count": self.rework_count,
            "inspection_count": self.inspection_count,
            "processing_stations": self.processing_stations.copy(),
            "can_rework": self.rework_count == 0,
            "quality_factors": self.quality_factors.copy()
        }
    
    def _update_quality_score(self):
        """根据各种因素更新质量分数"""
        # 计算总质量分数
        total_impact = (
            self.quality_factors["processing_defects"] +
            self.quality_factors["handling_damage"] -
            self.quality_factors["rework_improvement"]
        )
        
        # 更新当前质量分数，确保在0-1范围内
        self.quality_score = max(0.0, min(1.0, self.quality_score - total_impact))
        
    def simulate_aging(self, timestamp: float, aging_factor: float = 0.01):
        """模拟产品老化（如在仓库等待时）"""
        self.quality_factors["handling_damage"] += aging_factor
        self._update_quality_score()
        self.add_history(timestamp, f"Product aging: -{aging_factor:.2%}")


================================================
File: src/simulation/entities/quality_checker.py
================================================
# src/simulation/entities/quality_checker.py
import simpy
import random
from typing import Dict, Tuple, Optional
from enum import Enum

from config.schemas import DeviceStatus, StationStatus
from src.simulation.entities.station import Station
from src.simulation.entities.product import Product, QualityStatus
from src.utils.topic_manager import TopicManager

class SimpleDecision(Enum):
    """简化的质量检测决策"""
    PASS = "pass"           # 通过
    SCRAP = "scrap"         # 报废
    REWORK = "rework"       # 返工 (回到上一个工站)

class QualityChecker(Station):
    """
    简化版质量检测站 - 只保留核心功能
    
    核心逻辑：
    1. 基于产品质量分数做出简单决策
    2. 通过/报废/返工三种结果
    3. 最小化配置参数
    4. 增加output_buffer，满时阻塞并告警
    """
    
    def __init__(
        self,
        env: simpy.Environment,
        id: str,
        position: Tuple[int, int],
        buffer_size: int = 1,
        processing_times: Dict[str, Tuple[int, int]] = {},
        pass_threshold: float = 80.0,  # 合格阈值
        scrap_threshold: float = 60.0,  # 报废阈值
        output_buffer_capacity: int = 5,  # 新增，output buffer容量
        mqtt_client=None,
        interacting_points: list = [],
        topic_manager: Optional[TopicManager] = None,
        line_id: Optional[str] = None
    ):
        # 默认检测时间
        if processing_times is None:
            processing_times = {
                "P1": (10, 15),
                "P2": (12, 18), 
                "P3": (10, 15)
            }
        
        # Initialize output buffer before calling super().__init__() 
        # since publish_status() is called in parent's __init__
        self.pass_threshold = pass_threshold
        self.scrap_threshold = scrap_threshold
        self.output_buffer_capacity = output_buffer_capacity
        self.output_buffer = simpy.Store(env, capacity=output_buffer_capacity)
        
        super().__init__(env, id, position, topic_manager=topic_manager, line_id=line_id, buffer_size=buffer_size, processing_times=processing_times, downstream_conveyor=None, mqtt_client=mqtt_client, interacting_points=interacting_points)
        
        # 简单统计
        self.stats = {
            "inspected_count": 0,
            "total_processing_time": 0.0,
            "average_processing_time": 0.0,
            "passed_count": 0,
            "reworked_count": 0,
            "scrapped_count": 0,
            "working_time": 0.0,  # Total time spent in PROCESSING status
            "start_time": env.now  # Track when station started
        }
        
        print(f"[{self.env.now:.2f}] 🔍 {self.id}: Simple quality checker ready (pass≥{self.pass_threshold}%, scrap≤{self.scrap_threshold}%)")
        # The run process is already started by the parent Station class
        
    def publish_status(self, message: Optional[str] = None):
        """Publishes the current status of the station to MQTT."""
        if not self.mqtt_client or not self.mqtt_client.is_connected():
            return
            
        status_data = StationStatus(
            timestamp=self.env.now,
            source_id=self.id,
            status=self.status,
            buffer=[p.id for p in self.buffer.items],
            stats=self.stats,
            output_buffer=[p.id for p in self.output_buffer.items],
            message=message,
        )
        if self.topic_manager and self.line_id:
            topic = self.topic_manager.get_station_status_topic(self.line_id, self.id)
        else:
            from config.topics import get_station_status_topic
            topic = get_station_status_topic(self.id)
        self.mqtt_client.publish(topic, status_data.model_dump_json(), retain=False)

    def process_product(self, product: Product):
        """
        Quality check process following Station's timeout-get-put pattern.
        """
        try:
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: process_product called for {product.id}, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            # Check if the device can operate
            if not self.can_operate():
                msg = f"[{self.env.now:.2f}] ⚠️  {self.id}: can not process product, device is not available"
                print(msg)
                self.publish_status(msg)
                return

            self.set_status(DeviceStatus.PROCESSING)
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: set_status(PROCESSING), buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            self.publish_status()

            # Record processing start and get processing time
            min_time, max_time = self.processing_times.get(product.product_type, (10, 15))
            processing_time = random.uniform(min_time, max_time)
            
            # Apply efficiency and fault impacts
            efficiency_factor = getattr(self.performance_metrics, 'efficiency_rate', 100.0) / 100.0
            actual_processing_time = processing_time / efficiency_factor
            
            msg = f"[{self.env.now:.2f}] 🔍 {self.id}: 检测产品中... (预计{actual_processing_time:.1f}s)"
            print(msg)
            self.publish_status(msg)
            
            # The actual processing work (timeout-get pattern like Station)
            yield self.env.timeout(actual_processing_time)
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: timeout finished for {product.id}, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            product = yield self.buffer.get()
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: got product {product.id} from buffer, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            product.process_at_station(self.id, self.env.now)
            
            # Update statistics upon successful completion
            self.stats["inspected_count"] += 1
            self.stats["total_processing_time"] += actual_processing_time
            self.stats["average_processing_time"] = (
                self.stats["total_processing_time"] / self.stats["inspected_count"]
            )
            
            # Perform quality inspection
            decision = self._make_simple_decision(product)
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: decision for {product.id} is {decision}, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            
            # Processing finished successfully
            msg = f"[{self.env.now:.2f}] {self.id}: {product.id} finished inspecting, actual processing time: {actual_processing_time:.1f}s"
            print(msg)
            self.publish_status(msg)
            
            # Execute decision (equivalent to transfer_product_to_next_stage)
            yield self.env.process(self._execute_quality_decision(product, decision))

        except simpy.Interrupt as e:
            print(f"[{self.env.now:.2f}] ⚠️ {self.id}: Inspection of product {product.id} was interrupted: {e.cause}")
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: INTERRUPT, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            if product not in self.buffer.items:
                # 产品已取出，说明检测时间已经完成，应该继续流转
                print(f"[{self.env.now:.2f}] 🚚 {self.id}: 产品 {product.id} 已检测完成，继续流转")
                decision = self._make_simple_decision(product)
                yield self.env.process(self._execute_quality_decision(product, decision))
            else:
                # 产品还在buffer中，说明在timeout期间被中断，等待下次处理
                print(f"[{self.env.now:.2f}] ⏸️  {self.id}: 产品 {product.id} 检测被中断，留在buffer中")
        finally:
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: process_product finally for {product.id}, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            # Clear the action handle once the process is complete or interrupted
            self.action = None

    def _execute_quality_decision(self, product: Product, decision: SimpleDecision):
        """Execute quality decision (equivalent to _transfer_product_to_next_stage)"""
        print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: _execute_quality_decision for {product.id}, decision={decision}, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
        
        if decision == SimpleDecision.PASS:
            self.stats["passed_count"] += 1
            msg = f"[{self.env.now:.2f}] ✅ {self.id}: {product.id} passed quality inspection"
            print(msg)
            self.publish_status(msg)
            
            # Report to KPI calculator
            if hasattr(self, 'kpi_calculator') and self.kpi_calculator:
                self.kpi_calculator.complete_order_item(product.order_id, product.product_type, passed_quality=True)
            
            # Check if output buffer is full and report if needed
            if len(self.output_buffer.items) >= self.output_buffer_capacity:
                self.set_status(DeviceStatus.BLOCKED)
                msg = f"[{self.env.now:.2f}] ⚠️ {self.id}: output buffer is full, station is blocked"
                print(msg)
                self.publish_status(msg)
                self.report_buffer_full("output_buffer")
            # TODO: Quality Checker do not have downstream device, dont care about whether downstream can_operate, just cares about buffer full
            # Put product into output buffer (may block if full)
            yield self.output_buffer.put(product)
            msg = f"[{self.env.now:.2f}] 📦 {self.id}: 产品 {product.id} 放入output buffer，等待AGV/人工搬运"
            
        elif decision == SimpleDecision.SCRAP:

            # Report to KPI calculator
            if hasattr(self, 'kpi_calculator') and self.kpi_calculator:
                self.kpi_calculator.complete_order_item(product.order_id, product.product_type, passed_quality=False)
            
            yield self.env.process(self._handle_product_scrap(product, "quality_inspection_failed"))
            self.stats["scrapped_count"] += 1
            self.set_status(DeviceStatus.SCRAP)
            msg = f"[{self.env.now:.2f}] ❌ {self.id}: {product.id} scrapping"
            self.publish_status(msg)
            msg = f"[{self.env.now:.2f}] ⚠️ {self.id}: {product.id} scrapped"

        elif decision == SimpleDecision.REWORK:
            self.stats["reworked_count"] += 1
            # 返工：回到最后一个加工工站
            last_station = self._get_last_processing_station(product)
            if last_station:
                # 检查output buffer是否满
                if len(self.output_buffer.items) >= self.output_buffer_capacity:
                    self.set_status(DeviceStatus.BLOCKED)
                    self.publish_status("output buffer is full, station is blocked")
                    self.report_buffer_full("output_buffer")
                
                # 将返工产品放入output buffer，等待AGV运送
                yield self.output_buffer.put(product)
                msg = f"[{self.env.now:.2f}] 📦 {self.id}: {product.id} reworked to {last_station}, put into output buffer, waiting for AGV to deliver"
                
            else:
                msg = f"[{self.env.now:.2f}] ⚠️  {self.id}: can not determine rework station, product scrapped"
                yield self.env.process(self._handle_product_scrap(product, "rework_failed"))
        
        # Set status back to IDLE after the operation is complete
        self.set_status(DeviceStatus.IDLE)
        print(msg)
        self.publish_status(msg if msg else None)

    def _handle_product_scrap(self, product, reason: str):
        """Handle product scrapping due to quality issues"""
        
        # Set product status to scrapped
        product.quality_score = 0.0
        product.quality_status = QualityStatus.SCRAP
        
        # Simulate scrap handling time
        yield self.env.timeout(2.0)

    def _make_simple_decision(self, product: Product) -> SimpleDecision:
        """简化的决策逻辑：最多一次返工"""
        quality_percentage = product.quality_score * 100
        
        # 如果已经返工过一次
        if product.rework_count >= 1:
            # 返工后仍然不合格，直接报废
            if quality_percentage < self.pass_threshold:
                return SimpleDecision.SCRAP
            else:
                return SimpleDecision.PASS
        
        # 首次检测决策
        if quality_percentage >= self.pass_threshold:
            return SimpleDecision.PASS
        elif quality_percentage <= self.scrap_threshold:
            return SimpleDecision.SCRAP
        else:
            # 中间质量，可以返工
            return SimpleDecision.REWORK

    def _get_last_processing_station(self, product: Product) -> str:
        """获取产品最后处理的工站 (排除QualityCheck)"""
        processing_stations = [s for s in product.processing_stations if s != self.id]
        return processing_stations[-1] if processing_stations else ""

    def get_simple_stats(self) -> Dict:
        """获取简化的统计信息"""
        total = self.stats["inspected_count"]
        if total == 0:
            return {"inspected": 0, "pass_rate": 0, "scrap_rate": 0, "rework_rate": 0}
            
        return {
            "inspected": total,
            "passed": self.stats["passed_count"],
            "scrapped": self.stats["scrapped_count"], 
            "reworked": self.stats["reworked_count"],
            "pass_rate": round(self.stats["passed_count"] / total * 100, 1),
            "scrap_rate": round(self.stats["scrapped_count"] / total * 100, 1),
            "rework_rate": round(self.stats["reworked_count"] / total * 100, 1),
            "buffer_level": self.get_buffer_level()
        }

    def reset_stats(self):
        """重置统计数据"""
        self.stats = {
            "inspected_count": 0,
            "total_processing_time": 0.0,
            "average_processing_time": 0.0,
            "passed_count": 0,
            "reworked_count": 0,
            "scrapped_count": 0,
            "working_time": 0.0,  # Total time spent in PROCESSING status
            "start_time": self.env.now  # Track when station started
        }
    
    def pop(self, buffer_type=None):
        """Remove and return a product from the specified buffer.
        
        Args:
            buffer_type: "buffer" for input buffer, "output_buffer" for output buffer
            
        Returns:
            The removed product
        """
        if buffer_type == "output_buffer" or buffer_type is None:
            # 从 output_buffer 取货（默认）
            product = yield self.output_buffer.get()
            msg = f"Product {product.id} taken from {self.id} output_buffer by AGV"
        else:
            # 从输入 buffer 取货，需要检查是否正在处理
            if len(self.buffer.items) > 0 and self.current_product_id == self.buffer.items[0].id:
                raise ValueError(f"Product {self.current_product_id} is currently being processed and cannot be taken")
            
            product = yield self.buffer.get()
            msg = f"Product {product.id} taken from {self.id} input buffer by AGV"
        
        print(f"[{self.env.now:.2f}] 📤 {self.id}: {msg}")
        self.publish_status(msg)
        return product
    
    def add_product_to_outputbuffer(self, product: Product):
        """Add a product to its output buffer (used by AGV for delivery)"""
        yield self.output_buffer.put(product)
        print(f"[{self.env.now:.2f}] 📦 {self.id}: 运出产品 {product.id} 到output buffer")
        return True


================================================
File: src/simulation/entities/station.py
================================================
# simulation/entities/station.py
import simpy
import random
from typing import Dict, Tuple, Optional, Callable

from config.schemas import DeviceStatus, StationStatus
from src.simulation.entities.base import Device
from src.simulation.entities.product import Product
from src.utils.topic_manager import TopicManager
from config.topics import get_station_status_topic

class Station(Device):
    """
    Represents a manufacturing station in the factory.

    Stations have a buffer to hold products and take time to process them.
    Default input buffer capacity is 1 (single-piece flow).
    
    Attributes:
        buffer (simpy.Store): A buffer to hold incoming products.
        buffer_size (int): The maximum capacity of the buffer（default 1）。
        processing_times (Dict[str, Tuple[int, int]]): A dictionary mapping product types
            to a tuple of (min_time, max_time) for processing.
        product_transfer_callback (Callable): Callback function to transfer products to next station
        downstream_conveyor (Conveyor): The conveyor downstream from this station

        # For fault system to record the current product for resume processing
        current_product_id (str): The ID of the current product being processed.
        current_product_start_time (float): The time when the current product started processing.
        current_product_total_time (float): The total time required to process the current product.
        current_product_elapsed_time (float): The elapsed time before the current product was interrupted.
    """
    
    def __init__(
        self,
        env: simpy.Environment,
        id: str,
        position: Tuple[int, int],
        buffer_size: int = 1,
        processing_times: Dict[str, Tuple[int, int]] = {},
        downstream_conveyor=None,
        mqtt_client=None,
        interacting_points: list = [],
        kpi_calculator=None,  # Injected dependency
        topic_manager: Optional[TopicManager] = None,
        line_id: Optional[str] = None
    ):
        super().__init__(env, id, position, device_type="station", mqtt_client=mqtt_client, interacting_points=interacting_points)
        self.topic_manager = topic_manager
        self.line_id = line_id
        self.buffer_size = buffer_size
        self.buffer = simpy.Store(env, capacity=buffer_size)
        self.processing_times = processing_times
        
        # # 工站特定属性初始化
        # self._specific_attributes.update({
        #     "precision_level": random.uniform(95.0, 100.0),  # 加工精度水平
        #     "tool_wear_level": random.uniform(0.0, 20.0),    # 刀具磨损程度
        #     "lubricant_level": random.uniform(80.0, 100.0)   # 润滑油水平
        # })
        
        # 统计数据
        self.stats = {
            "products_processed": 0,
            "total_processing_time": 0.0,
            "average_processing_time": 0.0,
            "working_time": 0.0,  # Total time spent in PROCESSING status
            "start_time": env.now  # Track when station started
        }
        
        self.downstream_conveyor = downstream_conveyor
        self.kpi_calculator = kpi_calculator
        self.last_status_change_time = env.now
        # 产品处理时间跟踪（站点一次只处理一个产品）
        self.current_product_id = None  # 当前正在处理的产品ID
        self.current_product_start_time = None  # 当前产品开始处理的时间
        self.current_product_total_time = None  # 当前产品需要的总处理时间
        self.current_product_elapsed_time = None  # 中断前已经处理的累计时间
        
        # Start the main operational process for the station
        self.env.process(self.run())
        
        # Publish initial status
        self.publish_status("Station initialized")

    def set_status(self, new_status: DeviceStatus, message: Optional[str] = None):
        """Overrides the base method to publish status on change."""
        if self.status == new_status:
            return
        
        # Track working time for KPI
        if self.status == DeviceStatus.PROCESSING:
            processing_duration = self.env.now - self.last_status_change_time
            self.stats["working_time"] += processing_duration
            
            # Update KPI calculator with device utilization
            if self.kpi_calculator:
                self.kpi_calculator.add_energy_cost(self.id, self.line_id, processing_duration)
                self.kpi_calculator.update_device_utilization(self.id, self.line_id, self.env.now - self.stats["start_time"])
        
        self.last_status_change_time = self.env.now
        super().set_status(new_status, message)

    def publish_status(self, message: Optional[str] = None):
        """Publishes the current status of the station to MQTT."""
        if not self.mqtt_client or not self.mqtt_client.is_connected():
            return
            
        status_data = StationStatus(
            timestamp=self.env.now,
            source_id=self.id,
            status=self.status,
            message=message,
            buffer=[p.id for p in self.buffer.items],
            stats=self.stats,
            output_buffer=[]  # 普通工站没有 output_buffer
        )
        if self.topic_manager and self.line_id:
            topic = self.topic_manager.get_station_status_topic(self.line_id, self.id)
        else:
            topic = get_station_status_topic(self.id)
        self.mqtt_client.publish(topic, status_data.model_dump_json(), retain=False)

    def run(self):
        """The main operational loop for the station."""
        while True:
            try:
                # 等待设备可操作且buffer有产品
                yield self.env.process(self._wait_for_ready_state())
                
                # 如果能到这里，说明设备可操作且有产品
                if len(self.buffer.items) > 0:
                    product = self.buffer.items[0]
                    self.action = self.env.process(self.process_product(product))
                    yield self.action
                    
            except simpy.Interrupt:
                # 被中断（通常是故障），继续循环
                continue
    
    def _wait_for_ready_state(self):
        """等待设备处于可操作状态且buffer有产品"""
        while True:
            # 如果buffer为空，等待
            if len(self.buffer.items) == 0:
                yield self.env.timeout(0.1)
                continue

            # 如果设备不可操作，等待
            if not self.can_operate():
                yield self.env.timeout(1)
                continue

            # 设备可操作且有产品，返回
            return

    def process_product(self, product: Product):
        """
        Simulates the entire lifecycle of processing a single product,
        from waiting for it to processing and transferring it.
        Includes robust error handling for interruptions.
        """
        print(f"[{self.env.now:.2f}] [DEBUG] Station {self.id}: process_product started for {product.id}, buffer={len(self.buffer.items)}/{self.buffer.capacity}")
        try:
            # Check if the device can operate
            if not self.can_operate():
                msg = f"[{self.env.now:.2f}] ⚠️  {self.id}: can not process product, device is not available"
                print(msg)
                self.publish_status(msg)
                return

            self.set_status(DeviceStatus.PROCESSING)
            self.publish_status()

            # Record processing start and get processing time
            min_time, max_time = self.processing_times.get(product.product_type, (10, 20))
            processing_time = random.uniform(min_time, max_time)
            
            # 处理中断恢复的逻辑
            if (self.current_product_id == product.id and 
                self.current_product_elapsed_time is not None and
                self.current_product_total_time is not None):
                # 恢复处理：使用之前记录的已处理时间
                elapsed_time = self.current_product_elapsed_time
                remaining_time = max(0, self.current_product_total_time - elapsed_time)
                msg = f"[{self.env.now:.2f}] {self.id}: {product.id} resume processing, elapsed {elapsed_time:.1f}s, remaining {remaining_time:.1f}s"
                print(msg)
                self.publish_status(msg)
                # 重新记录开始时间，但保留累计时间和总时间
                self.current_product_start_time = self.env.now
            else:
                # 第一次开始处理
                self.current_product_id = product.id
                self.current_product_start_time = self.env.now
                self.current_product_total_time = processing_time
                self.current_product_elapsed_time = 0  # 初始化累计时间
                remaining_time = processing_time
                msg = f"[{self.env.now:.2f}] {self.id}: {product.id} start processing, need {processing_time:.1f}s"
                print(msg)
                self.publish_status(msg)
                
                # Mark production start for KPI tracking (only for StationA)
                if self.id == "StationA" and self.kpi_calculator:
                    self.kpi_calculator.mark_production_start(product)
            
            # The actual processing work
            yield self.env.timeout(remaining_time)
            product = yield self.buffer.get()
            product.process_at_station(self.id, self.env.now)

            # Update statistics upon successful completion
            self.stats["products_processed"] += 1
            self.stats["total_processing_time"] += processing_time
            self.stats["average_processing_time"] = (
                self.stats["total_processing_time"] / self.stats["products_processed"]
            )
            
            # Processing finished successfully
            msg = f"[{self.env.now:.2f}] {self.id}: {product.id} finished processing, actual processing time {processing_time:.1f}s"
            print(msg)
            self.publish_status(msg)
            
            # Trigger moving the product to the next stage
            yield self.env.process(self._transfer_product_to_next_stage(product))

        except simpy.Interrupt as e:
            message = f"Processing of product {product.id} was interrupted: {e.cause}"
            print(f"[{self.env.now:.2f}] ⚠️ {self.id}: {message}")
            
            # 记录中断时已经处理的时间
            if self.current_product_start_time is not None:
                elapsed_before_interrupt = self.env.now - self.current_product_start_time
                self.current_product_elapsed_time = (self.current_product_elapsed_time or 0) + elapsed_before_interrupt
                print(f"[{self.env.now:.2f}] 💾 {self.id}: 产品 {product.id} 中断前已处理 {elapsed_before_interrupt:.1f}s，累计 {self.current_product_elapsed_time:.1f}s")
                # 清理开始时间，但保留其他记录
                self.current_product_start_time = None
            
            if product not in self.buffer.items:
                # 产品已取出，说明处理时间已经完成，应该继续流转，但需要等待设备可操作防止覆盖Fault状态
                print(f"[{self.env.now:.2f}] 🚚 {self.id}: 产品 {product.id} 已处理完成，继续流转到下游")
                while not self.can_operate():
                    yield self.env.timeout(1)
                yield self.env.process(self._transfer_product_to_next_stage(product))
                # 清理所有时间记录
                self.current_product_id = None
                self.current_product_start_time = None
                self.current_product_total_time = None
                self.current_product_elapsed_time = None
            else:
                # 产品还在buffer中，说明在timeout期间被中断，等待下次处理
                print(f"[{self.env.now:.2f}] ⏸️  {self.id}: 产品 {product.id} 处理被中断，留在buffer中")
        finally:
            # Clear the action handle once the process is complete or interrupted
            self.action = None
            # 如果产品成功完成处理并转移，清理时间记录
            if self.current_product_id == product.id and product not in self.buffer.items:
                self.current_product_id = None
                self.current_product_start_time = None
                self.current_product_total_time = None
                self.current_product_elapsed_time = None
        print(f"[{self.env.now:.2f}] [DEBUG] Station {self.id}: process_product finished for {product.id}, buffer={len(self.buffer.items)}/{self.buffer.capacity}")

    def _transfer_product_to_next_stage(self, product):
        """Transfer the processed product to the next station or conveyor."""

        if self.downstream_conveyor is None:
            # No downstream, end of process
            return
        
        if self.downstream_conveyor.is_full() or not self.downstream_conveyor.can_operate():
            self.set_status(DeviceStatus.BLOCKED)
            self.publish_status("downstream conveyor is full or run into some issue, station is blocked")

        # TODO: while len(self.downstream_conveyor.buffer.items) >0 //取决于下游堵塞但是没东西时要不要放1个（之前有空位就会放）
        while not self.downstream_conveyor.can_operate() or self.downstream_conveyor.is_full():
            yield self.env.timeout(0.1)

        yield self.downstream_conveyor.push(product)
        
        # Set status back to IDLE after the push operation is complete
        self.set_status(DeviceStatus.IDLE)
        self.publish_status()
        return

    def pop(self):
        """Remove and return the first product from the station's buffer.
        Ensures that the product being processed cannot be taken.
        """
        # 检查第一个产品是否正在被处理
        if len(self.buffer.items) > 0 and self.current_product_id == self.buffer.items[0].id:
            raise ValueError(f"Product {self.current_product_id} is currently being processed and cannot be taken")
        
        # 取出第一个产品
        product = yield self.buffer.get()
        print(f"[{self.env.now:.2f}] [DEBUG] Station {self.id}: pop {product.id}, buffer={len(self.buffer.items)}/{self.buffer.capacity}")
        
        # 发布状态更新
        msg = f"Product {product.id} taken from {self.id} by AGV"
        print(f"[{self.env.now:.2f}] 📤 {self.id}: {msg}")
        self.publish_status(msg)
        return product

    def add_product_to_buffer(self, product: Product):
        """Add a product to the station's buffer"""
        success = False

        try:
            yield self.buffer.put(product)
            msg = f"[{self.env.now:.2f}] 📥 {self.id}: Product {product.id} added to buffer."
            success = True
        except simpy.Interrupt:
            msg = f"[{self.env.now:.2f}] ⚠️ {self.id}: add_product_to_buffer interrupted."
            success = False

        print(msg)
        self.publish_status(msg)
        return success

    def get_buffer_level(self) -> int:
        """获取当前缓冲区产品数量"""
        return len(self.buffer.items)

    def is_full(self):
        return len(self.buffer.items) >= self.buffer_size
    
    def is_empty(self):
        return len(self.buffer.items) == 0
    
    def get_processing_stats(self) -> Dict:
        """获取工站处理统计信息"""
        return {
            **self.stats,
            "buffer_level": self.get_buffer_level(),
            "buffer_utilization": self.get_buffer_level() / self.buffer_size,
            "can_operate": self.can_operate()
        }

    def reset_stats(self):
        """重置统计数据"""
        self.stats = {
            "products_processed": 0,
            "total_processing_time": 0.0,
            "average_processing_time": 0.0
        }
    
    def recover(self):
        """Custom recovery logic for the station."""
        # 清理不在buffer中的产品的时间记录
        if self.current_product_id:
            products_in_buffer = {p.id for p in self.buffer.items}
            if self.current_product_id not in products_in_buffer:
                print(f"[{self.env.now:.2f}] 🗑️ Station {self.id}: 清理过期产品 {self.current_product_id} 的时间记录")
                self.current_product_id = None
                self.current_product_start_time = None
                self.current_product_total_time = None
                self.current_product_elapsed_time = None
        
        # 只有当设备处于FAULT状态时才恢复
        if self.status == DeviceStatus.FAULT:
            self.set_status(DeviceStatus.IDLE)
            msg = f"[{self.env.now:.2f}] ✅ Station {self.id} is recovered."
            print(msg)
            self.publish_status(msg)
        else:
            # 如果设备不是FAULT状态，只打印恢复尝试的信息
            msg = f"[{self.env.now:.2f}] ℹ️ Station {self.id}: Recovery attempted, but status is {self.status.value}, not changing."
            print(msg)




================================================
File: src/simulation/entities/warehouse.py
================================================
# simulation/entities/warehouse.py
import simpy
import random
from typing import Dict, Tuple, Optional

from src.simulation.entities.base import Device
from src.simulation.entities.product import Product
from config.schemas import WarehouseStatus
from config.topics import get_warehouse_status_topic
from src.utils.topic_manager import TopicManager

class BaseWarehouse(Device):
    """Base class for all warehouse types, inheriting from Device."""

    def __init__(
        self,
        env: simpy.Environment,
        id: str,
        position: Tuple[int, int],
        mqtt_client=None,
        interacting_points: list = [],
        topic_manager: Optional[TopicManager] = None,
        line_id: Optional[str] = None,
        **kwargs # Absorb other config values
    ):
        super().__init__(env, id, position, device_type="warehouse", mqtt_client=mqtt_client)
        self.buffer = simpy.Store(env)
        self.interacting_points = interacting_points
        self.stats = {}  # To be overridden by subclasses
        self.topic_manager = topic_manager
        self.line_id = line_id

    def publish_status(self, message: str = "Warehouse is ready"):
        """Publishes the current status of the warehouse to MQTT."""
        if not self.mqtt_client or not self.mqtt_client.is_connected():
            return
        status_data = WarehouseStatus(
            timestamp=self.env.now,
            source_id=self.id,
            message=message,
            buffer=[p.id for p in self.buffer.items],
            stats=self.stats
        )
        if self.topic_manager:
            topic = self.topic_manager.get_warehouse_status_topic(self.id)
        else:
            topic = get_warehouse_status_topic(self.id)
        self.mqtt_client.publish(topic, status_data.model_dump_json(), retain=False)

    def get_buffer_level(self) -> int:
        """Return the current number of items in the buffer."""
        return len(self.buffer.items)
    
    def pop(self, product_id: Optional[str] = None):
        """
        Remove and return a product from the warehouse buffer.
        If product_id is specified, remove the product with that id.
        Otherwise, remove the first product in the buffer.
        """
        if product_id:
            # Try to find and remove the product with the specified id
            for idx, p in enumerate(self.buffer.items):
                if p.id == product_id:
                    product = self.buffer.items.pop(idx)
                    print(f"[{self.env.now:.2f}] 📤 {self.id}: Product {product.id} taken from warehouse buffer.")
                    break
            else:
                # If not found, raise an error
                raise ValueError(f"Product with id {product_id} not found in warehouse buffer.")
        else:
            product = yield self.buffer.get()
            print(f"[{self.env.now:.2f}] 📤 {self.id}: Default Product taken from warehouse buffer.")

        # 发布状态更新
        msg = f"Product {product.id} taken from {self.id} by AGV"
        print(f"[{self.env.now:.2f}] 📤 {self.id}: {msg}")
        self.publish_status(msg)
        return product

    def run(self):
        """Warehouses don't process products, just idle loop."""
        while True:
            yield self.env.timeout(60)  # Check every minute

class RawMaterial(BaseWarehouse):
    """Raw material warehouse - the starting point of the production line"""

    def __init__(
        self,
        env: simpy.Environment,
        mqtt_client=None,
        kpi_calculator=None,
        **config
    ):
        super().__init__(env=env, mqtt_client=mqtt_client, **config)
        self.device_type = "raw_material"  # Override device type
        self.kpi_calculator = kpi_calculator
        self.stats = {
            "total_materials_supplied": 0,
            "product_type_summary": {"P1": 0, "P2": 0, "P3": 0}
        }
        print(f"[{self.env.now:.2f}] 🏭 {self.id}: Raw material warehouse is ready")
        self.publish_status("Raw material warehouse is ready")

    def create_raw_material(self, product_type: str, order_id: str) -> Product:
        """Create raw material product"""
        product = Product(product_type, order_id)
        self.stats["total_materials_supplied"] += 1
        self.stats["product_type_summary"][product_type] += 1
        product.add_history(self.env.now, f"Raw material created at {self.id}")
        print(f"[{self.env.now:.2f}] 🔧 {self.id}: Create raw material {product.id} (type: {product_type})")
        self.buffer.put(product)
        self.publish_status(f"Supply raw material {product.id} (type: {product_type}) since order {order_id} is created")
        return product

    def pop(self, product_id: Optional[str] = None):
        """
        Override parent's pop method to add material cost calculation.
        Material cost is added when product is taken from raw material warehouse.
        """
        # First get the product using parent's pop method
        product = yield from super().pop(product_id)
        
        # Add material cost to KPI when product is taken
        if self.kpi_calculator and hasattr(product, 'product_type'):
            material_cost = self.kpi_calculator.cost_parameters['material_cost_per_product'].get(
                product.product_type, 10.0  # Default to P1 cost if not found
            )
            self.kpi_calculator.stats.material_costs += material_cost
            
            # Also update the order tracking if it exists
            if hasattr(product, 'order_id') and product.order_id in self.kpi_calculator.active_orders:
                order_tracking = self.kpi_calculator.active_orders[product.order_id]
                order_tracking.total_cost += material_cost
            
            print(f"[{self.env.now:.2f}] 💰 {self.id}: Added material cost ${material_cost:.2f} for {product.product_type}")
            
            # Trigger KPI update
            self.kpi_calculator._check_and_publish_kpi_update()
        
        return product

    def is_full(self) -> bool:
        # return self.get_buffer_level() >= self.buffer_size
        return False

class Warehouse(BaseWarehouse):
    """Finished product warehouse - the ending point of the production line"""

    def __init__(
        self,
        env: simpy.Environment,
        mqtt_client=None,
        **config
    ):
        super().__init__(env=env, mqtt_client=mqtt_client, **config)
        self.stats = {
            "total_products_received": 0,
            "product_type_summary": {"P1": 0, "P2": 0, "P3": 0},
        }
        print(f"[{self.env.now:.2f}] 🏪 {self.id}: Finished product warehouse is ready")
        self.publish_status("Warehouse is ready")

    def add_product_to_buffer(self, product: Product):
        """AGV put product to warehouse"""
        yield self.buffer.put(product)
        self.publish_status(f"Store finished product {product.id} (type: {product.product_type})")
        self.stats["total_products_received"] += 1
        self.stats["product_type_summary"][product.product_type] += 1
        product.add_history(self.env.now, f"Stored in warehouse {self.id}")
        print(f"[{self.env.now:.2f}] 📦 {self.id}: Store finished product {product.id} (type: {product.product_type})")
        return True
    
    def is_full(self) -> bool:
        # return self.get_buffer_level() >= self.buffer_size
        return False



================================================
File: src/utils/config_loader.py
================================================
"""
Configuration loader for SUPCON Factory Simulation
Loads configuration from YAML files and provides typed access to configuration data.
"""

import yaml
from pathlib import Path
from typing import Dict, Any, Optional

class ConfigLoader:
    """simplified config loader - load yaml file to dict"""
    
    def __init__(self, config_dir: str = "config"):
        self.config_dir = Path(config_dir)
    
    def load_factory_layout(self, config_file_name: str = "factory_layout.yml") -> Dict[str, Any]:
        """load factory layout from yaml file"""
        config_file = self.config_dir / config_file_name
        
        if not config_file.exists():
            raise FileNotFoundError(f"Configuration file not found: {config_file}")
        
        with open(config_file, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        
        # # simple validation for required fields
        # required_sections = ['stations', 'agvs', 'conveyors', 'warehouses']
        # for section in required_sections:
        #     if section not in config:
        #         raise ValueError(f"Missing required section: {section}")
        
        return config

# global config loader instance
_config_loader: Optional[ConfigLoader] = None

def get_config_loader() -> ConfigLoader:
    """get global config loader instance"""
    global _config_loader
    if _config_loader is None:
        _config_loader = ConfigLoader()
    return _config_loader

def load_factory_config(config_file_name: str = "factory_layout.yml") -> Dict[str, Any]:
    """convenient function - load factory config"""
    return get_config_loader().load_factory_layout(config_file_name)


================================================
File: src/utils/mqtt_client.py
================================================
# utils/mqtt_client.py
import logging
import paho.mqtt.client as mqtt
from typing import Callable, Optional
from pydantic import BaseModel

# Configure logger
logger = logging.getLogger(__name__)

class MQTTClient:
    """
    A robust wrapper for the paho-mqtt client providing easy-to-use
    methods for connecting, publishing, and subscribing.
    """

    def __init__(self, host: str, port: int, client_id: str = ""):
        self._host = host
        self._port = port
        # NOTE: The client_id is passed as the first argument for compatibility.
        self._client = mqtt.Client(client_id=client_id)
            
        self._client.on_connect = self._on_connect
        self._client.on_disconnect = self._on_disconnect
        self._client.on_message = self._on_message
        self._message_callbacks = {}

    def _on_connect(self, client, userdata, flags, reason_code, properties=None):
        if reason_code == 0:
            logger.info(f"Successfully connected to MQTT Broker at {self._host}:{self._port}")
        else:
            logger.error(f"Failed to connect to MQTT Broker, reason code: {reason_code}")

    def _on_disconnect(self, client, userdata, reason_code, properties=None):
        logger.warning(f"Disconnected from MQTT Broker with reason code: {reason_code}. Reconnecting...")

    def _on_message(self, client, userdata, msg):
        """
        Internal callback to route messages to the appropriate topic-specific callback.
        """
        logger.debug(f"Received message on topic {msg.topic}")
        # Iterate over subscribed topics and check for a match
        for topic_filter, callback in self._message_callbacks.items():
            if mqtt.topic_matches_sub(topic_filter, msg.topic):
                callback(msg.topic, msg.payload)
                break
        else:
            logger.warning(f"No callback registered for message on topic {msg.topic}")

    def connect(self):
        """
        Connects to the MQTT broker and starts the network loop in a separate thread.
        """
        try:
            logger.info(f"Connecting to MQTT Broker at {self._host}:{self._port}...")
            self._client.connect(self._host, self._port, 60)
            self._client.loop_start()
        except Exception as e:
            logger.error(f"Error connecting to MQTT Broker: {e}")
            raise

    def disconnect(self):
        """
        Stops the network loop and disconnects from the MQTT broker.
        """
        logger.info("Disconnecting from MQTT Broker.")
        self._client.loop_stop()
        self._client.disconnect()

    def subscribe(self, topic: str, callback: Callable[[str, bytes], None], qos: int = 0):
        """
        Subscribes to a topic and registers a callback for incoming messages.

        Args:
            topic (str): The topic to subscribe to (can include wildcards).
            callback (Callable): A function to call when a message is received.
                                 The callback should accept (topic, payload).
            qos (int): The Quality of Service level for the subscription.
        """
        if not callable(callback):
            raise TypeError("Callback must be a callable function")
            
        logger.info(f"Subscribing to topic: {topic}")
        self._message_callbacks[topic] = callback
        self._client.subscribe(topic, qos)

    def publish(self, topic: str, payload: str | BaseModel, qos: int = 1, retain: bool = False):
        """
        Publishes a message to a topic.

        Args:
            topic (str): The topic to publish to.
            payload (str | BaseModel): The message payload. If it's a Pydantic BaseModel,
                                       it will be automatically converted to a JSON string.
            qos (int): The Quality of Service level for the message.
            retain (bool): Whether the message should be retained by the broker.
        """
        if isinstance(payload, BaseModel):
            message = payload.model_dump_json()
        elif isinstance(payload, str):
            message = payload
        else:
            message = str(payload)
            # raise TypeError("Payload must be a string or a Pydantic BaseModel")

        logger.debug(f"Publishing to topic '{topic}': {message}")
        result = self._client.publish(topic, message, qos, retain)
        if result.rc != mqtt.MQTT_ERR_SUCCESS:
            logger.error(f"Failed to publish to topic {topic}: {mqtt.error_string(result.rc)}") 

    def is_connected(self):
        return self._client.is_connected()


================================================
File: src/utils/safe_output.py
================================================
"""
Safe output utilities to handle BrokenPipeError when using pipes
"""
import sys

def safe_print(*args, **kwargs):
    """
    Safe print function that handles BrokenPipeError when output is piped
    """
    try:
        print(*args, **kwargs)
    except BrokenPipeError:
        # When piped to head/tail, ignore broken pipe errors
        sys.stderr.close()
    except KeyboardInterrupt:
        sys.exit(1) 


================================================
File: src/utils/topic_manager.py
================================================
# src/utils/topic_manager.py
import os
from typing import Dict, Optional

class TopicManager:
    """
    Manages the generation of all MQTT topics for the simulation.
    It ensures a consistent topic structure based on a root name.
    """
    def __init__(self, player_name: str):
        """
        Initializes the TopicManager with a root topic name.
        Args:
            player_name: The root name for all topics, typically the player's or team's name.
        """
        if not player_name or not isinstance(player_name, str) or "/" in player_name:
            raise ValueError("Player name cannot be empty or contain '/'")
        self.root = player_name
        print(f"✅ TopicManager initialized with root topic: '{self.root}'")

    def get_station_status_topic(self, line_id: str, device_id: str) -> str:
        """Generates topic for device status updates."""
        # device_id from Line class is already line_x_device_y, so we can just use it
        return f"{self.root}/{line_id}/station/{device_id}/status"

    def get_conveyor_status_topic(self, line_id: str, device_id: str) -> str:
        """Generates topic for device status updates."""
        # device_id from Line class is already line_x_device_y, so we can just use it
        return f"{self.root}/{line_id}/conveyor/{device_id}/status"

    def get_warehouse_status_topic(self, device_id: str) -> str:
        """Generates topic for device status updates."""
        # device_id from Line class is already line_x_device_y, so we can just use it
        return f"{self.root}/warehouse/{device_id}/status"

    def get_agv_status_topic(self, line_id: str, agv_id: str) -> str:
        """Generates topic for AGV status updates."""
        return f"{self.root}/{line_id}/agv/{agv_id}/status"

    def get_order_topic(self) -> str:
        """Generates topic for new order announcements."""
        return f"{self.root}/orders/status"

    def get_fault_alert_topic(self, line_id: str) -> str:
        """Generates topic for fault alerts."""
        return f"{self.root}/{line_id}/alerts"
        
    def get_kpi_topic(self) -> str:
        """Generates topic for factory-wide KPI updates."""
        return f"{self.root}/kpi/status"
    
    def get_result_topic(self) -> str:
        """Generates topic for factory-wide result updates."""
        return f"{self.root}/result/status"

    def get_agent_command_topic_wildcard(self) -> str:
        """Generates a wildcard topic for agent commands for all lines."""
        return f"{self.root}/command/+"

    def get_agent_command_topic(self, line_id: str) -> str:
        """Generates the specific command topic for a given line."""
        return f"{self.root}/command/{line_id}"

    def parse_agent_command_topic(self, topic: str) -> Optional[Dict[str, str]]:
        """
        Parses an agent command topic to extract line_id.
        Expected format: {root}/command/{line_id}
        """
        parts = topic.split('/')
        if len(parts) == 3 and parts[0] == self.root and parts[1] == "command":
            return {
                "line_id": parts[2]
            }
        return None

    def get_agent_response_topic(self, line_id: Optional[str]) -> str:
        """Generates the response topic for agent commands."""
        if line_id:
            return f"{self.root}/response/{line_id}"
        else:
            return f"{self.root}/response/general"





================================================
File: unity/index.html
================================================
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity WebGL Player | SimPyUnity</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
  </head>
  <body>
    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas" width=1980 height=1080 tabindex="-1"></canvas>
      <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
          <div id="unity-progress-bar-full"></div>
        </div>
      </div>
      <div id="unity-warning"> </div>
      <div id="unity-footer">
        <div id="unity-webgl-logo"></div>
        <div id="unity-fullscreen-button"></div>
        <div id="unity-build-title">SimPyUnity</div>
      </div>
    </div>
    <script>

      var container = document.querySelector("#unity-container");
      var canvas = document.querySelector("#unity-canvas");
      var loadingBar = document.querySelector("#unity-loading-bar");
      var progressBarFull = document.querySelector("#unity-progress-bar-full");
      var fullscreenButton = document.querySelector("#unity-fullscreen-button");
      var warningBanner = document.querySelector("#unity-warning");

      // Shows a temporary message banner/ribbon for a few seconds, or
      // a permanent error message on top of the canvas if type=='error'.
      // If type=='warning', a yellow highlight color is used.
      // Modify or remove this function to customize the visually presented
      // way that non-critical warnings and error messages are presented to the
      // user.
      function unityShowBanner(msg, type) {
        function updateBannerVisibility() {
          warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
        }
        var div = document.createElement('div');
        div.innerHTML = msg;
        warningBanner.appendChild(div);
        if (type == 'error') div.style = 'background: red; padding: 10px;';
        else {
          if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
          setTimeout(function() {
            warningBanner.removeChild(div);
            updateBannerVisibility();
          }, 5000);
        }
        updateBannerVisibility();
      }

      var buildUrl = "Build";
      var loaderUrl = buildUrl + "/SimPy.loader.js";
      var config = {
        dataUrl: buildUrl + "/SimPy.data.unityweb",
        frameworkUrl: buildUrl + "/SimPy.framework.js.unityweb",
        codeUrl: buildUrl + "/SimPy.wasm.unityweb",
        streamingAssetsUrl: "StreamingAssets",
        companyName: "DefaultCompany",
        productName: "SimPyUnity",
        productVersion: "0.1.0",
        showBanner: unityShowBanner,
      };

      // By default, Unity keeps WebGL canvas render target size matched with
      // the DOM size of the canvas element (scaled by window.devicePixelRatio)
      // Set this to false if you want to decouple this synchronization from
      // happening inside the engine, and you would instead like to size up
      // the canvas DOM size and WebGL render target sizes yourself.
      // config.matchWebGLToCanvasSize = false;

      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        // Mobile device style: fill the whole browser client area with the game canvas:

        var meta = document.createElement('meta');
        meta.name = 'viewport';
        meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        document.getElementsByTagName('head')[0].appendChild(meta);
        container.className = "unity-mobile";
        canvas.className = "unity-mobile";

        // To lower canvas resolution on mobile devices to gain some
        // performance, uncomment the following line:
        // config.devicePixelRatio = 1;


      } else {
        // Desktop style: Render the game canvas in a window that can be maximized to fullscreen:

        canvas.style.width = "1980px";
        canvas.style.height = "1080px";
      }

      loadingBar.style.display = "block";

      var script = document.createElement("script");
      script.src = loaderUrl;
      script.onload = () => {
        createUnityInstance(canvas, config, (progress) => {
          progressBarFull.style.width = 100 * progress + "%";
              }).then((unityInstance) => {
                loadingBar.style.display = "none";
                fullscreenButton.onclick = () => {
                  unityInstance.SetFullscreen(1);
                };
              }).catch((message) => {
                alert(message);
              });
            };

      document.body.appendChild(script);

    </script>
  </body>
</html>



================================================
File: unity/Build/SimPy.data.unityweb
================================================
[Non-text file]


================================================
File: unity/Build/SimPy.framework.js.unityweb
================================================
[Non-text file]


================================================
File: unity/Build/SimPy.loader.js
================================================
function createUnityInstance(t,n,d){function c(e,t){if(!c.aborted&&n.showBanner)return"error"==t&&(c.aborted=!0),n.showBanner(e,t);switch(t){case"error":console.error(e);break;case"warning":console.warn(e);break;default:console.log(e)}}function r(e){var t=e.reason||e.error,n=t?t.toString():e.message||e.reason||"",r=t&&t.stack?t.stack.toString():"";(n+="\n"+(r=r.startsWith(n)?r.substring(n.length):r).trim())&&f.stackTraceRegExp&&f.stackTraceRegExp.test(n)&&E(n,e.filename||t&&(t.fileName||t.sourceURL)||"",e.lineno||t&&(t.lineNumber||t.line)||0)}function e(e,t,n){var r=e[t];void 0!==r&&r||(console.warn('Config option "'+t+'" is missing or empty. Falling back to default value: "'+n+'". Consider updating your WebGL template to include the missing config option.'),e[t]=n)}d=d||function(){};var o,f={canvas:t,webglContextAttributes:{preserveDrawingBuffer:!1,powerPreference:2},cacheControl:function(e){return e==f.dataUrl||e.match(/\.bundle/)?"must-revalidate":"no-store"},streamingAssetsUrl:"StreamingAssets",downloadProgress:{},deinitializers:[],intervals:{},setInterval:function(e,t){e=window.setInterval(e,t);return this.intervals[e]=!0,e},clearInterval:function(e){delete this.intervals[e],window.clearInterval(e)},preRun:[],postRun:[],print:function(e){console.log(e)},printErr:function(e){console.error(e),"string"==typeof e&&-1!=e.indexOf("wasm streaming compile failed")&&(-1!=e.toLowerCase().indexOf("mime")?c('HTTP Response Header "Content-Type" configured incorrectly on the server for file '+f.codeUrl+' , should be "application/wasm". Startup time performance will suffer.',"warning"):c('WebAssembly streaming compilation failed! This can happen for example if "Content-Encoding" HTTP header is incorrectly enabled on the server for file '+f.codeUrl+", but the file is not pre-compressed on disk (or vice versa). Check the Network tab in browser Devtools to debug server header configuration.","warning"))},locateFile:function(e){return e},disabledCanvasEvents:["contextmenu","dragstart"]};for(o in e(n,"companyName","Unity"),e(n,"productName","WebGL Player"),e(n,"productVersion","1.0"),n)f[o]=n[o];f.streamingAssetsUrl=new URL(f.streamingAssetsUrl,document.URL).href;var i=f.disabledCanvasEvents.slice();function a(e){e.preventDefault()}i.forEach(function(e){t.addEventListener(e,a)}),window.addEventListener("error",r),window.addEventListener("unhandledrejection",r);var s="",u="";function l(e){document.webkitCurrentFullScreenElement===t?t.style.width&&(s=t.style.width,u=t.style.height,t.style.width="100%",t.style.height="100%"):s&&(t.style.width=s,t.style.height=u,u=s="")}document.addEventListener("webkitfullscreenchange",l),f.deinitializers.push(function(){for(var e in f.disableAccessToMediaDevices(),i.forEach(function(e){t.removeEventListener(e,a)}),window.removeEventListener("error",r),window.removeEventListener("unhandledrejection",r),document.removeEventListener("webkitfullscreenchange",l),f.intervals)window.clearInterval(e);f.intervals={}}),f.QuitCleanup=function(){for(var e=0;e<f.deinitializers.length;e++)f.deinitializers[e]();f.deinitializers=[],"function"==typeof f.onQuit&&f.onQuit()};var h,p,w,m,b,v,y,g,x,U={Module:f,SetFullscreen:function(){if(f.SetFullscreen)return f.SetFullscreen.apply(f,arguments);f.print("Failed to set Fullscreen mode: Player not loaded yet.")},SendMessage:function(){if(f.SendMessage)return f.SendMessage.apply(f,arguments);f.print("Failed to execute SendMessage: Player not loaded yet.")},Quit:function(){return new Promise(function(e,t){f.shouldQuit=!0,f.onQuit=e})},GetMemoryInfo:function(){var e=f._getMemInfo();return{totalWASMHeapSize:f.HEAPU32[e>>2],usedWASMHeapSize:f.HEAPU32[1+(e>>2)],totalJSHeapSize:f.HEAPF64[1+(e>>3)],usedJSHeapSize:f.HEAPF64[2+(e>>3)]}}};function E(e,t,n){-1==e.indexOf("fullscreen error")&&(f.startupErrorHandler?f.startupErrorHandler(e,t,n):f.errorHandler&&f.errorHandler(e,t,n)||(console.log("Invoking error handler due to\n"+e),"function"==typeof dump&&dump("Invoking error handler due to\n"+e),E.didShowErrorMessage||(-1!=(e="An error occurred running the Unity content on this page. See your browser JavaScript console for more info. The error was:\n"+e).indexOf("DISABLE_EXCEPTION_CATCHING")?e="An exception has occurred, but exception handling has been disabled in this build. If you are the developer of this content, enable exceptions in your project WebGL player settings to be able to catch the exception or see the stack trace.":-1!=e.indexOf("Cannot enlarge memory arrays")?e="Out of memory. If you are the developer of this content, try allocating more memory to your WebGL build in the WebGL player settings.":-1==e.indexOf("Invalid array buffer length")&&-1==e.indexOf("Invalid typed array length")&&-1==e.indexOf("out of memory")&&-1==e.indexOf("could not allocate memory")||(e="The browser could not allocate enough memory for the WebGL content. If you are the developer of this content, try allocating less memory to your WebGL build in the WebGL player settings."),alert(e),E.didShowErrorMessage=!0)))}function W(e,t){if("symbolsUrl"!=e){var n=f.downloadProgress[e],r=(n=n||(f.downloadProgress[e]={started:!1,finished:!1,lengthComputable:!1,total:0,loaded:0}),"object"!=typeof t||"progress"!=t.type&&"load"!=t.type||(n.started||(n.started=!0,n.lengthComputable=t.lengthComputable),n.total=t.total,n.loaded=t.loaded,"load"==t.type&&(n.finished=!0)),0),o=0,i=0,a=0,s=0;for(e in f.downloadProgress){if(!(n=f.downloadProgress[e]).started)return;i++,n.lengthComputable?(r+=n.loaded,o+=n.total,a++):n.finished||s++}d(.9*(i?(i-s-(o?a*(o-r)/o:0))/i:0))}}function O(){var e=this;this.isConnected=this.connect().then(function(){return e.cleanUpCache()}),this.isConnected.catch(function(e){e="Error when initializing cache: "+e,console.log("[UnityCache] "+e)})}function k(e){console.log("[UnityCache] "+e)}function B(e){return B.link=B.link||document.createElement("a"),B.link.href=e,B.link.href}f.SystemInfo=function(){var e,t,n,r,o=navigator.userAgent+" ",i=[["Firefox","Firefox"],["OPR","Opera"],["Edg","Edge"],["SamsungBrowser","Samsung Browser"],["Trident","Internet Explorer"],["MSIE","Internet Explorer"],["Chrome","Chrome"],["CriOS","Chrome on iOS Safari"],["FxiOS","Firefox on iOS Safari"],["Safari","Safari"]];function a(e,t,n){return(e=RegExp(e,"i").exec(t))&&e[n]}for(var s=0;s<i.length;++s)if(t=a(i[s][0]+"[/ ](.*?)[ \\)]",o,1)){e=i[s][1];break}"Safari"==e&&(t=a("Version/(.*?) ",o,1)),"Internet Explorer"==e&&(t=a("rv:(.*?)\\)? ",o,1)||t);for(var d=[["Windows (.*?)[;)]","Windows"],["Android ([0-9_.]+)","Android"],["iPhone OS ([0-9_.]+)","iPhoneOS"],["iPad.*? OS ([0-9_.]+)","iPadOS"],["FreeBSD( )","FreeBSD"],["OpenBSD( )","OpenBSD"],["Linux|X11()","Linux"],["Mac OS X ([0-9_\\.]+)","MacOS"],["bot|google|baidu|bing|msn|teoma|slurp|yandex","Search Bot"]],c=0;c<d.length;++c)if(f=a(d[c][0],o,1)){n=d[c][1],f=f.replace(/_/g,".");break}var u,f={"NT 5.0":"2000","NT 5.1":"XP","NT 5.2":"Server 2003","NT 6.0":"Vista","NT 6.1":"7","NT 6.2":"8","NT 6.3":"8.1","NT 10.0":"10"}[f]||f,l=((l=document.createElement("canvas"))&&(u=(h=l.getContext("webgl2"))?2:0,h||(h=l&&l.getContext("webgl"))&&(u=1),h&&(r=h.getExtension("WEBGL_debug_renderer_info")&&h.getParameter(37446)||h.getParameter(7937))),"undefined"!=typeof SharedArrayBuffer),h="object"==typeof WebAssembly&&"function"==typeof WebAssembly.compile;return{width:screen.width,height:screen.height,userAgent:o.trim(),browser:e||"Unknown browser",browserVersion:t||"Unknown version",mobile:/Mobile|Android|iP(ad|hone)/.test(navigator.appVersion),os:n||"Unknown OS",osVersion:f||"Unknown OS Version",gpu:r||"Unknown GPU",language:navigator.userLanguage||navigator.language,hasWebGL:u,hasCursorLock:!!document.body.requestPointerLock,hasFullscreen:!!document.body.requestFullscreen||!!document.body.webkitRequestFullscreen,hasThreads:l,hasWasm:h,hasWasmThreads:!1}}(),f.abortHandler=function(e){return E(e,"",0),!0},Error.stackTraceLimit=Math.max(Error.stackTraceLimit||0,50),f.readBodyWithProgress=function(i,a,s){var e=i.body?i.body.getReader():void 0,d=void 0!==i.headers.get("Content-Length"),c=function(e,t){if(!t)return 0;var t=e.headers.get("Content-Encoding"),n=parseInt(e.headers.get("Content-Length"));switch(t){case"br":return Math.round(5*n);case"gzip":return Math.round(4*n);default:return n}}(i,d),u=new Uint8Array(c),f=[],l=0,h=0;return d||console.warn("[UnityCache] Response is served without Content-Length header. Please reconfigure server to include valid Content-Length for better download performance."),function o(){return void 0===e?i.arrayBuffer().then(function(e){var t=new Uint8Array(e);return a({type:"progress",response:i,total:e.length,loaded:0,lengthComputable:d,chunk:s?t:null}),t}):e.read().then(function(e){if(e.done){if(l===c)return u;if(l<c)return u.slice(0,l);for(var t=new Uint8Array(l),n=(t.set(u,0),h),r=0;r<f.length;++r)t.set(f[r],n),n+=f[r].length;return t}return l+e.value.length<=u.length?(u.set(e.value,l),h=l+e.value.length):f.push(e.value),l+=e.value.length,a({type:"progress",response:i,total:Math.max(c,l),loaded:l,lengthComputable:d,chunk:s?e.value:null}),o()})}().then(function(e){return a({type:"load",response:i,total:e.length,loaded:e.length,lengthComputable:d,chunk:null}),i.parsedBody=e,i})},f.fetchWithProgress=function(e,t){var n=function(){};return t&&t.onProgress&&(n=t.onProgress),fetch(e,t).then(function(e){return f.readBodyWithProgress(e,n,t.enableStreamingDownload)})},f.UnityCache=(h={name:"UnityCache",version:4},p={name:"RequestMetaDataStore",version:1},w="RequestStore",m="WebAssembly",b=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,v=null,O.getInstance=function(){return v=v||new O},O.destroyInstance=function(){return v?v.close().then(function(){v=null}):Promise.resolve()},O.prototype.clearCache=function(){var r=this;return this.isConnected.then(function(){return r.execute(p.name,"clear",[])}).then(function(){return r.cache.keys()}).then(function e(t){var n;return 0===t.length?Promise.resolve():(n=t.pop(),r.cache.delete(n).then(function(){return e(t)}))})},O.UnityCacheDatabase=h,O.RequestMetaDataStore=p,O.MaximumCacheSize=1073741824,O.prototype.loadRequest=function(e){var t=this;return t.isConnected.then(function(){return Promise.all([t.cache.match(e),t.loadRequestMetaData(e)])}).then(function(e){if(void 0!==e[0]&&void 0!==e[1])return{response:e[0],metaData:e[1]}})},O.prototype.loadRequestMetaData=function(e){e="string"==typeof e?e:e.url;return this.execute(p.name,"get",[e])},O.prototype.updateRequestMetaData=function(e){return this.execute(p.name,"put",[e])},O.prototype.storeRequest=function(e,t){var n=this;return n.isConnected.then(function(){return n.cache.put(e,t)})},O.prototype.close=function(){return this.isConnected.then(function(){this.database&&(this.database.close(),this.database=null),this.cache&&(this.cache=null)}.bind(this))},O.prototype.connect=function(){var o=this;return void 0===b?Promise.reject(new Error("Could not connect to cache: IndexedDB is not supported.")):void 0===window.caches?Promise.reject(new Error("Could not connect to cache: Cache API is not supported.")):new Promise(function(t,n){try{function r(){o.openDBTimeout&&(clearTimeout(o.openDBTimeout),o.openDBTimeout=null)}o.openDBTimeout=setTimeout(function(){void 0===o.database&&n(new Error("Could not connect to cache: Database timeout."))},2e4);var e=b.open(h.name,h.version);e.onupgradeneeded=o.upgradeDatabase.bind(o),e.onsuccess=function(e){r(),o.database=e.target.result,t()},e.onerror=function(e){r(),o.database=null,n(new Error("Could not connect to database."))}}catch(e){r(),o.database=null,o.cache=null,n(new Error("Could not connect to cache: Could not connect to database."))}}).then(function(){var e=h.name+"_"+f.companyName+"_"+f.productName;return caches.open(e)}).then(function(e){o.cache=e})},O.prototype.upgradeDatabase=function(e){var t,e=e.target.result;e.objectStoreNames.contains(p.name)||(t=e.createObjectStore(p.name,{keyPath:"url"}),["accessedAt","updatedAt"].forEach(function(e){t.createIndex(e,e)})),e.objectStoreNames.contains(w)&&e.deleteObjectStore(w),e.objectStoreNames.contains(m)&&e.deleteObjectStore(m)},O.prototype.execute=function(i,a,s){return this.isConnected.then(function(){return new Promise(function(t,n){try{var e,r,o;null===this.database?n(new Error("indexedDB access denied")):(e=-1!=["put","delete","clear"].indexOf(a)?"readwrite":"readonly",r=this.database.transaction([i],e).objectStore(i),"openKeyCursor"==a&&(r=r.index(s[0]),s=s.slice(1)),(o=r[a].apply(r,s)).onsuccess=function(e){t(e.target.result)},o.onerror=function(e){n(e)})}catch(e){n(e)}}.bind(this))}.bind(this))},O.prototype.getMetaDataEntries=function(){var r=this,o=0,i=[];return new Promise(function(t,n){var e=r.database.transaction([p.name],"readonly").objectStore(p.name).openCursor();e.onsuccess=function(e){e=e.target.result;e?(o+=e.value.size,i.push(e.value),e.continue()):t({metaDataEntries:i,cacheSize:o})},e.onerror=function(e){n(e)}})},O.prototype.cleanUpCache=function(){var a=this;return this.getMetaDataEntries().then(function(e){for(var t=e.metaDataEntries,n=e.cacheSize,r=[],o=[],i=0;i<t.length;++i)t[i].version==f.productVersion?o.push(t[i]):(r.push(t[i]),n-=t[i].size);o.sort(function(e,t){return e.accessedAt-t.accessedAt});for(i=0;i<o.length&&!(n<O.MaximumCacheSize);++i)r.push(o[i]),n-=o[i].size;return function e(){var t;return 0===r.length?Promise.resolve():(t=r.pop(),a.cache.delete(t.url).then(function(e){if(e)return r=t.url,new Promise(function(e,t){var n=a.database.transaction([p.name],"readwrite");n.objectStore(p.name).delete(r),n.oncomplete=e,n.onerror=t});var r}).then(e))}()})},O),f.cachedFetch=(y=f.UnityCache,g=f.fetchWithProgress,x=f.readBodyWithProgress,function(o,i){var e,t,a=y.getInstance(),s=B("string"==typeof o?o:o.url),d={enabled:(e=s,(!(t=i)||!t.method||"GET"===t.method)&&((!t||-1!=["must-revalidate","immutable"].indexOf(t.control))&&!!e.match("^https?://")))};function c(n,r){return fetch(n,r).then(function(e){var t;return!d.enabled||d.revalidated?e:304===e.status?(d.revalidated=!0,a.updateRequestMetaData(d.metaData).then(function(){k("'"+d.metaData.url+"' successfully revalidated and served from the indexedDB cache")}).catch(function(e){k("'"+d.metaData.url+"' successfully revalidated but not stored in the indexedDB cache due to the error: "+e)}),x(d.response,r.onProgress,r.enableStreamingDownload)):200==e.status?(d.response=e,d.metaData.updatedAt=d.metaData.accessedAt,d.revalidated=!0,t=e.clone(),x(e,r.onProgress,r.enableStreamingDownload).then(function(e){return d.metaData.size=e.parsedBody.length,Promise.all([a.storeRequest(n,t),a.updateRequestMetaData(d.metaData)]).then(function(){k("'"+s+"' successfully downloaded and stored in the indexedDB cache")}).catch(function(e){k("'"+s+"' successfully downloaded but not stored in the indexedDB cache due to the error: "+e)}),e})):(k("'"+s+"' request failed with status: "+e.status+" "+e.statusText),x(e,r.onProgress,r.enableStreamingDownload))})}return i&&(d.control=i.control,d.companyName=i.companyName,d.productName=i.productName,d.productVersion=i.productVersion),d.revalidated=!1,d.metaData={url:s,accessedAt:Date.now(),version:d.productVersion},d.response=null,d.enabled?a.loadRequest(s).then(function(e){var n,r,t;return e?(n=e.response,r=e.metaData,d.response=n,d.metaData.size=r.size,d.metaData.updatedAt=r.updatedAt,"immutable"==d.control?(d.revalidated=!0,a.updateRequestMetaData(r).then(function(){k("'"+d.metaData.url+"' served from the indexedDB cache without revalidation")}),x(n,i.onProgress,i.enableStreamingDownload)):(e=s,(t=window.location.href.match(/^[a-z]+:\/\/[^\/]+/))&&!e.lastIndexOf(t[0],0)||!n.headers.get("Last-Modified")&&!n.headers.get("ETag")?(e=(i=i||{}).headers||{},i.headers=e,n.headers.get("Last-Modified")?(e["If-Modified-Since"]=n.headers.get("Last-Modified"),e["Cache-Control"]="no-cache"):n.headers.get("ETag")&&(e["If-None-Match"]=n.headers.get("ETag"),e["Cache-Control"]="no-cache"),c(o,i)):fetch(s,{method:"HEAD"}).then(function(t){return d.revalidated=["Last-Modified","ETag"].every(function(e){return!n.headers.get(e)||n.headers.get(e)==t.headers.get(e)}),d.revalidated?(a.updateRequestMetaData(r).then(function(){k("'"+d.metaData.url+"' successfully revalidated and served from the indexedDB cache")}),x(d.response,i.onProgress,i.enableStreamingDownload)):c(o,i)}))):c(o,i)}).catch(function(e){return k("Failed to load '"+d.metaData.url+"' from indexedDB cache due to the error: "+e),g(o,i)}):g(o,i)});var P={br:{require:function(e){var t,n={"decompress.js":function(e,t,n){t.exports=e("./dec/decode").BrotliDecompressBuffer},"dec/bit_reader.js":function(e,t,n){const r=8224,o=new Uint32Array([0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215]);function i(e){this.buf_=new Uint8Array(r),this.input_=e,this.reset()}i.READ_SIZE=4096,i.IBUF_MASK=8191,i.prototype.reset=function(){this.buf_ptr_=0,this.val_=0,this.pos_=0,this.bit_pos_=0,this.bit_end_pos_=0,this.eos_=0,this.readMoreInput();for(var e=0;e<4;e++)this.val_|=this.buf_[this.pos_]<<8*e,++this.pos_;return 0<this.bit_end_pos_},i.prototype.readMoreInput=function(){if(!(256<this.bit_end_pos_))if(this.eos_){if(this.bit_pos_>this.bit_end_pos_)throw new Error("Unexpected end of input "+this.bit_pos_+" "+this.bit_end_pos_)}else{var e=this.buf_ptr_,t=this.input_.read(this.buf_,e,4096);if(t<0)throw new Error("Unexpected end of input");if(t<4096){this.eos_=1;for(var n=0;n<32;n++)this.buf_[e+t+n]=0}if(0===e){for(n=0;n<32;n++)this.buf_[8192+n]=this.buf_[n];this.buf_ptr_=4096}else this.buf_ptr_=0;this.bit_end_pos_+=t<<3}},i.prototype.fillBitWindow=function(){for(;8<=this.bit_pos_;)this.val_>>>=8,this.val_|=this.buf_[8191&this.pos_]<<24,++this.pos_,this.bit_pos_=this.bit_pos_-8>>>0,this.bit_end_pos_=this.bit_end_pos_-8>>>0},i.prototype.readBits=function(e){32-this.bit_pos_<e&&this.fillBitWindow();var t=this.val_>>>this.bit_pos_&o[e];return this.bit_pos_+=e,t},t.exports=i},"dec/context.js":function(e,t,n){n.lookup=new Uint8Array([0,0,0,0,0,0,0,0,0,4,4,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,12,16,12,12,20,12,16,24,28,12,12,32,12,36,12,44,44,44,44,44,44,44,44,44,44,32,32,24,40,28,12,12,48,52,52,52,48,52,52,52,48,52,52,52,52,52,48,52,52,52,52,52,48,52,52,52,52,52,24,12,28,12,12,12,56,60,60,60,56,60,60,60,56,60,60,60,60,60,56,60,60,60,60,60,56,60,60,60,60,60,24,12,28,12,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,56,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,26,26,26,26,27,27,27,27,28,28,28,28,29,29,29,29,30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,33,34,34,34,34,35,35,35,35,36,36,36,36,37,37,37,37,38,38,38,38,39,39,39,39,40,40,40,40,41,41,41,41,42,42,42,42,43,43,43,43,44,44,44,44,45,45,45,45,46,46,46,46,47,47,47,47,48,48,48,48,49,49,49,49,50,50,50,50,51,51,51,51,52,52,52,52,53,53,53,53,54,54,54,54,55,55,55,55,56,56,56,56,57,57,57,57,58,58,58,58,59,59,59,59,60,60,60,60,61,61,61,61,62,62,62,62,63,63,63,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),n.lookupOffsets=new Uint16Array([1024,1536,1280,1536,0,256,768,512])},"dec/decode.js":function(e,n,t){var r=e("./streams").BrotliInput,o=e("./streams").BrotliOutput,he=e("./bit_reader"),pe=e("./dictionary"),we=e("./huffman").HuffmanCode,V=e("./huffman").BrotliBuildHuffmanTable,me=e("./context"),be=e("./prefix"),ve=e("./transform");const A=8,q=16,ye=256,ge=704,xe=26,Ue=6,Ee=2,H=8,i=255,We=1080,D=18,F=new Uint8Array([1,2,3,4,0,5,17,6,16,7,8,9,10,11,12,13,14,15]),Oe=16,ke=new Uint8Array([3,2,1,0,3,3,3,3,3,3,2,2,2,2,2,2]),De=new Int8Array([0,0,0,0,-1,1,-2,2,-3,3,-1,1,-2,2,-3,3]),d=new Uint16Array([256,402,436,468,500,534,566,598,630,662,694,726,758,790,822,854,886,920,952,984,1016,1048,1080]);function Be(e){var t;return 0===e.readBits(1)?16:0<(t=e.readBits(3))?17+t:0<(t=e.readBits(3))?8+t:17}function Pe(e){var t;return e.readBits(1)?0===(t=e.readBits(3))?1:e.readBits(t)+(1<<t):0}function c(){this.meta_block_length=0,this.input_end=0,this.is_uncompressed=0,this.is_metadata=!1}function Ne(e){var t,n,r,o=new c;if(o.input_end=e.readBits(1),!o.input_end||!e.readBits(1)){if(7===(t=e.readBits(2)+4)){if(o.is_metadata=!0,0!==e.readBits(1))throw new Error("Invalid reserved bit");if(0===(n=e.readBits(2)))return o;for(r=0;r<n;r++){var i=e.readBits(8);if(r+1===n&&1<n&&0===i)throw new Error("Invalid size byte");o.meta_block_length|=i<<8*r}}else for(r=0;r<t;++r){var a=e.readBits(4);if(r+1===t&&4<t&&0===a)throw new Error("Invalid size nibble");o.meta_block_length|=a<<4*r}++o.meta_block_length,o.input_end||o.is_metadata||(o.is_uncompressed=e.readBits(1))}return o}function Re(e,t,n){var r;return n.fillBitWindow(),0<(r=e[t+=n.val_>>>n.bit_pos_&i].bits-H)&&(n.bit_pos_+=H,t=(t+=e[t].value)+(n.val_>>>n.bit_pos_&(1<<r)-1)),n.bit_pos_+=e[t].bits,e[t].value}function Me(e,t,n,r){var o=new Uint8Array(e);if(r.readMoreInput(),1===(m=r.readBits(2))){for(var i=e-1,a=0,s=new Int32Array(4),d=r.readBits(2)+1;i;)i>>=1,++a;for(h=0;h<d;++h)s[h]=r.readBits(a)%e,o[s[h]]=2;switch(d){case o[s[0]]=1:break;case 3:if(s[0]===s[1]||s[0]===s[2]||s[1]===s[2])throw new Error("[ReadHuffmanCode] invalid symbols");break;case 2:if(s[0]===s[1])throw new Error("[ReadHuffmanCode] invalid symbols");o[s[1]]=1;break;case 4:if(s[0]===s[1]||s[0]===s[2]||s[0]===s[3]||s[1]===s[2]||s[1]===s[3]||s[2]===s[3])throw new Error("[ReadHuffmanCode] invalid symbols");r.readBits(1)?(o[s[2]]=3,o[s[3]]=3):o[s[0]]=2}}else{for(var c=new Uint8Array(D),u=32,f=0,l=[new we(2,0),new we(2,4),new we(2,3),new we(3,2),new we(2,0),new we(2,4),new we(2,3),new we(4,1),new we(2,0),new we(2,4),new we(2,3),new we(3,2),new we(2,0),new we(2,4),new we(2,3),new we(4,5)],h=m;h<D&&0<u;++h){var p=F[h],w=0;r.fillBitWindow(),w+=r.val_>>>r.bit_pos_&15,r.bit_pos_+=l[w].bits,w=l[w].value,0!==(c[p]=w)&&(u-=32>>w,++f)}if(1!==f&&0!==u)throw new Error("[ReadHuffmanCode] invalid num_codes or space");for(var m=c,b=e,v=o,y=r,g=0,x=A,U=0,E=0,W=32768,O=[],k=0;k<32;k++)O.push(new we(0,0));for(V(O,0,5,m,D);g<b&&0<W;){var B=0;if(y.readMoreInput(),y.fillBitWindow(),B+=y.val_>>>y.bit_pos_&31,y.bit_pos_+=O[B].bits,(B=255&O[B].value)<q)(U=0)!=(v[g++]=B)&&(W-=32768>>(x=B));else{var P,N=B-14,R=0;if(E!==(R=B===q?x:R)&&(U=0,E=R),0<(B=U)&&(U=U-2<<N),b<g+(P=(U+=y.readBits(N)+3)-B))throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");for(var M=0;M<P;M++)v[g+M]=E;g+=P,0!==E&&(W-=P<<15-E)}}if(0!==W)throw new Error("[ReadHuffmanCodeLengths] space = "+W);for(;g<b;g++)v[g]=0}if(0===(m=V(t,n,H,o,e)))throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");return m}function Ve(e,t,n){return e=Re(e,t,n),t=be.kBlockLengthPrefixCode[e].nbits,be.kBlockLengthPrefixCode[e].offset+n.readBits(t)}function Ae(e,t){this.alphabet_size=e,this.num_htrees=t,this.codes=new Array(t+t*d[e+31>>>5]),this.htrees=new Uint32Array(t)}function qe(e,t){var n,r,o,i={num_htrees:null,context_map:null},a=0,s=(t.readMoreInput(),i.num_htrees=Pe(t)+1),d=i.context_map=new Uint8Array(e);if(!(s<=1)){for(t.readBits(1)&&(a=t.readBits(4)+1),n=[],r=0;r<We;r++)n[r]=new we(0,0);for(Me(s+a,n,0,t),r=0;r<e;)if(t.readMoreInput(),0===(o=Re(n,0,t)))d[r]=0,++r;else if(o<=a)for(var c=1+(1<<o)+t.readBits(o);--c;){if(e<=r)throw new Error("[DecodeContextMap] i >= context_map_size");d[r]=0,++r}else d[r]=o-a,++r;if(t.readBits(1)){for(var u=d,f=e,l=new Uint8Array(256),h=0;h<256;++h)l[h]=h;for(h=0;h<f;++h){var p=u[h];if(u[h]=l[p],p){for(var w=m=void 0,m=l,b=m[p],w=p;w;--w)m[w]=m[w-1];m[0]=b}}}}return i}function He(e,t,n,r,o,i,a){var s=2*n,d=n;e<=(a=0===(t=Re(t,n*We,a))?o[s+(1&i[d])]:1===t?o[s+(i[d]-1&1)]+1:t-2)&&(a-=e),r[n]=a,o[s+(1&i[d])]=a,++i[d]}function a(e){return e=new r(e),Be(e=new he(e)),Ne(e).meta_block_length}function s(D,e){for(var t=0,F=0,L=0,T=[16,15,11,4],S=0,n=0,r=0,o=[new Ae(0,0),new Ae(0,0),new Ae(0,0)],Y=128+he.READ_SIZE,i=new he(D),C=(1<<(D=Be(i)))-16,a=1<<D,s=a-1,d=new Uint8Array(a+Y+pe.maxDictionaryWordLength),I=a,c=[],u=[],f=0;f<3*We;f++)c[f]=new we(0,0),u[f]=new we(0,0);for(;!F;){for(var l,z,G,Z,h,K,X,p=0,w=[1<<28,1<<28,1<<28],m=[0],b=[1,1,1],j=[0,1,0,1,0,1],J=[0],Q=null,_=null,$=null,ee=0,te=0,v=0;v<3;++v)o[v].codes=null,o[v].htrees=null;if(i.readMoreInput(),t+(p=(g=Ne(i)).meta_block_length)>e.buffer.length&&((X=new Uint8Array(t+p)).set(e.buffer),e.buffer=X),F=g.input_end,X=g.is_uncompressed,g.is_metadata)for(g=void 0,g=(W=i).bit_pos_+7&-8,W.readBits(g-W.bit_pos_);0<p;--p)i.readMoreInput(),i.readBits(8);else if(0!==p)if(X){i.bit_pos_=i.bit_pos_+7&-8;var y,g,x=y=P=B=O=W=E=g=U=ne=void 0,ne=e,U=p,E=d,W=s,O=i,k=W+1,B=(g=t)&W,P=O.pos_&he.IBUF_MASK;if(U<8||O.bit_pos_+(U<<3)<O.bit_end_pos_)for(;0<U--;)O.readMoreInput(),E[B++]=O.readBits(8),B===k&&(ne.write(E,k),B=0);else{if(O.bit_end_pos_<32)throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");for(;O.bit_pos_<32;)E[B]=O.val_>>>O.bit_pos_,O.bit_pos_+=8,++B,--U;if(P+(y=O.bit_end_pos_-O.bit_pos_>>3)>he.IBUF_MASK){for(var re=he.IBUF_MASK+1-P,x=0;x<re;x++)E[B+x]=O.buf_[P+x];y-=re,B+=re,U-=re,P=0}for(x=0;x<y;x++)E[B+x]=O.buf_[P+x];if(U-=y,k<=(B+=y))for(ne.write(E,k),B-=k,x=0;x<B;x++)E[x]=E[k+x];for(;k<=B+U;){if(O.input_.read(E,B,y=k-B)<y)throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");ne.write(E,k),U-=y,B=0}if(O.input_.read(E,B,U)<U)throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");O.reset()}t+=p}else{for(v=0;v<3;++v)b[v]=Pe(i)+1,2<=b[v]&&(Me(b[v]+2,c,v*We,i),Me(xe,u,v*We,i),w[v]=Ve(u,v*We,i),J[v]=1);for(i.readMoreInput(),G=(1<<(l=i.readBits(2)))-1,g=(z=Oe+(i.readBits(4)<<l))+(48<<l),Q=new Uint8Array(b[0]),v=0;v<b[0];++v)i.readMoreInput(),Q[v]=i.readBits(2)<<1;var oe,N,R,M,ie,V,ae=qe(b[0]<<Ue,i),se=ae.num_htrees,de=ae.context_map,ce=(ae=qe(b[2]<<Ee,i)).num_htrees,ue=ae.context_map;for(o[0]=new Ae(ye,se),o[1]=new Ae(ge,b[1]),o[2]=new Ae(g,ce),v=0;v<3;++v)o[v].decode(i);for(h=Q[m[$=_=0]],ee=me.lookupOffsets[h],te=me.lookupOffsets[h+1],K=o[1].htrees[0];0<p;){for(i.readMoreInput(),0===w[1]&&(He(b[1],c,1,m,j,J,i),w[1]=Ve(u,We,i),K=o[1].htrees[m[1]]),--w[1],V=2<=(A=(H=Re(o[1].codes,K,i))>>6)?(A-=2,-1):0,q=be.kInsertRangeLut[A]+(H>>3&7),A=be.kCopyRangeLut[A]+(7&H),oe=be.kInsertLengthPrefixCode[q].offset+i.readBits(be.kInsertLengthPrefixCode[q].nbits),N=be.kCopyLengthPrefixCode[A].offset+i.readBits(be.kCopyLengthPrefixCode[A].nbits),n=d[t-1&s],r=d[t-2&s],M=0;M<oe;++M)i.readMoreInput(),0===w[0]&&(He(b[0],c,0,m,j,J,i),w[0]=Ve(u,0,i),_=m[0]<<Ue,h=Q[m[0]],ee=me.lookupOffsets[h],te=me.lookupOffsets[h+1]),Z=de[_+(me.lookup[ee+n]|me.lookup[te+r])],--w[0],r=n,n=Re(o[0].codes,o[0].htrees[Z],i),d[t&s]=n,(t&s)==s&&e.write(d,a),++t;if((p-=oe)<=0)break;if(V<0&&(i.readMoreInput(),0===w[2]&&(He(b[2],c,2,m,j,J,i),w[2]=Ve(u,2*We,i),$=m[2]<<Ee),--w[2],H=ue[$+(255&(4<N?3:N-2))],z<=(V=Re(o[2].codes,o[2].htrees[H],i))&&(q=(V-=z)&G,V=z+((fe=(2+(1&(V>>=l))<<(A=1+(V>>1)))-4)+i.readBits(A)<<l)+q)),H=T,A=S,(R=H=(q=V)<Oe?H[A=A+ke[q]&3]+De[q]:q-Oe+1)<0)throw new Error("[BrotliDecompress] invalid distance");if(ie=t&s,(L=t<C&&L!==C?t:C)<R){if(!(N>=pe.minDictionaryWordLength&&N<=pe.maxDictionaryWordLength))throw new Error("Invalid backward reference. pos: "+t+" distance: "+R+" len: "+N+" bytes left: "+p);var fe=pe.offsetsByLength[N],A=R-L-1,q=pe.sizeBitsByLength[N],H=A>>q;if(fe+=(A&(1<<q)-1)*N,!(H<ve.kNumTransforms))throw new Error("Invalid backward reference. pos: "+t+" distance: "+R+" len: "+N+" bytes left: "+p);if(t+=A=ve.transformDictionaryWord(d,ie,fe,N,H),p-=A,I<=(ie+=A)){e.write(d,a);for(var le=0;le<ie-I;le++)d[le]=d[I+le]}}else{if(0<V&&(T[3&S]=R,++S),p<N)throw new Error("Invalid backward reference. pos: "+t+" distance: "+R+" len: "+N+" bytes left: "+p);for(M=0;M<N;++M)d[t&s]=d[t-R&s],(t&s)==s&&e.write(d,a),++t,--p}n=d[t-1&s],r=d[t-2&s]}t&=1073741823}}e.write(d,t&s)}Ae.prototype.decode=function(e){for(var t=0,n=0;n<this.num_htrees;++n)this.htrees[n]=t,t+=Me(this.alphabet_size,this.codes,t,e)},t.BrotliDecompressedSize=a,t.BrotliDecompressBuffer=function(e,t){var n=new r(e),e=(null==t&&(t=a(e)),new Uint8Array(t));return s(n,t=new o(e)),t.pos<t.buffer.length&&(t.buffer=t.buffer.subarray(0,t.pos)),t.buffer},t.BrotliDecompress=s,pe.init()},"dec/dictionary.js":function(e,t,n){var r=e("./dictionary-browser");n.init=function(){n.dictionary=r.init()},n.offsetsByLength=new Uint32Array([0,0,0,0,0,4096,9216,21504,35840,44032,53248,63488,74752,87040,93696,100864,104704,106752,108928,113536,115968,118528,119872,121280,122016]),n.sizeBitsByLength=new Uint8Array([0,0,0,0,10,10,11,11,10,10,10,10,10,9,9,8,7,7,8,7,7,6,6,5,5]),n.minDictionaryWordLength=4,n.maxDictionaryWordLength=24},"dec/dictionary.bin.js":function(e,t,n){t.exports="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"},"dec/dictionary-browser.js":function(e,t,n){var r=e("base64-js");n.init=function(){return(0,e("./decode").BrotliDecompressBuffer)(r.toByteArray(e("./dictionary.bin.js")))}},"dec/huffman.js":function(e,t,n){function v(e,t){this.bits=e,this.value=t}n.HuffmanCode=v;function y(e,t){for(var n=1<<t-1;e&n;)n>>=1;return(e&n-1)+n}function g(e,t,n,r,o){for(;e[t+(r-=n)]=new v(o.bits,o.value),0<r;);}n.BrotliBuildHuffmanTable=function(e,t,n,r,o){for(var i,a,s,d,c,u,f,l,h=t,p=new Int32Array(16),w=new Int32Array(16),m=new Int32Array(o),b=0;b<o;b++)p[r[b]]++;for(w[1]=0,i=1;i<15;i++)w[i+1]=w[i]+p[i];for(b=0;b<o;b++)0!==r[b]&&(m[w[r[b]]++]=b);if(l=f=1<<n,1===w[15])for(a=0;a<l;++a)e[t+a]=new v(0,65535&m[0]);else{for(b=a=0,i=1,s=2;i<=n;++i,s<<=1)for(;0<p[i];--p[i])g(e,t+a,s,f,new v(255&i,65535&m[b++])),a=y(a,i);for(c=l-1,d=-1,i=n+1,s=2;i<=15;++i,s<<=1)for(;0<p[i];--p[i])(a&c)!==d&&(t+=f,l+=f=1<<(u=function(e,t,n){for(var r=1<<t-n;t<15&&!((r-=e[t])<=0);)++t,r<<=1;return t-n}(p,i,n)),e[h+(d=a&c)]=new v(u+n&255,t-h-d&65535)),g(e,t+(a>>n),s,f,new v(i-n&255,65535&m[b++])),a=y(a,i)}return l}},"dec/prefix.js":function(e,t,n){function r(e,t){this.offset=e,this.nbits=t}n.kBlockLengthPrefixCode=[new r(1,2),new r(5,2),new r(9,2),new r(13,2),new r(17,3),new r(25,3),new r(33,3),new r(41,3),new r(49,4),new r(65,4),new r(81,4),new r(97,4),new r(113,5),new r(145,5),new r(177,5),new r(209,5),new r(241,6),new r(305,6),new r(369,7),new r(497,8),new r(753,9),new r(1265,10),new r(2289,11),new r(4337,12),new r(8433,13),new r(16625,24)],n.kInsertLengthPrefixCode=[new r(0,0),new r(1,0),new r(2,0),new r(3,0),new r(4,0),new r(5,0),new r(6,1),new r(8,1),new r(10,2),new r(14,2),new r(18,3),new r(26,3),new r(34,4),new r(50,4),new r(66,5),new r(98,5),new r(130,6),new r(194,7),new r(322,8),new r(578,9),new r(1090,10),new r(2114,12),new r(6210,14),new r(22594,24)],n.kCopyLengthPrefixCode=[new r(2,0),new r(3,0),new r(4,0),new r(5,0),new r(6,0),new r(7,0),new r(8,0),new r(9,0),new r(10,1),new r(12,1),new r(14,2),new r(18,2),new r(22,3),new r(30,3),new r(38,4),new r(54,4),new r(70,5),new r(102,5),new r(134,6),new r(198,7),new r(326,8),new r(582,9),new r(1094,10),new r(2118,24)],n.kInsertRangeLut=[0,0,8,8,0,16,8,16,16],n.kCopyRangeLut=[0,8,0,8,16,0,16,8,16]},"dec/streams.js":function(e,t,n){function r(e){this.buffer=e,this.pos=0}function o(e){this.buffer=e,this.pos=0}r.prototype.read=function(e,t,n){this.pos+n>this.buffer.length&&(n=this.buffer.length-this.pos);for(var r=0;r<n;r++)e[t+r]=this.buffer[this.pos+r];return this.pos+=n,n},n.BrotliInput=r,o.prototype.write=function(e,t){if(this.pos+t>this.buffer.length)throw new Error("Output buffer is not large enough");return this.buffer.set(e.subarray(0,t),this.pos),this.pos+=t,t},n.BrotliOutput=o},"dec/transform.js":function(e,t,n){var p=e("./dictionary");function r(e,t,n){this.prefix=new Uint8Array(e.length),this.transform=t,this.suffix=new Uint8Array(n.length);for(var r=0;r<e.length;r++)this.prefix[r]=e.charCodeAt(r);for(r=0;r<n.length;r++)this.suffix[r]=n.charCodeAt(r)}var w=[new r("",0,""),new r("",0," "),new r(" ",0," "),new r("",12,""),new r("",10," "),new r("",0," the "),new r(" ",0,""),new r("s ",0," "),new r("",0," of "),new r("",10,""),new r("",0," and "),new r("",13,""),new r("",1,""),new r(", ",0," "),new r("",0,", "),new r(" ",10," "),new r("",0," in "),new r("",0," to "),new r("e ",0," "),new r("",0,'"'),new r("",0,"."),new r("",0,'">'),new r("",0,"\n"),new r("",3,""),new r("",0,"]"),new r("",0," for "),new r("",14,""),new r("",2,""),new r("",0," a "),new r("",0," that "),new r(" ",10,""),new r("",0,". "),new r(".",0,""),new r(" ",0,", "),new r("",15,""),new r("",0," with "),new r("",0,"'"),new r("",0," from "),new r("",0," by "),new r("",16,""),new r("",17,""),new r(" the ",0,""),new r("",4,""),new r("",0,". The "),new r("",11,""),new r("",0," on "),new r("",0," as "),new r("",0," is "),new r("",7,""),new r("",1,"ing "),new r("",0,"\n\t"),new r("",0,":"),new r(" ",0,". "),new r("",0,"ed "),new r("",20,""),new r("",18,""),new r("",6,""),new r("",0,"("),new r("",10,", "),new r("",8,""),new r("",0," at "),new r("",0,"ly "),new r(" the ",0," of "),new r("",5,""),new r("",9,""),new r(" ",10,", "),new r("",10,'"'),new r(".",0,"("),new r("",11," "),new r("",10,'">'),new r("",0,'="'),new r(" ",0,"."),new r(".com/",0,""),new r(" the ",0," of the "),new r("",10,"'"),new r("",0,". This "),new r("",0,","),new r(".",0," "),new r("",10,"("),new r("",10,"."),new r("",0," not "),new r(" ",0,'="'),new r("",0,"er "),new r(" ",11," "),new r("",0,"al "),new r(" ",11,""),new r("",0,"='"),new r("",11,'"'),new r("",10,". "),new r(" ",0,"("),new r("",0,"ful "),new r(" ",10,". "),new r("",0,"ive "),new r("",0,"less "),new r("",11,"'"),new r("",0,"est "),new r(" ",10,"."),new r("",11,'">'),new r(" ",0,"='"),new r("",10,","),new r("",0,"ize "),new r("",11,"."),new r("\xc2\xa0",0,""),new r(" ",0,","),new r("",10,'="'),new r("",11,'="'),new r("",0,"ous "),new r("",11,", "),new r("",10,"='"),new r(" ",10,","),new r(" ",11,'="'),new r(" ",11,", "),new r("",11,","),new r("",11,"("),new r("",11,". "),new r(" ",11,"."),new r("",11,"='"),new r(" ",11,". "),new r(" ",10,'="'),new r(" ",11,"='"),new r(" ",10,"='")];function m(e,t){return e[t]<192?(97<=e[t]&&e[t]<=122&&(e[t]^=32),1):e[t]<224?(e[t+1]^=32,2):(e[t+2]^=5,3)}n.kTransforms=w,n.kNumTransforms=w.length,n.transformDictionaryWord=function(e,t,n,r,o){for(var i,a=w[o].prefix,s=w[o].suffix,d=(o=w[o].transform)<12?0:o-11,c=0,u=t,f=(r<d&&(d=r),0);f<a.length;)e[t++]=a[f++];for(n+=d,r-=d,o<=9&&(r-=o),c=0;c<r;c++)e[t++]=p.dictionary[n+c];if(i=t-r,10===o)m(e,i);else if(11===o)for(;0<r;){var l=m(e,i);i+=l,r-=l}for(var h=0;h<s.length;)e[t++]=s[h++];return t-u}},"node_modules/base64-js/index.js":function(e,t,n){"use strict";n.byteLength=function(e){return 3*e.length/4-f(e)},n.toByteArray=function(e){for(var t,n,r,o,i=e.length,a=(r=f(e),o=new u(3*i/4-r),t=0<r?i-4:i,0),s=0;s<t;s+=4)n=c[e.charCodeAt(s)]<<18|c[e.charCodeAt(s+1)]<<12|c[e.charCodeAt(s+2)]<<6|c[e.charCodeAt(s+3)],o[a++]=n>>16&255,o[a++]=n>>8&255,o[a++]=255&n;return 2===r?(n=c[e.charCodeAt(s)]<<2|c[e.charCodeAt(s+1)]>>4,o[a++]=255&n):1===r&&(n=c[e.charCodeAt(s)]<<10|c[e.charCodeAt(s+1)]<<4|c[e.charCodeAt(s+2)]>>2,o[a++]=n>>8&255,o[a++]=255&n),o},n.fromByteArray=function(e){for(var t,n=e.length,r=n%3,o="",i=[],a=0,s=n-r;a<s;a+=16383)i.push(function(e,t){for(var n,r=[],o=a;o<t;o+=3)n=(e[o]<<16)+(e[o+1]<<8)+e[o+2],r.push(d[n>>18&63]+d[n>>12&63]+d[n>>6&63]+d[63&n]);return r.join("")}(e,s<a+16383?s:a+16383));return 1==r?(t=e[n-1],o=(o+=d[t>>2])+d[t<<4&63]+"=="):2==r&&(t=(e[n-2]<<8)+e[n-1],o=(o=(o+=d[t>>10])+d[t>>4&63])+d[t<<2&63]+"="),i.push(o),i.join("")};for(var d=[],c=[],u="undefined"!=typeof Uint8Array?Uint8Array:Array,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=0,i=r.length;o<i;++o)d[o]=r[o],c[r.charCodeAt(o)]=o;function f(e){var t=e.length;if(0<t%4)throw new Error("Invalid string. Length must be a multiple of 4");return"="===e[t-2]?2:"="===e[t-1]?1:0}c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63}};for(t in n)n[t].folder=t.substring(0,t.lastIndexOf("/")+1);function r(e,t){var n=t.match(/^\//)?null:e?t.match(/^\.\.?\//)?o(e.folder+t):i(e,t):o(t);if(n)return n.exports||(n.parent=e,n(r.bind(null,n),n,n.exports={})),n.exports;throw"module not found: "+t}var o=function(e){var t=[];return(e=e.split("/").every(function(e){return".."==e?t.pop():"."==e||""==e||t.push(e)})?t.join("/"):null)?n[e]||n[e+".js"]||n[e+"/index.js"]:null},i=function(e,t){return e?o(e.folder+"node_modules/"+t)||i(e.parent,t):null};return r(null,e)},decompress:function(e){this.exports||(this.exports=this.require("decompress.js"));try{return this.exports(e)}catch(e){}},hasUnityMarker:function(e){var t="UnityWeb Compressed Content (brotli)";if(!e.length)return!1;var n=1&e[0]?14&e[0]?4:7:1,r=e[0]&(1<<n)-1,o=1+(Math.log(t.length-1)/Math.log(2)>>3);if(commentOffset=1+n+2+1+2+(o<<3)+7>>3,17==r||commentOffset>e.length)return!1;for(var i=r+(6+(o<<4)+(t.length-1<<6)<<n),a=0;a<commentOffset;a++,i>>>=8)if(e[a]!=(255&i))return!1;return String.fromCharCode.apply(null,e.subarray(commentOffset,commentOffset+t.length))==t}}};function N(n){W(n);var e=f.cacheControl(f[n]),t=f.companyName&&f.productName?f.cachedFetch:f.fetchWithProgress,r=f[n],r=/file:\/\//.exec(r)?"same-origin":void 0;return t(f[n],{method:"GET",companyName:f.companyName,productName:f.productName,productVersion:f.productVersion,control:e,mode:r,onProgress:function(e){W(n,e)}}).then(function(e){return a=e.parsedBody,s=f[n],new Promise(function(e,t){try{for(var n in P){var r,o,i;if(P[n].hasUnityMarker(a))return s&&console.log('You can reduce startup time if you configure your web server to add "Content-Encoding: '+n+'" response header when serving "'+s+'" file.'),(r=P[n]).worker||(o=URL.createObjectURL(new Blob(["this.require = ",r.require.toString(),"; this.decompress = ",r.decompress.toString(),"; this.onmessage = ",function(e){e={id:e.data.id,decompressed:this.decompress(e.data.compressed)};postMessage(e,e.decompressed?[e.decompressed.buffer]:[])}.toString(),"; postMessage({ ready: true });"],{type:"application/javascript"})),r.worker=new Worker(o),r.worker.onmessage=function(e){e.data.ready?URL.revokeObjectURL(o):(this.callbacks[e.data.id](e.data.decompressed),delete this.callbacks[e.data.id])},r.worker.callbacks={},r.worker.nextCallbackId=0),i=r.worker.nextCallbackId++,r.worker.callbacks[i]=e,void r.worker.postMessage({id:i,compressed:a},[a.buffer])}e(a)}catch(e){t(e)}});var a,s}).catch(function(e){var t="Failed to download file "+f[n];"file:"==location.protocol?c(t+". Loading web pages via a file:// URL without a web server is not supported by this browser. Please use a local development web server to host Unity content, or use the Unity Build and Run option.","error"):console.error(t)})}function R(){Promise.all([N("frameworkUrl").then(function(e){var s=URL.createObjectURL(new Blob([e],{type:"application/javascript"}));return new Promise(function(i,e){var a=document.createElement("script");a.src=s,a.onload=function(){if("undefined"==typeof unityFramework||!unityFramework){var e,t=[["br","br"],["gz","gzip"]];for(e in t){var n,r=t[e];if(f.frameworkUrl.endsWith("."+r[0]))return n="Unable to parse "+f.frameworkUrl+"!","file:"==location.protocol?void c(n+" Loading pre-compressed (brotli or gzip) content via a file:// URL without a web server is not supported by this browser. Please use a local development web server to host compressed Unity content, or use the Unity Build and Run option.","error"):(n+=' This can happen if build compression was enabled but web server hosting the content was misconfigured to not serve the file with HTTP Response Header "Content-Encoding: '+r[1]+'" present. Check browser Console and Devtools Network tab to debug.',"br"==r[0]&&"http:"==location.protocol&&(r=-1!=["localhost","127.0.0.1"].indexOf(location.hostname)?"":"Migrate your server to use HTTPS.",n=/Firefox/.test(navigator.userAgent)?"Unable to parse "+f.frameworkUrl+'!<br>If using custom web server, verify that web server is sending .br files with HTTP Response Header "Content-Encoding: br". Brotli compression may not be supported in Firefox over HTTP connections. '+r+' See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1670675">https://bugzilla.mozilla.org/show_bug.cgi?id=1670675</a> for more information.':"Unable to parse "+f.frameworkUrl+'!<br>If using custom web server, verify that web server is sending .br files with HTTP Response Header "Content-Encoding: br". Brotli compression may not be supported over HTTP connections. Migrate your server to use HTTPS.'),void c(n,"error"))}c("Unable to parse "+f.frameworkUrl+"! The file is corrupt, or compression was misconfigured? (check Content-Encoding HTTP Response Header on web server)","error")}var o=unityFramework;unityFramework=null,a.onload=null,URL.revokeObjectURL(s),i(o)},a.onerror=function(e){c("Unable to load file "+f.frameworkUrl+"! Check that the file exists on the remote server. (also check browser Console and Devtools Network tab to debug)","error")},document.body.appendChild(a),f.deinitializers.push(function(){document.body.removeChild(a)})})}),N("codeUrl")]).then(function(e){f.wasmBinary=e[1],e[0](f)});var e=N("dataUrl");f.preRun.push(function(){f.addRunDependency("dataUrl"),e.then(function(e){var t=new DataView(e.buffer,e.byteOffset,e.byteLength),n=0,r="UnityWebData1.0\0";if(!String.fromCharCode.apply(null,e.subarray(n,n+r.length))==r)throw"unknown data format";var o=t.getUint32(n+=r.length,!0);for(n+=4;n<o;){var i=t.getUint32(n,!0),a=(n+=4,t.getUint32(n,!0)),s=(n+=4,t.getUint32(n,!0)),d=(n+=4,String.fromCharCode.apply(null,e.subarray(n,n+s)));n+=s;for(var c=0,u=d.indexOf("/",c)+1;0<u;c=u,u=d.indexOf("/",c)+1)f.FS_createPath(d.substring(0,c),d.substring(c,u-1),!0,!0);f.FS_createDataFile(d,null,e.subarray(i,i+a),!0,!0,!0)}f.removeRunDependency("dataUrl")})})}return new Promise(function(e,t){var n;f.SystemInfo.hasWebGL?1==f.SystemInfo.hasWebGL?(n='Your browser does not support graphics API "WebGL 2" which is required for this content.',"Safari"==f.SystemInfo.browser&&parseInt(f.SystemInfo.browserVersion)<15&&(f.SystemInfo.mobile||1<navigator.maxTouchPoints?n+="\nUpgrade to iOS 15 or later.":n+="\nUpgrade to Safari 15 or later."),t(n)):f.SystemInfo.hasWasm?(f.startupErrorHandler=t,d(0),f.postRun.push(function(){d(1),delete f.startupErrorHandler,e(U)}),R()):t("Your browser does not support WebAssembly."):t("Your browser does not support WebGL.")})}


================================================
File: unity/Build/SimPy.wasm.unityweb
================================================
[Non-text file]


================================================
File: unity/StreamingAssets/MQTTBroker.json
================================================
{
  "tcp": {
    "port": 1883,
    "host": "supos-ce-instance4.supos.app",
    "client_id": "simpy_mqtt_docker_mqtt_client",
    "username": "",
    "password": "",
    "keep_alive": 60,
    "mqtt_version": 5,
    "connect_timeout": 30,
    "auto_reconnect": true,
    "reconnect_delay": 5,
    "subscribe_broker_topic": ""
  },
  "ws": {
    "port": 8083,
    "host": "supos-ce-instance4.supos.app",
    "client_id": "simpy_mqtt_docker_mqtt_client_ws",
    "username": "",
    "password": "",
    "keep_alive": 60,
    "mqtt_version": 5,
    "connect_timeout": 30,
    "auto_reconnect": true,
    "reconnect_delay": 5,
    "subscribe_broker_topic": ""
  },
  "wss": {
    "port": 8084,
    "host": "supos-ce-instance4.supos.app",
    "client_id": "NLDF_TEST",
    "username": "",
    "password": "",
    "keep_alive": 60,
    "mqtt_version": 5,
    "connect_timeout": 30,
    "auto_reconnect": true,
    "reconnect_delay": 5,
    "subscribe_broker_topic": ""
  },

  "common_topic": {
    "Root_Topic_Head": "NLDF_TEST"
  },
  "connect_mode": { "wss": true }
}



================================================
File: unity/TemplateData/style.css
================================================
body { padding: 0; margin: 0 }
#unity-container { position: absolute }
#unity-container.unity-desktop { left: 50%; top: 50%; transform: translate(-50%, -50%) }
#unity-container.unity-mobile { position: fixed; width: 100%; height: 100% }
#unity-canvas { background: #231F20 }
.unity-mobile #unity-canvas { width: 100%; height: 100% }
#unity-loading-bar { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); display: none }
#unity-logo { width: 154px; height: 130px; background: url('unity-logo-dark.png') no-repeat center }
#unity-progress-bar-empty { width: 141px; height: 18px; margin-top: 10px; margin-left: 6.5px; background: url('progress-bar-empty-dark.png') no-repeat center }
#unity-progress-bar-full { width: 0%; height: 18px; margin-top: 10px; background: url('progress-bar-full-dark.png') no-repeat center }
#unity-footer { position: relative }
.unity-mobile #unity-footer { display: none }
#unity-webgl-logo { float:left; width: 204px; height: 38px; background: url('webgl-logo.png') no-repeat center }
#unity-build-title { float: right; margin-right: 10px; line-height: 38px; font-family: arial; font-size: 18px }
#unity-fullscreen-button { cursor:pointer; float: right; width: 38px; height: 38px; background: url('fullscreen-button.png') no-repeat center }
#unity-warning { position: absolute; left: 50%; top: 5%; transform: translate(-50%); background: white; padding: 10px; display: none }


