Directory structure:
‚îî‚îÄ‚îÄ 25-AdventureX-SUPCON-Hackathon/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ pyproject.toml
    ‚îú‚îÄ‚îÄ run_multi_line_simulation.py
    ‚îú‚îÄ‚îÄ task_scheduler.py
    ‚îú‚îÄ‚îÄ uv.lock
    ‚îú‚îÄ‚îÄ .python-version
    ‚îú‚îÄ‚îÄ config/
    ‚îÇ   ‚îú‚îÄ‚îÄ factory_layout.yml
    ‚îÇ   ‚îú‚îÄ‚îÄ factory_layout_multi.yml
    ‚îÇ   ‚îú‚îÄ‚îÄ path_timing.py
    ‚îÇ   ‚îú‚îÄ‚îÄ schemas.py
    ‚îÇ   ‚îú‚îÄ‚îÄ settings.py
    ‚îÇ   ‚îú‚îÄ‚îÄ topics.py
    ‚îÇ   ‚îî‚îÄ‚îÄ __pycache__/
    ‚îú‚îÄ‚îÄ docs/
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ main.py
    ‚îÇ   ‚îú‚îÄ‚îÄ user_input.py
    ‚îÇ   ‚îú‚îÄ‚îÄ user_input_multi.py
    ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
    ‚îÇ   ‚îú‚îÄ‚îÄ agent_interface/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ command_handler.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ multi_line_command_handler.py
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __pycache__/
    ‚îÇ   ‚îú‚îÄ‚îÄ game_logic/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fault_system.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ kpi_calculator.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order_generator.py
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __pycache__/
    ‚îÇ   ‚îú‚îÄ‚îÄ simulation/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ factory.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ factory_multi.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ line.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ entities/
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ agv.py
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ base.py
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ conveyor.py
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ product.py
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ quality_checker.py
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ station.py
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ warehouse.py
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ __pycache__/
    ‚îÇ   ‚îî‚îÄ‚îÄ utils/
    ‚îÇ       ‚îú‚îÄ‚îÄ config_loader.py
    ‚îÇ       ‚îú‚îÄ‚îÄ mqtt_client.py
    ‚îÇ       ‚îú‚îÄ‚îÄ safe_output.py
    ‚îÇ       ‚îú‚îÄ‚îÄ topic_manager.py
    ‚îÇ       ‚îî‚îÄ‚îÄ __pycache__/
    ‚îî‚îÄ‚îÄ unity/
        ‚îú‚îÄ‚îÄ index.html
        ‚îú‚îÄ‚îÄ Build/
        ‚îÇ   ‚îú‚îÄ‚îÄ SimPy.data.unityweb
        ‚îÇ   ‚îú‚îÄ‚îÄ SimPy.framework.js.unityweb
        ‚îÇ   ‚îú‚îÄ‚îÄ SimPy.loader.js
        ‚îÇ   ‚îî‚îÄ‚îÄ SimPy.wasm.unityweb
        ‚îú‚îÄ‚îÄ StreamingAssets/
        ‚îÇ   ‚îî‚îÄ‚îÄ MQTTBroker.json
        ‚îî‚îÄ‚îÄ TemplateData/
            ‚îî‚îÄ‚îÄ style.css

================================================
File: README.md
================================================
# SUPCON NLDF (Natual Language Driven Factory) Simulator

## Quick Start

### 1. Environment Setup

- Download [uv](https://docs.astral.sh/uv/getting-started/installation/)

```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

- Clone project

```bash
git clone https://github.com/supcon-international/25-AdventureX-SUPCON-Hackathon.git
cd 25-AdventureX-SUPCON-Hackathon
```

- Install dependencies

```bash
uv sync
```

### 2. Run Simulation

ËÆæÁΩÆÁéØÂ¢ÉÂèòÈáè`TOPIC_ROOT`‰Ωú‰∏∫‰ªøÁúüÁ≥ªÁªü mqtt ÁöÑ client id Âíå topic root Êù•ÂàÜÈöî‰∏çÂêåÈÄâÊâãÔºåÈªòËÆ§ÂÄºËé∑ÂèñÈ°∫Â∫è‰∏∫`TOPIC_ROOT`, `USERNAME`, `USER`ÁöÑÁéØÂ¢ÉÂèòÈáèÔºåÂê¶ÂàôÈªòËÆ§"NLDF_TEST"

- add `--menu` arg to enable interactive input thread for test only
- add `--no-mqtt` arg to disable mqtt communication for debug offline

```bash
uv run run_multi_line_simulation.py (--menu) (--no-mqtt)
```

### 3. Unity Run

1. ËÆæÁΩÆ `StreamingAssets/MQTTBroker.json`‰∏≠ÁöÑ Root_Topic_Head Â≠óÊÆµ‰∏é‰∏äËø∞ÁöÑ topic root ‰∏ÄËá¥ÔºåÂπ∂‰øÆÊîπ wss.client_id Â≠óÊÆµÈò≤Ê≠¢ client ÂÜ≤Á™Å„ÄÇ
2. ‰ΩøÁî® VScode Live Server Êèí‰ª∂ÔºåÈÄâ‰∏≠Âà∞ index.html Êñá‰ª∂Âêé go live ÂàùÂßãÂåñÁªô‰∫à WebGL ÁöÑ Unity ÂâçÁ´ØÁïåÈù¢

   "wss":{
   "port": 8084,
   "host": "supos-ce-instance4.supos.app",
   "client*id": "\*\*\_NLDF2_mqtt_wss_test*\*\*",
   ......
   },

   "common*topic":{
   "Root_Topic_Head": "\*\*\_NLDF1*\*\*"},

## Background

Agent Êàê‰∫ÜÊØè‰∏™È¢ÜÂüüÁªï‰∏çÂºÄÁöÑÈù©ÂëΩÁÅ´ÁßçÔºåÂú®Â∑•‰∏öÈ¢ÜÂüü‰∫¶ÊòØÂ¶ÇÊ≠§„ÄÇ‰Ωú‰∏∫ÂõΩÂÜÖÂ∑•‰∏öËá™Âä®ÂåñÁöÑÈæôÂ§¥‰ºÅ‰∏öÔºåÊàë‰ª¨Ê≠£Âú®ÁßØÊûÅÂ∞ùËØïÂ∞ÜÊúÄÂâçÊ≤øÁöÑ agent ÊäÄÊúØÂºïÂÖ•ÁúüÂÆû‰∫ßÁ∫øÔºåÊé®Âä®‰º†ÁªüÂ∑•ÂéÇÂêëËá™ÈÄÇÂ∫î„ÄÅËá™ÁªÑÁªá„ÄÅËá™‰ºòÂåñÁ≥ªÁªüÊºîËøõ„ÄÇ
Êàë‰ª¨Ëøõ‰∏ÄÊ≠•ÁïÖÊÉ≥ÔºöËÉΩÂê¶ÊûÑÂª∫‰∏Ä‰∏™ÂÉè‰∫∫Á±ª‰∏ÄÊ†∑ÈÄöËøáËØ≠Ë®ÄÂÜ≥Á≠ñÁöÑÊô∫ËÉΩ‰ΩìÁ≥ªÁªüÔºüÂèØ‰ª•ÊÉ≥Ë±°Êú∫Âô®‰πãÈó¥ÂØπËØùÔºö‚ÄúÊàëËøôËæπÂø´Êª°‰∫ÜÔºåÊöÇÂÅúÊäïÊñô„ÄÇ‚Äù
‚ÄúÊî∂Âà∞ÔºåÊàëÂÖàÁºì‰∏ÄËΩÆ„ÄÇ‚ÄùÁî®ËØ≠Ë®ÄÂÅöÂà∞ÁêÜËß£ÂΩºÊ≠§„ÄÅÂçè‰ΩúÂ∫îÂèò„ÄÅËá™‰∏ªÂÜ≥Á≠ñÔºåÂÆûÁé∞Â∑•ÂéÇÊî∂ÁõäÊúÄÂ§ßÂåñÁöÑÂêåÊó∂Á®≥ÂÆöËøêË°å„ÄÇ‰∏∫Ê≠§ÔºåÊàë‰ª¨Êê≠Âª∫‰∫Ü‰∏Ä‰∏™ÂèØÊéßÁöÑÊ®°ÊãüÂ∑•ÂéÇÔºåÁ≠âÂæÖ‰Ω†Êù•Ëµã‰∫àÂÆÉÊÄùÁª¥‰∏éË°åÂä®ÔºåÊé¢Á¥¢ agent ‰∏éÂ∑•‰∏öÂçè‰ΩúÁöÑÊñ∞ÂèØËÉΩ„ÄÇ

## Âú∫ÊôØËß£Èáä

Â∑•ÂéÇÂÜÖÈÉ®ÂåÖÂê´ 3 Êù°‰∫ßÁ∫øÔºå‰∏Ä‰∏™ÂéüÊñô‰ªìÂ∫ì‰ª•Âèä‰∏Ä‰∏™ÊúÄÁªà‰∫ßÂìÅ‰ªìÂ∫ìÔºå3 Êù°‰∫ßÁ∫øÈÖçÁΩÆÊúâ‰∏ÄÊ†∑ÁöÑ AÔºåBÔºåC Â∑•Á´ô‰ª•Âèä‰∏Ä‰∏™Ë¥®Ê£ÄÁ´ôÔºåABÔºåBCÔºåCQ ‰∏âÊù°‰∏≠Èó¥ËøûÊé•ÁöÑËá™Âä®‰º†ÈÄÅÂ∏¶Âíå AGV_1ÔºåAGV_2 ‰∏§‰∏™ AGV„ÄÇÈÄâÊâãÈúÄË¶ÅÂØπ 3 Êù°‰∫ßÁ∫øÁöÑ‰∏ÄÂÖ± 6 ‰∏™ AGV ËøõË°åÊìç‰ΩúÔºàÂåÖÊã¨ÁßªÂä®ÔºåË£ÖË¥ßÂç∏Ë¥ßÁ≠âÔºâÔºåÈÄâÊâãÈúÄË¶ÅÂú®ÊúâÈôêÁöÑÊó∂Èó¥ÂÜÖÊìç‰Ωú agv ÂçèË∞ÉÁîü‰∫ßÔºåÂêåÊó∂Â∫îÂØπÈöèÊú∫ÊïÖÈöúÔºåËé∑ÂæóÂ∞ΩÂèØËÉΩÈ´òÁöÑ KPI ÂæóÂàÜ„ÄÇÔºàKPI ÂÆö‰πâËßÅ‰∏ãÊñáÔºâ

‰∏∫‰∫ÜÁÆÄÂçïËµ∑ËßÅÔºåÊØè‰∏™ AGV ÁöÑÂèØÁßªÂä®Ë∑ØÂæÑÁÇπÈÉΩ‰ΩøÁî® P1-P10 Êù•Ë°®Á§∫Ôºå‰ªñ‰ª¨Ë°®Á§∫ÂΩìÂâç AGV Ë∑ØÂæÑ‰∏äÁöÑÁõ∏ÂØπÂèØÂÅúÈ°øÁÇπÔºåÂ¶ÇÊûúÂ∏åÊúõ AGV1 Êàñ 2 ÂâçÂæÄÊüêÁÇπ‰æãÂ¶ÇÂéüÊñô‰ªìÂ∫ìÔºåÈÉΩÈúÄË¶ÅÁßªÂä®Âà∞ P0 ÁÇπ„ÄÇAGV Ë∑ØÂæÑ‰∫í‰∏çÂπ≤Êâ∞Ôºå‰∏çËÄÉËôëÁ¢∞ÊíûÁ≠âÂõ†Á¥†ÔºåË∑ØÂæÑ‰∏äÁöÑÁÇπ ID Â¶ÇÂõæ„ÄÇ
![Factory Agent Logo](/docs/path_point.png)

| point_id | device_id    | Â§áÊ≥®      |
| :------- | :----------- | :-------- |
| P0       | RawMaterial  | ÂéüÊñô‰ªìÂ∫ì  |
| P1       | StationA     | Â∑•Á´ô A    |
| P2       | Conveyor_AB  | ‰º†ÈÄÅÂ∏¶ AB |
| P3       | StationB     | Â∑•Á´ô B    |
| P4       | Conveyor_BC  | ‰º†ÈÄÅÂ∏¶ BC |
| P5       | StationC     | Â∑•Á´ô C    |
| P6       | Conveyor_CQ  | ‰º†ÈÄÅÂ∏¶ CQ |
| P7       | QualityCheck | Ë¥®Ê£ÄÁ´ô    |
| P8       | QualityCheck | Ë¥®Ê£ÄÁ´ô    |
| P9       | Warehouse    | ÊàêÂìÅ‰ªìÂ∫ì  |

## Ê∏∏ÊàèÊú∫Âà∂

Ê∏∏Êàè‰ΩøÁî® simpy ÂÆûÁé∞Á¶ªÊï£Â∑•ÂéÇÁöÑ‰ªøÁúü

1. Order Generactor: Ê∏∏ÊàèÊúâ‰∏Ä‰∏™ÂÖ®Â±ÄÁöÑËÆ¢ÂçïÁîüÊàêÂô®ÔºåÊØè‰∏™ËÆ¢Âçï‰∏≠ÂèØËÉΩÊúâ‰∏Ä‰∏™ÊàñÂ§ö‰∏™‰∫ßÂìÅÁ≠âÂæÖÂä†Â∑•Ôºå‰∏ÄÊó¶ÁîüÊàêÂØπÂ∫îÂæÖÂä†Â∑•ÁöÑ product ‰ºöÂú®ÂéüÊñô‰ªìÂ∫ì‰∏≠Âá∫Áé∞
2. ‰∫ßÂìÅËØ¥ÊòéÔºö Ê∏∏ÊàèÂÆö‰πâ P1ÔºåP2ÔºåP3 ‰∏âÁßç‰∫ßÂìÅÔºå‰∫ßÂìÅ id:prod_1_XXXXXX ‰∏≠ÂåÖÂê´ 3 ÈÉ®ÂàÜ prod,type Êï∞Â≠óÂíå UUIDÔºå‰∫ßÂìÅÊúâËá™Â∑±ÂØπÂ∫îÁöÑÂ∑•Ëâ∫ÊµÅÁ®ãÔºö

- ‰∫ßÂìÅ P1 / P2

```
RawMaterial ‚Üí [AGV] ‚Üí StationA ‚Üí Conveyor_AB ‚Üí StationB ‚Üí Conveyor_BC ‚Üí StationC ‚Üí Conveyor_CQ ‚Üí QualityCheck ‚Üí [AGV] ‚Üí Warehouse
```

- ‰∫ßÂìÅ P3

```
RawMaterial ‚Üí [AGV] ‚Üí StationA ‚Üí Conveyor_AB ‚Üí StationB ‚Üí Conveyor_BC ‚Üí StationC ‚Üí Conveyor_CQ[upper/lower buffer] ‚Üí [AGV] ‚Üí StationB ‚Üí Conveyor_BC ‚Üí StationC ‚Üí Conveyor_CQ ‚Üí QualityCheck ‚Üí [AGV] ‚Üí Warehousse
```

3. AGV Âä®‰ΩúÊìçÊéßÊó∂‰ºöÊ∂àËÄóÁîµÈáèÔºåÂú®ÁßªÂä®ÂâçÊ£ÄÊü•Â¶ÇÊûúÂΩìÂâçÁîµÈáè‰∏çË∂≥‰ª•ÂÆåÊàêÂä®‰ΩúÔºåAGV ‰ºöËá™Âä®ËøîÂõûÂÖÖÁîµÁ´ôÂÖÖÁîµ„ÄÇ
4. KPI ÊåáÊ†á

| Á±ªÂà´         | ÊåáÊ†á         | ËÆ°ÁÆóÂÖ¨Âºè                                      |
| :----------- | :----------- | :-------------------------------------------- |
| **Áîü‰∫ßÊïàÁéá** | ËÆ¢ÂçïÂÆåÊàêÁéá   | `ÊåâÊó∂ÂÆåÊàêËÆ¢ÂçïÊï∞ / ÊÄªËÆ¢ÂçïÊï∞ √ó 100%`            |
|              | Áîü‰∫ßÂë®ÊúüÊïàÁéá | `ÂÆûÈôÖÁîü‰∫ßÊó∂Èó¥ / ÁêÜËÆ∫Áîü‰∫ßÊó∂Èó¥`ÔºàÂê´ÂÆåÊàêÁéáÊùÉÈáçÔºâ |
|              | ËÆæÂ§áÂà©Áî®Áéá   | `ËÆæÂ§áÂ∑•‰ΩúÊó∂Èó¥ / ÊÄªÊó∂Èó¥ √ó 100%`                |
| **Ë¥®ÈáèÊàêÊú¨** | ‰∏ÄÊ¨°ÈÄöËøáÁéá   | `‰∏ÄÊ¨°ÈÄöËøáË¥®Ê£ÄÊï∞ / ÊÄª‰∫ßÂìÅÊï∞ √ó 100%`            |
|              | Áîü‰∫ßÊàêÊú¨     | `Œ£(Áâ©Êñô+ËÉΩÊ∫ê+Áª¥‰øÆ+Êä•Â∫üÊàêÊú¨)`                  |
| **AGV ÊïàÁéá** | ÂÖÖÁîµÁ≠ñÁï•     | `‰∏ªÂä®ÂÖÖÁîµÊ¨°Êï∞ / ÊÄªÂÖÖÁîµÊ¨°Êï∞ √ó 100%`            |
|              | ËÉΩÊ∫êÊïàÁéá     | `ÂÆåÊàê‰ªªÂä°Êï∞ / ÊÄªÂÖÖÁîµÊó∂Èó¥`                     |
|              | AGV Âà©Áî®Áéá   | `ËøêËæìÊó∂Èó¥ / (ÊÄªÊó∂Èó¥-ÊïÖÈöú-ÂÖÖÁîµ) √ó 100%`        |

5. Á´ûËµõËØÑÂàÜÁ≥ªÁªüÔºà100 ÂàÜÂà∂Ôºâ

- **Áîü‰∫ßÊïàÁéá**Ôºà40 ÂàÜÔºâÔºöËÆ¢ÂçïÂÆåÊàêÁéá 16 ÂàÜ + Âë®ÊúüÊïàÁéá 16 ÂàÜ + ËÆæÂ§áÂà©Áî®Áéá 8 ÂàÜ
- **Ë¥®ÈáèÊàêÊú¨**Ôºà30 ÂàÜÔºâÔºö‰∏ÄÊ¨°ÈÄöËøáÁéá 12 ÂàÜ + ÊàêÊú¨ÊéßÂà∂ 18 ÂàÜ
- **AGV ÊïàÁéá**Ôºà30 ÂàÜÔºâÔºöÂÖÖÁîµÁ≠ñÁï• 9 ÂàÜ + ËÉΩÊïàÊØî 12 ÂàÜ + Âà©Áî®Áéá 9 ÂàÜ

## 3. ÂäüËÉΩ‰∏éÊû∂ÊûÑ

### 3.1 Ê†∏ÂøÉÂ∑•‰ΩúÊµÅÔºöÂ§ñÈÉ® JSON Êé•Âè£ÔºåÂÜÖÈÉ®Ëá™ÁÑ∂ËØ≠Ë®ÄÈ©±Âä®

‰ªøÁúüÁéØÂ¢É‰∏éÈÄâÊâã Agent ‰πãÈó¥ÈÄöËøáÁªìÊûÑÂåñÁöÑ JSON Ê∂àÊÅØËøõË°åÈÄö‰ø°ÔºåÊàë‰ª¨Ë¶ÅÊ±ÇÈÄâÊâãÂú®Ëá™Â∑±ÁöÑ Agent ÂÜÖÈÉ®ÊûÑÂª∫Ëá™ÁÑ∂ËØ≠Ë®ÄÂ§ÑÁêÜËÉΩÂäõÔºåÂΩ¢Êàê `JSON -> NL -> JSON` ÁöÑÂÆåÊï¥ÂÜ≥Á≠ñÈìæË∑Ø„ÄÇ

```mermaid
sequenceDiagram
    participant D as Device (SimPy)
    participant M as MQTT Broker
    participant A as AI Agent (ÈÄâÊâã‰ª£Á†Å)

    D->>M: PUBLISH (NLDF/station/StationA/status)<br>{"status":"IDLE", ...}
    M->>A: SUBSCRIBE
    A->>A: **ÂÜÖÈÉ®ÂÆûÁé∞: JSON -> Ëá™ÁÑ∂ËØ≠Ë®Ä -> ÂÜ≥Á≠ñ -> JSON**
    A->>M: PUBLISH (agent/commands)<br>{"action": "unload_to_station", ...}
    M->>D: **ÊâßË°å‰ªøÁúüÂä®‰Ωú**
```

### 3.2 MQTT ÈÄö‰ø°Â±Ç

#### Topic Êû∂ÊûÑ (`NLDF_DEFAULT` will be replaced by use environment variable `TOPIC_ROOT`)

| Topic                                         | Agent ÊùÉÈôê    | ÊèèËø∞                            | Ê∂àÊÅØÊ†ºÂºè (Payload) |
| :-------------------------------------------- | :------------ | :------------------------------ | :----------------- |
| `NLDF_DEFAULT/{line_id}/station/{id}/status`  | **Subscribe** | ËÆ¢ÈòÖÊâÄÊúâÂ∑•Á´ôÁöÑÁä∂ÊÄÅ              | JSON (ÁªìÊûÑÂåñ)      |
| `NLDF_DEFAULT/{line_id}/agv/{id}/status`      | **Subscribe** | ËÆ¢ÈòÖÊâÄÊúâ AGV ÁöÑÁä∂ÊÄÅ             | JSON (ÁªìÊûÑÂåñ)      |
| `NLDF_DEFAULT/{line_id}/conveyor/{id}/status` | **Subscribe** | ËÆ¢ÈòÖÊâÄÊúâ‰º†ÈÄÅÂ∏¶ÁöÑÁä∂ÊÄÅ            | JSON (ÁªìÊûÑÂåñ)      |
| `NLDF_DEFAULT/warehouse/{id}/status`          | **Subscribe** | ËÆ¢ÈòÖÊâÄÊúâ‰ªìÂ∫ìÁöÑÁä∂ÊÄÅ              | JSON (ÁªìÊûÑÂåñ)      |
| :---                                          | :---          | :---                            | :---               |
| `NLDF_DEFAULT/{line_id}/alerts`               | **Subscribe** | ËÆ¢ÈòÖÊâÄÊúâËÆæÂ§áÊïÖÈöúË≠¶Êä•            | JSON (ÁªìÊûÑÂåñ)      |
| `NLDF_DEFAULT/orders/status`                  | **Subscribe** | Êé•Êî∂Êñ∞ËÆ¢Âçï‰ø°ÊÅØ                  | JSON (ÁªìÊûÑÂåñ)      |
| `NLDF_DEFAULT/kpi/status`                     | **Subscribe** | ËÆ¢ÈòÖ KPI Êõ¥Êñ∞                   | JSON (ÁªìÊûÑÂåñ)      |
| `NLDF_DEFAULT/result/status`                  | **Subscribe** | ËÆ¢ÈòÖÁªìÊûúÊõ¥Êñ∞                    | JSON (ÁªìÊûÑÂåñ)      |
| :---                                          | :---          | :---                            | :---               |
| `NLDF_DEFAULT/command/{line_id}`              | **Publish**   | ÂèëÂ∏ÉÈÄâÊâã Agent ÁîüÊàêÁöÑÁªìÊûÑÂåñÊåá‰ª§ | JSON (ÁªìÊûÑËßÅ‰∏ãÊñá)  |
| `NLDF_DEFAULT/response/{line_id}`             | **Subscribe** | Êé•Êî∂ÈÄâÊâã Agent ÁöÑÂìçÂ∫î           | JSONÔºàÁªìÊûÑËßÅ‰∏ãÊñáÔºâ |

ÈÄâÊâãÂèëÂæÄ `NLDF_DEFAULT/command/{line_id}` ÁöÑÊ∂àÊÅØ**ÂøÖÈ°ª**ÊòØ‰ª•‰∏ãÊ†ºÂºèÁöÑ JSON Â≠óÁ¨¶‰∏≤Ôºö

```json
{
  "command_id": "str (ÂèØÈÄâÂ≠óÊÆµÔºåÁî®‰∫éËÆ∞ÂΩïÂÜ≥Á≠ñËøáÁ®ã)",
  "action": "str (ÂøÖÈ°ªÊòØÊîØÊåÅÁöÑÂä®‰Ωú‰πã‰∏Ä)",
  "target": "str (Âä®‰ΩúÁöÑÁõÆÊ†áËÆæÂ§áIDÔºåÂèØÈÄâ)",
  "params": {
    "key1": "value1", ...
  }
}
```

Á≥ªÁªüÂèçÈ¶à `response/{line_id}` ÁöÑÊ∂àÊÅØÂ¶Ç‰∏ãÔºö

```json
{
  "timestamp": "float (‰ªøÁúüÊó∂Èó¥Êà≥)",
  "command_id": "str (Êù•Ëá™‰∫éÈÄâÊâãÁöÑcommand_id)",
  "response": "str (ÂèçÈ¶à‰ø°ÊÅØ)"
}
```

ÊîØÊåÅÁöÑÊåá‰ª§ `action` ÂíåÊâÄÈúÄ `params`Ôºåcommand_id is optional, can be ignored.

| Action       | ÊèèËø∞                                                                               | Target | Á§∫‰æã                                                                                                                                                                                |
| :----------- | :--------------------------------------------------------------------------------- | :----- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `move`       | ÂëΩ‰ª§ AGV ÁßªÂä®Âà∞ÊåáÂÆöË∑ØÂæÑÁÇπ                                                          | AGV ID | `{'command_id': 'move_688777', 'action': 'move', 'target': 'AGV_1', 'params': {'target_point': 'P1'}}`                                                                              |
| `charge`     | ÂëΩ‰ª§ AGV ‰∏ªÂä®ÂÖÖÁîµ                                                                  | AGV ID | `{'command_id': 'charge_688777', 'action': 'charge', 'target': 'AGV_1', 'params': {'target_level': 70.0}}`(default: 80.0)                                                           |
| `unload`     | ÂëΩ‰ª§ AGV Âç∏ËΩΩ‰∫ßÂìÅÂà∞ÊåáÂÆöÂ∑•Á´ô                                                        | AGV ID | `{'command_id': 'unload_688777', 'action': 'unload', 'target': 'AGV_2', 'params': {}}`                                                                                              |
| `load`       | ÂëΩ‰ª§ AGV ‰ªéÊåáÂÆöÂ∑•Á´ôË£ÖËΩΩ‰∫ßÂìÅ                                                        | AGV ID | `{'command_id': 'load_688777', 'action': 'load', 'target': 'AGV_1', 'params': {'product_id': 'prod_1_1ee7ce46'}}`(Product ID only can be used in RawMaterial, else will be ignored) |
| ÂÖ®Â±Ä action  | topic ‰∏≠ÁöÑ line_id Âíå payload ‰∏≠ÁöÑ target Â≠óÊÆµÂÜÖÂÆπÂèØ‰ª•ÂøΩÁï•Ôºå‰ªÖ‰∏∫Ëøá schema Ê†ºÂºèÂÆ°Ê†∏ | ÂÖ®Â±Ä   | :---                                                                                                                                                                                |
| `get_result` | Ëé∑ÂèñÂΩìÂâçÊï¥‰∏™Â∑•ÂéÇÁöÑ KPI ÁªìÊûú                                                        | any    | `{'command_id': 'get_result_688777', 'action': 'get_result', 'target': my factoty', 'params': {}}`                                                                                  |

## 4.ËØÑ‰ª∑Áª¥Â∫¶

Èô§‰∫Ü ADVX ÁöÑÁªü‰∏ÄËØÑ‰ª∑Áª¥Â∫¶Â§ñÔºåÊàë‰ª¨Â∞Ü‰ªé‰ª•‰∏ãÂõõ‰∏™ÊñπÈù¢ÂØπ‰Ω†ÁöÑÈ°πÁõÆËøõË°åÁ≠âÊùÉÈáçËØÑ‰ª∑Ôºö

1. **KPI ÂæóÂàÜ**

   - ËøôÊòØÊúÄÁõ¥Êé•‰∏îÂÆ¢ËßÇÁöÑËØÑ‰ª∑Ê†áÂáÜ„ÄÇÊàë‰ª¨Â∞ÜÊ†πÊçÆ‰Ω†Êê≠Âª∫ÁöÑ Agent Âú®È¢ÑÂÆö‰πâ KPI ÊåáÊ†á‰∏äÁöÑË°®Áé∞ËøõË°åËØÑÂàÜ„ÄÇ
   - _Ê≥®ÊÑèÔºöÂ¶ÇÊûú‰Ω†ÂØπËôöÊãüÂ∑•ÂéÇËøõË°å‰∫Ü‰øÆÊîπÔºåÊàë‰ª¨‰ºöÁªºÂêàËÄÉËôëËøô‰∫õÊîπÂä®ÂØπ KPI ÂæóÂàÜÁöÑÂΩ±Âìç„ÄÇ_

2. **LLM Agent Â∑•Á®ãËÉΩÂäõ**

   - ‰Ω†ÈúÄË¶ÅËÆæËÆ°Êàñ‰ΩøÁî®‰∏Ä‰∏™Ê°ÜÊû∂Ôºå‰Ωø LLM ËÉΩÂ§üÈÄöËøá MQTT + JSON ‰∏éËôöÊãüÂ∑•ÂéÇÈ´òÊïà‰∫§‰∫í„ÄÇ
   - Êàë‰ª¨Â∞ÜÈáçÁÇπËÄÉÂØü‰Ω†Âú®‰∏ä‰∏ãÊñáÁÆ°ÁêÜ„ÄÅÁä∂ÊÄÅÁÆ°ÁêÜ„ÄÅÈîôËØØÂ§ÑÁêÜÁ≠âÂÖ≥ÈîÆÊú∫Âà∂‰∏äÁöÑÂÆûÁé∞„ÄÇ
   - ‰ºòÈõÖ„ÄÅÂÅ•Â£ÆÁöÑ Agent Â∑•Á®ãËÆæËÆ°Â∞ÜËé∑ÂæóÈ¢ùÂ§ñÂä†ÂàÜ„ÄÇ

3. **ËôöÊãüÂ∑•ÂéÇÁöÑÊîπËøõ**

   - ËôöÊãüÂ∑•ÂéÇÂü∫‰∫é Simpy ÂÆûÁé∞ÔºåÊ®°Êãü‰∫ÜÁúüÂÆû‰∏ñÁïåÁöÑÈ´òÁ∫ßÊéíÁ®ãÔºàAdvanced SchedulingÔºâÈóÆÈ¢ò„ÄÇ
   - Â¶ÇÊûú‰Ω†ÂèëÁé∞Â∑•ÂéÇÂ≠òÂú®‰∏çÂêàÁêÜ‰πãÂ§ÑÔºåÂèØ‰ª•Áõ¥Êé•‰øÆÊîπÊàñÊâ©Â±ïÂÖ∂ËøêË°åÊú∫Âà∂Ôºå‰ΩøÂÖ∂Êõ¥Ë¥¥ËøëÁúüÂÆûÂ∑•ÂéÇ„ÄÇ
   - _Â¶ÇÂØπËôöÊãüÂ∑•ÂéÇÊúâ‰ªª‰Ωï‰øÆÊîπÔºåËØ∑Âä°ÂøÖÂú®È°πÁõÆ README ‰∏≠ÊòæËëóÊ≥®Êòé„ÄÇ_

4. **supOS-CE ÂºÄÊ∫êÊ°ÜÊû∂ÁöÑÂ∫îÁî®**

   - ÊàêÂäüÈÉ®ÁΩ≤ supOS-CEÔºåÂπ∂‰ΩøÁî®ÂÖ∂Ëá™Â∏¶ÁöÑ MQTT Broker ‰Ωú‰∏∫ËôöÊãüÂ∑•ÂéÇ‰∏é Agent ÁöÑÈÄö‰ø°Êé•Âè£ÔºåÂ∞ÜËé∑ÂæóÂä†ÂàÜ„ÄÇ
   - Â¶ÇÊûú‰Ω†Ëøõ‰∏ÄÊ≠•ÈõÜÊàê‰∫Ü supOS-CE ÁöÑÂÖ∂‰ªñÁªÑ‰ª∂ÔºàÂ¶Ç NodeRED„ÄÅPortainer Á≠âÔºâÔºåÊàñÂèëÁé∞Âπ∂ÂèçÈ¶à‰∫ÜÂÖ∂ÈóÆÈ¢ò/bugÔºå‰πü‰ºöËé∑ÂæóÈ¢ùÂ§ñÂä†ÂàÜ„ÄÇ

   - > [supos ÈÄâÊâã‰ΩøÁî®ÊñπÊ≥ï](https://ofra65wfwe.feishu.cn/wiki/SRgrwj9LWimsTikRFdzcVvlDnEU)

---



================================================
File: pyproject.toml
================================================
[project]
name = "supcon-adventurex-factory-sim"
version = "1.0.0"
description = "Backend simulation environment for the SUPCON Hackathon"
authors = [{ name = "SUPCON R&D Team" }]
dependencies = [
    "simpy",
    "paho-mqtt",
    "pydantic",
    "pyyaml",
    "numpy",
    "psutil",
]
requires-python = ">=3.9"

# Add package configuration for proper import resolution
[tool.setuptools]
packages = ["src"]

[tool.setuptools.package-dir]
"" = "."

[build-system]
requires = ["setuptools", "wheel"]
build-backend = "setuptools.build_meta"

[tool.uv]
dev-dependencies = [
    "pytest",
]

[tool.pyright]
include = ["src"]
exclude = ["**/__pycache__"]
typeCheckingMode = "basic"

[tool.ruff]
line-length = 88
select = ["E", "F", "W", "I"]
ignore = []

[tool.ruff.format]
quote-style = "double"



================================================
File: run_multi_line_simulation.py
================================================
# run_multi_line_simulation.py
import os
import sys
import argparse
import threading

# Add the project root to Python path
project_root = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, project_root)

from src.utils.mqtt_client import MQTTClient
from src.simulation.factory_multi import Factory
from src.utils.config_loader import load_factory_config
from config.settings import MQTT_BROKER_HOST, MQTT_BROKER_PORT, SIMULATION_SPEED
import logging
from config.settings import LOG_LEVEL
from src.agent_interface.multi_line_command_handler import MultiLineCommandHandler
from src.user_input_multi import menu_input_thread
from typing import Optional
import time

logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class MultiLineFactorySimulation:
    """
    Main orchestrator class that combines all components of the factory simulation.
    """
    
    def __init__(self):
        self.factory: Optional[Factory] = None
        self.mqtt_client: Optional[MQTTClient] = None
        self.command_handler: Optional[MultiLineCommandHandler] = None
        self.running = False

    def initialize(self, no_faults=False, no_mqtt=False):
        """Initialize all simulation components."""
        logger.info("üè≠ Initializing Multi-Line Factory Simulation...")
        # ‰ºòÂÖà‰ΩøÁî® CLIENT_IDÔºåÂÖ∂Ê¨° USERNAME/USERÔºåÊúÄÂêéÈªòËÆ§ÂÄºÔºåÁ°Æ‰øù client_name ‰∏ÄÂÆö‰∏∫ str
        client_name = (
            os.getenv("TOPIC_ROOT")
            or os.getenv("USERNAME")
            or os.getenv("USER")
            or "NLDF_TEST"
        )
        self.mqtt_client = MQTTClient(MQTT_BROKER_HOST, MQTT_BROKER_PORT, client_name)
        
        # Connect to MQTT
        logger.info(f"üì° Connecting to MQTT broker at {MQTT_BROKER_HOST}:{MQTT_BROKER_PORT}, client_name: {client_name}")

        if not no_mqtt:
            self.mqtt_client.connect()
            # Wait for MQTT client to be fully connected
            max_retries = 20
            retry_interval = 0.5
            for i in range(max_retries):
                if self.mqtt_client.is_connected():
                    logger.info("‚úÖ MQTT client is fully connected.")
                    break
                logger.info(f"Waiting for MQTT connection... ({i+1}/{max_retries})")
                time.sleep(retry_interval)
            else:
                logger.error("‚ùå Failed to connect to MQTT broker within the given time. Exiting simulation.")
                raise ConnectionError("MQTT connection failed.")

        try:
            layout_config = load_factory_config('factory_layout_multi.yml')
            print(f"‚úÖ Successfully loaded multi-line factory configuration from layout_config")
        except Exception as e:
            print(f"‚ùå Failed to load multi-line factory configuration: {e}")
            raise e
        
        self.factory = Factory(layout_config, self.mqtt_client, no_faults=no_faults) # no_faults for cleaner testing
        logger.info(f"‚úÖ Factory created with {len(self.factory.lines)} lines")
        
        # Create command handler (this will start listening for commands)
        self.command_handler = MultiLineCommandHandler(self.factory, self.mqtt_client, self.factory.topic_manager)
        logger.info("üéØ Command handler initialized and listening for agent commands")
    
    def run(self, duration: Optional[int] = None):
        """Run the simulation."""
        if self.factory is None:
            logger.error("‚ùå Factory is not initialized. Call initialize() first.")
            return

        logger.info("üöÄ Starting Factory Simulation...")
        self.running = True
        
        try:
            if duration:
                logger.info(f"‚è±Ô∏è  Running simulation for {duration} seconds")
                self.factory.run(until=duration)
                # For fixed duration, print scores after normal completion
                # self.factory.print_final_scores()
            else:
                logger.info("üîÑ Running simulation indefinitely (Ctrl+C to stop)")
                while self.running:
                    # Run simulation for 1 second at a time
                    self.factory.run(until=int(self.factory.env.now) + 1)
                    time.sleep(1 / SIMULATION_SPEED)  # Small delay to prevent busy waiting
                    
        except KeyboardInterrupt:
            logger.info("üõë Simulation interrupted by user")
            # Scores will be printed in shutdown()
        except Exception as e:
            logger.error(f"‚ùå Simulation error: {e}")
        finally:
            # For indefinite runs or errors, print scores during shutdown
            if not duration:
                self.shutdown()
            else:
                # For fixed duration runs, just clean up without printing scores again
                logger.info("üßπ Cleaning up resources...")
                self.running = False
                if self.mqtt_client:
                    self.mqtt_client.disconnect()
                logger.info("üëã Factory Simulation stopped")

    def shutdown(self):
        """Clean up resources."""
        logger.info("üßπ Shutting down Factory Simulation...")
        self.running = False
        
        # # Print final scores when shutting down
        # if self.factory:
        #     self.factory.print_final_scores()
        
        if self.mqtt_client:
            self.mqtt_client.disconnect()
            
        logger.info("üëã Factory Simulation stopped")

def run_simulation_multi():
    """Runs the multi-line factory simulation."""
    parser = argparse.ArgumentParser(description="SUPCON Multi-Line Factory Simulation Launcher")
    parser.add_argument(
        "--menu",
        action="store_true",
        help="Enable the interactive menu for manual control."
    )
    parser.add_argument(
        "--no-mqtt",
        action="store_true",
        help="Ignore mqtt connection for offline test"
    )
    parser.add_argument(
        "--no-fault",
        action="store_true",
        help="Disable random fault injection in the simulation."
    )
    args = parser.parse_args()

    simulation = MultiLineFactorySimulation()
    simulation.initialize(no_faults=args.no_fault, no_mqtt=args.no_mqtt)
    
    if args.menu and simulation.factory and simulation.factory.topic_manager:
        threading.Thread(target=menu_input_thread, args=(simulation.mqtt_client, simulation.factory, simulation.factory.topic_manager), daemon=True).start()
        logger.info("Interactive menu enabled. Type commands in the console.")

    simulation.run()  # Run indefinitely

if __name__ == '__main__':
    run_simulation_multi()



================================================
File: task_scheduler.py
================================================
import os
import paho.mqtt.client as mqtt
import json
import logging
import time
import csv
from datetime import datetime
from collections import deque
from typing import Dict, Any, Optional, List, Tuple
from itertools import cycle

# --- Configuration ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger("TaskSchedulerAgent")

MQTT_BROKER_HOST = os.getenv("MQTT_BROKER_HOST", "supos-ce-instance4.supos.app")
MQTT_BROKER_PORT = int(os.getenv("MQTT_BROKER_PORT", 1883))
TOPIC_ROOT = os.getenv("TOPIC_ROOT") or os.getenv("USERNAME") or os.getenv("USER") or "marks"

# --- Constants ---
LOCATION_MAPPING = {
    "RawMaterial": "P0",
    "StationA": "P1",
    "QualityCheck_output": "P8",
    "Warehouse": "P9"
}
FACTORY_LINES = ["line1", "line2", "line3"]
AGV_CAPACITY = 2
AGV_ROLES = {
    "AGV_1": "feeder",       # RawMaterial -> StationA
    "AGV_2": "finisher"      # QualityCheck -> Warehouse
}

class TaskScheduler:
    """
    An intelligent agent that schedules factory AGV tasks based on predefined roles
    and optimizes for multi-product transport.
    """
    def __init__(self, broker_host: str, broker_port: int, topic_root: str):
        self.topic_root = topic_root
        self.client_id = f"{topic_root}_task_scheduler_agent_{int(time.time())}"
        
        # --- State Management ---
        self.feeder_tasks: Dict[str, deque] = {line: deque() for line in FACTORY_LINES}
        self.finisher_tasks: Dict[str, deque] = {line: deque() for line in FACTORY_LINES}
        
        self.agv_states: Dict[str, Dict[str, Any]] = {}
        self.agv_jobs: Dict[str, Dict[str, Any]] = {}
        self.tasks_created_for_product: set[str] = set()
        
        self.line_cycler = cycle(FACTORY_LINES)
        
        # --- KPI Data Storage ---
        self.latest_kpi_data: Optional[Dict[str, Any]] = None

        # --- MQTT Client ---
        self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, self.client_id)
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        
        logger.info(f"Connecting to MQTT Broker {broker_host}:{broker_port}")
        self.client.connect(broker_host, broker_port, 60)

    def on_connect(self, client, userdata, flags, rc, properties):
        if rc == 0:
            logger.info("Successfully connected to MQTT Broker!")
            self._subscribe_to_topics()
        else:
            logger.error(f"Failed to connect, return code: {rc}")

    def _subscribe_to_topics(self):
        """Subscribe to all necessary topics."""
        topics = [
            (f"{self.topic_root}/warehouse/RawMaterial/status", 1),
            (f"{self.topic_root}/+/station/QualityCheck/status", 1),
            (f"{self.topic_root}/+/agv/+/status", 1),
            (f"{self.topic_root}/response/+", 1),
            (f"{self.topic_root}/kpi/status", 1)
        ]
        for topic, qos in topics:
            logger.info(f"Subscribing to topic: {topic}")
            self.client.subscribe(topic, qos)

    def on_message(self, client, userdata, msg):
        """Main message handler, routes messages to specific handlers."""
        try:
            topic = msg.topic
            payload = json.loads(msg.payload.decode('utf-8'))
            
            if "kpi/status" in topic: self.handle_kpi_status(payload)
            elif "RawMaterial/status" in topic: self.handle_raw_material_status(payload)
            elif "QualityCheck/status" in topic: self.handle_quality_check_status(topic.split('/')[1], payload)
            elif "agv" in topic and "status" in topic: self.handle_agv_status(topic.split('/')[1], topic.split('/')[3], payload)
            elif "response" in topic: logger.debug(f"Command response received: {payload.get('response')}")
        except Exception as e:
            logger.error(f"Error processing message from topic '{msg.topic}': {e}", exc_info=True)

    def handle_kpi_status(self, payload: Dict[str, Any]):
        self.latest_kpi_data = payload

    def handle_raw_material_status(self, payload: Dict[str, Any]):
        """Creates feeder tasks for new products in the RawMaterial warehouse."""
        for product_id in payload.get("buffer", []):
            self.add_task(product_id, "RawMaterial", "StationA")

    def handle_quality_check_status(self, line_id: str, payload: Dict[str, Any]):
        """Creates finisher tasks for products in the QualityCheck output buffer."""
        for product_id in payload.get("output_buffer", []):
            self.add_task(product_id, "QualityCheck_output", "Warehouse", line_id)

    def handle_agv_status(self, line_id: str, agv_id: str, payload: Dict[str, Any]):
        """Updates AGV state and triggers scheduling or next job step."""
        full_agv_id = f"{line_id}_{agv_id}"
        old_state = self.agv_states.get(full_agv_id, {})
        new_status = payload.get("status")
        
        self.agv_states[full_agv_id] = {
            "status": new_status,
            "current_point": payload.get("current_point"),
            "payload": payload.get("payload", []),
            "line_id": line_id,
            "agv_id": agv_id,
            "role": AGV_ROLES.get(agv_id)
        }
        
        if (old_state.get("status") != "idle" and new_status == "idle") or (not old_state and new_status == "idle"):
            logger.info(f"AGV {full_agv_id} is now idle at {payload.get('current_point')}. Checking for work.")
            if full_agv_id in self.agv_jobs: self.execute_next_step(full_agv_id)
            else: self.schedule_tasks()

    def add_task(self, product_id: str, from_loc: str, to_loc: str, line_id: Optional[str] = None):
        """Adds a new task to the appropriate role-based queue."""
        if product_id in self.tasks_created_for_product: return
        
        if from_loc == "RawMaterial":
            # Assign feeder tasks to lines in a round-robin fashion
            target_line = next(self.line_cycler)
            self.feeder_tasks[target_line].append(product_id)
            logger.info(f"„ÄêÊñ∞ Feeder ‰ªªÂä°„Äë‰∫ßÁ∫ø {target_line}: ‰ªé {from_loc} Âà∞ {to_loc}Ôºå‰∫ßÂìÅ: {product_id}")
        elif from_loc == "QualityCheck_output" and line_id:
            self.finisher_tasks[line_id].append(product_id)
            logger.info(f"„ÄêÊñ∞ Finisher ‰ªªÂä°„Äë‰∫ßÁ∫ø {line_id}: ‰ªé {from_loc} Âà∞ {to_loc}Ôºå‰∫ßÂìÅ: {product_id}")

        self.tasks_created_for_product.add(product_id)
        self.schedule_tasks()

    def schedule_tasks(self):
        """Iterates through idle AGVs and assigns them tasks based on their role."""
        idle_agvs = [agv_id for agv_id, state in self.agv_states.items() if state['status'] == 'idle' and agv_id not in self.agv_jobs]
        
        for agv_id in idle_agvs:
            state = self.agv_states[agv_id]
            role = state.get("role")
            line_id = state.get("line_id")
            
            task_products = []
            if role == "feeder" and self.feeder_tasks[line_id]:
                while len(task_products) < AGV_CAPACITY and self.feeder_tasks[line_id]:
                    task_products.append(self.feeder_tasks[line_id].popleft())
                from_loc, to_loc = "RawMaterial", "StationA"
                
            elif role == "finisher" and self.finisher_tasks[line_id]:
                while len(task_products) < AGV_CAPACITY and self.finisher_tasks[line_id]:
                    task_products.append(self.finisher_tasks[line_id].popleft())
                from_loc, to_loc = "QualityCheck_output", "Warehouse"

            if task_products:
                self.agv_jobs[agv_id] = {
                    "products": task_products,
                    "from": from_loc, "to": to_loc,
                    "step": "start"
                }
                logger.info(f"„Äê‰ªªÂä°ÂàÜÈÖç„ÄëAGV {agv_id} ({role}) ÂàÜÈÖçÂà∞‰ªªÂä°: ËøêÈÄÅ {len(task_products)} ‰∏™‰∫ßÂìÅ ({', '.join(task_products)}) ‰ªé {from_loc} Âà∞ {to_loc}")
                self.execute_next_step(agv_id)

    def execute_next_step(self, full_agv_id: str):
        """Manages the multi-step execution of a job for an AGV."""
        job, agv_state = self.agv_jobs.get(full_agv_id), self.agv_states[full_agv_id]
        if not job: self.schedule_tasks(); return

        line_id, agv_id = agv_state["line_id"], agv_state["agv_id"]
        from_loc, to_loc, products = job["from"], job["to"], job["products"]
        step, pickup_point, dropoff_point = job["step"], LOCATION_MAPPING[from_loc], LOCATION_MAPPING[to_loc]

        if step == "start":
            job["step"] = "moving_to_pickup"
            logger.info(f"  [Ê≠•È™§ 1] AGV {full_agv_id}: ÂâçÂæÄÂèñË¥ßÁÇπ {pickup_point} ({from_loc})")
            self.send_move_command(line_id, agv_id, pickup_point)
        
        elif step == "moving_to_pickup" and agv_state["current_point"] == pickup_point:
            job["step"] = "loading"
            logger.info(f"  [Ê≠•È™§ 2] AGV {full_agv_id}: Âà∞ËææÂèñË¥ßÁÇπÔºåÂºÄÂßãË£ÖËΩΩ {len(products)} ‰∏™‰∫ßÂìÅ")
            self.send_load_command(line_id, agv_id, products[0] if from_loc == "RawMaterial" else None)

        elif step == "loading":
            if len(agv_state["payload"]) < len(products):
                next_product_idx = len(agv_state["payload"])
                logger.info(f"  [Ê≠•È™§ 2.{next_product_idx+1}] AGV {full_agv_id}: ÁªßÁª≠Ë£ÖËΩΩÁ¨¨ {next_product_idx+1} ‰∏™‰∫ßÂìÅ")
                self.send_load_command(line_id, agv_id, products[next_product_idx] if from_loc == "RawMaterial" else None)
            else:
                job["step"] = "moving_to_dropoff"
                logger.info(f"  [Ê≠•È™§ 3] AGV {full_agv_id}: Ë£ÖËΩΩÂÆåÊàêÔºåÂâçÂæÄÂç∏Ë¥ßÁÇπ {dropoff_point} ({to_loc})")
                self.send_move_command(line_id, agv_id, dropoff_point)

        elif step == "moving_to_dropoff" and agv_state["current_point"] == dropoff_point:
            job["step"] = "unloading"
            logger.info(f"  [Ê≠•È™§ 4] AGV {full_agv_id}: Âà∞ËææÂç∏Ë¥ßÁÇπÔºåÂºÄÂßãÂç∏ËΩΩ")
            self.send_unload_command(line_id, agv_id)

        elif step == "unloading":
            if agv_state["payload"]:
                logger.info(f"  [Ê≠•È™§ 4.{len(products) - len(agv_state['payload'])}] AGV {full_agv_id}: ÁªßÁª≠Âç∏ËΩΩ")
                self.send_unload_command(line_id, agv_id)
            else:
                logger.info(f"„Äê‰ªªÂä°ÂÆåÊàê„ÄëAGV {full_agv_id} ÂÆåÊàê‰∫ÜËøêÈÄÅ {', '.join(products)} ÁöÑ‰ªªÂä°„ÄÇ")
                for pid in products: self.tasks_created_for_product.discard(pid)
                del self.agv_jobs[full_agv_id]
                self.schedule_tasks()
    
    def _send_command(self, line_id: str, command: Dict[str, Any]):
        topic = f"{self.topic_root}/command/{line_id}"
        command_id = f"{command['action']}_{command['target']}_{int(time.time() * 1000)}"
        payload = json.dumps({"command_id": command_id, **command})
        logger.info(f"ÂèëÂ∏ÉÊåá‰ª§Âà∞ '{topic}': {payload}")
        self.client.publish(topic, payload, qos=1)

    def send_move_command(self, line_id: str, agv_id: str, target_point: str):
        self._send_command(line_id, {"action": "move", "target": agv_id, "params": {"target_point": target_point}})

    def send_load_command(self, line_id: str, agv_id: str, product_id: Optional[str]):
        self._send_command(line_id, {"action": "load", "target": agv_id, "params": {"product_id": product_id} if product_id else {}})

    def send_unload_command(self, line_id: str, agv_id: str):
        self._send_command(line_id, {"action": "unload", "target": agv_id, "params": {}})

    def calculate_and_save_kpi(self):
        if not self.latest_kpi_data: logger.warning("Ê≤°ÊúâKPIÊï∞ÊçÆÔºåÊó†Ê≥ïÁîüÊàêÊä•Âëä„ÄÇ"); return
        kpis = self.latest_kpi_data
        logger.info("Ê≠£Âú®ËÆ°ÁÆóÊúÄÁªàKPIÂæóÂàÜÂπ∂ÁîüÊàêÊä•Âëä...")
        weights = {'production_efficiency': 0.4, 'quality_cost': 0.3, 'agv_efficiency': 0.3}
        efficiency_weights = {'order_completion': 0.4, 'production_cycle': 0.4, 'device_utilization': 0.2}
        quality_cost_weights = {'first_pass_rate': 0.4, 'cost_efficiency': 0.6}
        agv_weights = {'charge_strategy': 0.3, 'energy_efficiency': 0.4, 'utilization': 0.3}
        production_cycle_score = min(100, 100 / max(1, kpis.get('average_production_cycle', 1))) if kpis.get('total_products', 0) > 0 else 0
        baseline_cost_per_product, total_products, total_cost = 25, kpis.get('total_products', 0), kpis.get('total_production_cost', 0)
        cost_efficiency_score = min(100, (baseline_cost_per_product * total_products) / max(1, total_cost) * 100) if total_products > 0 else 0
        efficiency_score = (kpis.get('order_completion_rate', 0) * efficiency_weights['order_completion'] + production_cycle_score * efficiency_weights['production_cycle'] + kpis.get('device_utilization', 0) * efficiency_weights['device_utilization']) * weights['production_efficiency']
        quality_cost_score = (kpis.get('first_pass_rate', 0) * quality_cost_weights['first_pass_rate'] + cost_efficiency_score * quality_cost_weights['cost_efficiency']) * weights['quality_cost']
        agv_energy_efficiency_score = min(100, kpis.get('agv_energy_efficiency', 0) * 1000)
        agv_score = (kpis.get('charge_strategy_efficiency', 0) * agv_weights['charge_strategy'] + agv_energy_efficiency_score * agv_weights['energy_efficiency'] + kpis.get('agv_utilization', 0) * agv_weights['utilization']) * weights['agv_efficiency']
        total_score = efficiency_score + quality_cost_score + agv_score
        
        filename = f"kpi_results_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv"
        report_data = {"ÊÄªÂæóÂàÜ": f"{total_score:.2f}", "Áîü‰∫ßÊïàÁéáÂæóÂàÜ (40%)": f"{efficiency_score:.2f}", **{f"  - {k}": f"{v:.2f}" for k, v in {"ËÆ¢ÂçïÂÆåÊàêÁéá (%)": kpis.get('order_completion_rate', 0), "Áîü‰∫ßÂë®ÊúüÊïàÁéáÂæóÂàÜ": production_cycle_score, "ËÆæÂ§áÂà©Áî®Áéá (%)": kpis.get('device_utilization', 0)}.items()}, "Ë¥®Èáè‰∏éÊàêÊú¨ÂæóÂàÜ (30%)": f"{quality_cost_score:.2f}", **{f"  - {k}": f"{v:.2f}" for k, v in {"‰∏ÄÊ¨°ÈÄöËøáÁéá (%)": kpis.get('first_pass_rate', 0), "ÊàêÊú¨ÊïàÁéáÂæóÂàÜ (‰º∞ÁÆó)": cost_efficiency_score}.items()}, "AGVÊïàÁéáÂæóÂàÜ (30%)": f"{agv_score:.2f}", **{f"  - {k}": f"{v:.2f}" for k, v in {"ÂÖÖÁîµÁ≠ñÁï•ÊïàÁéá (%)": kpis.get('charge_strategy_efficiency', 0), "ËÉΩÊïàÊØîÂæóÂàÜ": agv_energy_efficiency_score, "AGVÂà©Áî®Áéá (%)": kpis.get('agv_utilization', 0)}.items()}, "--- ÂéüÂßãÊï∞ÊçÆ ---": "---", **{k: v for k, v in {"ÊÄªËÆ¢ÂçïÊï∞": kpis.get('total_orders', 0), "Â∑≤ÂÆåÊàêËÆ¢ÂçïÊï∞": kpis.get('completed_orders', 0)}.items()}, **{k: f"${v:.2f}" for k, v in {"ÊÄªÁîü‰∫ßÊàêÊú¨": kpis.get('total_production_cost', 0), "Áâ©ÊñôÊàêÊú¨": kpis.get('material_costs', 0), "ËÉΩÊ∫êÊàêÊú¨": kpis.get('energy_costs', 0), "Áª¥‰øÆÊàêÊú¨": kpis.get('maintenance_costs', 0), "Êä•Â∫üÊàêÊú¨": kpis.get('scrap_costs', 0)}.items()}}
        try:
            with open(filename, 'w', newline='', encoding='utf-8-sig') as f:
                writer = csv.writer(f); writer.writerow(['KPI ÊåáÊ†á', 'ÂÄº']); writer.writerows(report_data.items())
            logger.info(f"KPIÊä•ÂëäÂ∑≤ÊàêÂäü‰øùÂ≠òÂà∞Êñá‰ª∂: {filename}")
        except IOError as e: logger.error(f"Êó†Ê≥ïÂÜôÂÖ•KPIÊä•ÂëäÊñá‰ª∂ {filename}: {e}")

    def run_forever(self):
        logger.info("‰ªªÂä°Ë∞ÉÂ∫¶AgentÂ∑≤ÂêØÂä®... (Êåâ Ctrl+C ÂÅúÊ≠¢)")
        try: self.client.loop_forever()
        except KeyboardInterrupt: logger.info("AgentË¢´ÊâãÂä®‰∏≠Êñ≠ÔºåÊ≠£Âú®ÂÖ≥Èó≠...")
        finally: self.calculate_and_save_kpi(); self.client.disconnect(); logger.info("MQTTÂ∑≤Êñ≠ÂºÄËøûÊé•„ÄÇ")

if __name__ == "__main__":
    scheduler = TaskScheduler(MQTT_BROKER_HOST, MQTT_BROKER_PORT, TOPIC_ROOT)
    scheduler.run_forever()


================================================
File: uv.lock
================================================
version = 1
revision = 1
requires-python = ">=3.9"
resolution-markers = [
    "python_full_version >= '3.11'",
    "python_full_version == '3.10.*'",
    "python_full_version < '3.10'",
]

[[package]]
name = "annotated-types"
version = "0.7.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ee/67/531ea369ba64dcff5ec9c3402f9f51bf748cec26dde048a2f973a4eea7f5/annotated_types-0.7.0.tar.gz", hash = "sha256:aff07c09a53a08bc8cfccb9c85b05f1aa9a2a6f23728d790723543408344ce89", size = 16081 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/78/b6/6307fbef88d9b5ee7421e68d78a9f162e0da4900bc5f5793f6d3d0e34fb8/annotated_types-0.7.0-py3-none-any.whl", hash = "sha256:1f02e8b43a8fbbc3f3e0d4f0f4bfc8131bcb4eebe8849b8e5c773f3a1c582a53", size = 13643 },
]

[[package]]
name = "colorama"
version = "0.4.6"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d8/53/6f443c9a4a8358a93a6792e2acffb9d9d5cb0a5cfd8802644b7b1c9a02e4/colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44", size = 27697 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/d1/d6/3965ed04c63042e047cb6a3e6ed1a63a35087b6a609aa3a15ed8ac56c221/colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6", size = 25335 },
]

[[package]]
name = "exceptiongroup"
version = "1.3.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions", marker = "python_full_version < '3.11'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/0b/9f/a65090624ecf468cdca03533906e7c69ed7588582240cfe7cc9e770b50eb/exceptiongroup-1.3.0.tar.gz", hash = "sha256:b241f5885f560bc56a59ee63ca4c6a8bfa46ae4ad651af316d4e81817bb9fd88", size = 29749 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/36/f4/c6e662dade71f56cd2f3735141b265c3c79293c109549c1e6933b0651ffc/exceptiongroup-1.3.0-py3-none-any.whl", hash = "sha256:4d111e6e0c13d0644cad6ddaa7ed0261a0b36971f6d23e7ec9b4b9097da78a10", size = 16674 },
]

[[package]]
name = "iniconfig"
version = "2.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f2/97/ebf4da567aa6827c909642694d71c9fcf53e5b504f2d96afea02718862f3/iniconfig-2.1.0.tar.gz", hash = "sha256:3abbd2e30b36733fee78f9c7f7308f2d0050e88f0087fd25c2645f63c773e1c7", size = 4793 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2c/e1/e6716421ea10d38022b952c159d5161ca1193197fb744506875fbb87ea7b/iniconfig-2.1.0-py3-none-any.whl", hash = "sha256:9deba5723312380e77435581c6bf4935c94cbfab9b1ed33ef8d238ea168eb760", size = 6050 },
]

[[package]]
name = "numpy"
version = "2.0.2"
source = { registry = "https://pypi.org/simple" }
resolution-markers = [
    "python_full_version < '3.10'",
]
sdist = { url = "https://files.pythonhosted.org/packages/a9/75/10dd1f8116a8b796cb2c737b674e02d02e80454bda953fa7e65d8c12b016/numpy-2.0.2.tar.gz", hash = "sha256:883c987dee1880e2a864ab0dc9892292582510604156762362d9326444636e78", size = 18902015 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/21/91/3495b3237510f79f5d81f2508f9f13fea78ebfdf07538fc7444badda173d/numpy-2.0.2-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:51129a29dbe56f9ca83438b706e2e69a39892b5eda6cedcb6b0c9fdc9b0d3ece", size = 21165245 },
    { url = "https://files.pythonhosted.org/packages/05/33/26178c7d437a87082d11019292dce6d3fe6f0e9026b7b2309cbf3e489b1d/numpy-2.0.2-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:f15975dfec0cf2239224d80e32c3170b1d168335eaedee69da84fbe9f1f9cd04", size = 13738540 },
    { url = "https://files.pythonhosted.org/packages/ec/31/cc46e13bf07644efc7a4bf68df2df5fb2a1a88d0cd0da9ddc84dc0033e51/numpy-2.0.2-cp310-cp310-macosx_14_0_arm64.whl", hash = "sha256:8c5713284ce4e282544c68d1c3b2c7161d38c256d2eefc93c1d683cf47683e66", size = 5300623 },
    { url = "https://files.pythonhosted.org/packages/6e/16/7bfcebf27bb4f9d7ec67332ffebee4d1bf085c84246552d52dbb548600e7/numpy-2.0.2-cp310-cp310-macosx_14_0_x86_64.whl", hash = "sha256:becfae3ddd30736fe1889a37f1f580e245ba79a5855bff5f2a29cb3ccc22dd7b", size = 6901774 },
    { url = "https://files.pythonhosted.org/packages/f9/a3/561c531c0e8bf082c5bef509d00d56f82e0ea7e1e3e3a7fc8fa78742a6e5/numpy-2.0.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:2da5960c3cf0df7eafefd806d4e612c5e19358de82cb3c343631188991566ccd", size = 13907081 },
    { url = "https://files.pythonhosted.org/packages/fa/66/f7177ab331876200ac7563a580140643d1179c8b4b6a6b0fc9838de2a9b8/numpy-2.0.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:496f71341824ed9f3d2fd36cf3ac57ae2e0165c143b55c3a035ee219413f3318", size = 19523451 },
    { url = "https://files.pythonhosted.org/packages/25/7f/0b209498009ad6453e4efc2c65bcdf0ae08a182b2b7877d7ab38a92dc542/numpy-2.0.2-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:a61ec659f68ae254e4d237816e33171497e978140353c0c2038d46e63282d0c8", size = 19927572 },
    { url = "https://files.pythonhosted.org/packages/3e/df/2619393b1e1b565cd2d4c4403bdd979621e2c4dea1f8532754b2598ed63b/numpy-2.0.2-cp310-cp310-musllinux_1_2_aarch64.whl", hash = "sha256:d731a1c6116ba289c1e9ee714b08a8ff882944d4ad631fd411106a30f083c326", size = 14400722 },
    { url = "https://files.pythonhosted.org/packages/22/ad/77e921b9f256d5da36424ffb711ae79ca3f451ff8489eeca544d0701d74a/numpy-2.0.2-cp310-cp310-win32.whl", hash = "sha256:984d96121c9f9616cd33fbd0618b7f08e0cfc9600a7ee1d6fd9b239186d19d97", size = 6472170 },
    { url = "https://files.pythonhosted.org/packages/10/05/3442317535028bc29cf0c0dd4c191a4481e8376e9f0db6bcf29703cadae6/numpy-2.0.2-cp310-cp310-win_amd64.whl", hash = "sha256:c7b0be4ef08607dd04da4092faee0b86607f111d5ae68036f16cc787e250a131", size = 15905558 },
    { url = "https://files.pythonhosted.org/packages/8b/cf/034500fb83041aa0286e0fb16e7c76e5c8b67c0711bb6e9e9737a717d5fe/numpy-2.0.2-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:49ca4decb342d66018b01932139c0961a8f9ddc7589611158cb3c27cbcf76448", size = 21169137 },
    { url = "https://files.pythonhosted.org/packages/4a/d9/32de45561811a4b87fbdee23b5797394e3d1504b4a7cf40c10199848893e/numpy-2.0.2-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:11a76c372d1d37437857280aa142086476136a8c0f373b2e648ab2c8f18fb195", size = 13703552 },
    { url = "https://files.pythonhosted.org/packages/c1/ca/2f384720020c7b244d22508cb7ab23d95f179fcfff33c31a6eeba8d6c512/numpy-2.0.2-cp311-cp311-macosx_14_0_arm64.whl", hash = "sha256:807ec44583fd708a21d4a11d94aedf2f4f3c3719035c76a2bbe1fe8e217bdc57", size = 5298957 },
    { url = "https://files.pythonhosted.org/packages/0e/78/a3e4f9fb6aa4e6fdca0c5428e8ba039408514388cf62d89651aade838269/numpy-2.0.2-cp311-cp311-macosx_14_0_x86_64.whl", hash = "sha256:8cafab480740e22f8d833acefed5cc87ce276f4ece12fdaa2e8903db2f82897a", size = 6905573 },
    { url = "https://files.pythonhosted.org/packages/a0/72/cfc3a1beb2caf4efc9d0b38a15fe34025230da27e1c08cc2eb9bfb1c7231/numpy-2.0.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a15f476a45e6e5a3a79d8a14e62161d27ad897381fecfa4a09ed5322f2085669", size = 13914330 },
    { url = "https://files.pythonhosted.org/packages/ba/a8/c17acf65a931ce551fee11b72e8de63bf7e8a6f0e21add4c937c83563538/numpy-2.0.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:13e689d772146140a252c3a28501da66dfecd77490b498b168b501835041f951", size = 19534895 },
    { url = "https://files.pythonhosted.org/packages/ba/86/8767f3d54f6ae0165749f84648da9dcc8cd78ab65d415494962c86fac80f/numpy-2.0.2-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:9ea91dfb7c3d1c56a0e55657c0afb38cf1eeae4544c208dc465c3c9f3a7c09f9", size = 19937253 },
    { url = "https://files.pythonhosted.org/packages/df/87/f76450e6e1c14e5bb1eae6836478b1028e096fd02e85c1c37674606ab752/numpy-2.0.2-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:c1c9307701fec8f3f7a1e6711f9089c06e6284b3afbbcd259f7791282d660a15", size = 14414074 },
    { url = "https://files.pythonhosted.org/packages/5c/ca/0f0f328e1e59f73754f06e1adfb909de43726d4f24c6a3f8805f34f2b0fa/numpy-2.0.2-cp311-cp311-win32.whl", hash = "sha256:a392a68bd329eafac5817e5aefeb39038c48b671afd242710b451e76090e81f4", size = 6470640 },
    { url = "https://files.pythonhosted.org/packages/eb/57/3a3f14d3a759dcf9bf6e9eda905794726b758819df4663f217d658a58695/numpy-2.0.2-cp311-cp311-win_amd64.whl", hash = "sha256:286cd40ce2b7d652a6f22efdfc6d1edf879440e53e76a75955bc0c826c7e64dc", size = 15910230 },
    { url = "https://files.pythonhosted.org/packages/45/40/2e117be60ec50d98fa08c2f8c48e09b3edea93cfcabd5a9ff6925d54b1c2/numpy-2.0.2-cp312-cp312-macosx_10_9_x86_64.whl", hash = "sha256:df55d490dea7934f330006d0f81e8551ba6010a5bf035a249ef61a94f21c500b", size = 20895803 },
    { url = "https://files.pythonhosted.org/packages/46/92/1b8b8dee833f53cef3e0a3f69b2374467789e0bb7399689582314df02651/numpy-2.0.2-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:8df823f570d9adf0978347d1f926b2a867d5608f434a7cff7f7908c6570dcf5e", size = 13471835 },
    { url = "https://files.pythonhosted.org/packages/7f/19/e2793bde475f1edaea6945be141aef6c8b4c669b90c90a300a8954d08f0a/numpy-2.0.2-cp312-cp312-macosx_14_0_arm64.whl", hash = "sha256:9a92ae5c14811e390f3767053ff54eaee3bf84576d99a2456391401323f4ec2c", size = 5038499 },
    { url = "https://files.pythonhosted.org/packages/e3/ff/ddf6dac2ff0dd50a7327bcdba45cb0264d0e96bb44d33324853f781a8f3c/numpy-2.0.2-cp312-cp312-macosx_14_0_x86_64.whl", hash = "sha256:a842d573724391493a97a62ebbb8e731f8a5dcc5d285dfc99141ca15a3302d0c", size = 6633497 },
    { url = "https://files.pythonhosted.org/packages/72/21/67f36eac8e2d2cd652a2e69595a54128297cdcb1ff3931cfc87838874bd4/numpy-2.0.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:c05e238064fc0610c840d1cf6a13bf63d7e391717d247f1bf0318172e759e692", size = 13621158 },
    { url = "https://files.pythonhosted.org/packages/39/68/e9f1126d757653496dbc096cb429014347a36b228f5a991dae2c6b6cfd40/numpy-2.0.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:0123ffdaa88fa4ab64835dcbde75dcdf89c453c922f18dced6e27c90d1d0ec5a", size = 19236173 },
    { url = "https://files.pythonhosted.org/packages/d1/e9/1f5333281e4ebf483ba1c888b1d61ba7e78d7e910fdd8e6499667041cc35/numpy-2.0.2-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:96a55f64139912d61de9137f11bf39a55ec8faec288c75a54f93dfd39f7eb40c", size = 19634174 },
    { url = "https://files.pythonhosted.org/packages/71/af/a469674070c8d8408384e3012e064299f7a2de540738a8e414dcfd639996/numpy-2.0.2-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:ec9852fb39354b5a45a80bdab5ac02dd02b15f44b3804e9f00c556bf24b4bded", size = 14099701 },
    { url = "https://files.pythonhosted.org/packages/d0/3d/08ea9f239d0e0e939b6ca52ad403c84a2bce1bde301a8eb4888c1c1543f1/numpy-2.0.2-cp312-cp312-win32.whl", hash = "sha256:671bec6496f83202ed2d3c8fdc486a8fc86942f2e69ff0e986140339a63bcbe5", size = 6174313 },
    { url = "https://files.pythonhosted.org/packages/b2/b5/4ac39baebf1fdb2e72585c8352c56d063b6126be9fc95bd2bb5ef5770c20/numpy-2.0.2-cp312-cp312-win_amd64.whl", hash = "sha256:cfd41e13fdc257aa5778496b8caa5e856dc4896d4ccf01841daee1d96465467a", size = 15606179 },
    { url = "https://files.pythonhosted.org/packages/43/c1/41c8f6df3162b0c6ffd4437d729115704bd43363de0090c7f913cfbc2d89/numpy-2.0.2-cp39-cp39-macosx_10_9_x86_64.whl", hash = "sha256:9059e10581ce4093f735ed23f3b9d283b9d517ff46009ddd485f1747eb22653c", size = 21169942 },
    { url = "https://files.pythonhosted.org/packages/39/bc/fd298f308dcd232b56a4031fd6ddf11c43f9917fbc937e53762f7b5a3bb1/numpy-2.0.2-cp39-cp39-macosx_11_0_arm64.whl", hash = "sha256:423e89b23490805d2a5a96fe40ec507407b8ee786d66f7328be214f9679df6dd", size = 13711512 },
    { url = "https://files.pythonhosted.org/packages/96/ff/06d1aa3eeb1c614eda245c1ba4fb88c483bee6520d361641331872ac4b82/numpy-2.0.2-cp39-cp39-macosx_14_0_arm64.whl", hash = "sha256:2b2955fa6f11907cf7a70dab0d0755159bca87755e831e47932367fc8f2f2d0b", size = 5306976 },
    { url = "https://files.pythonhosted.org/packages/2d/98/121996dcfb10a6087a05e54453e28e58694a7db62c5a5a29cee14c6e047b/numpy-2.0.2-cp39-cp39-macosx_14_0_x86_64.whl", hash = "sha256:97032a27bd9d8988b9a97a8c4d2c9f2c15a81f61e2f21404d7e8ef00cb5be729", size = 6906494 },
    { url = "https://files.pythonhosted.org/packages/15/31/9dffc70da6b9bbf7968f6551967fc21156207366272c2a40b4ed6008dc9b/numpy-2.0.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:1e795a8be3ddbac43274f18588329c72939870a16cae810c2b73461c40718ab1", size = 13912596 },
    { url = "https://files.pythonhosted.org/packages/b9/14/78635daab4b07c0930c919d451b8bf8c164774e6a3413aed04a6d95758ce/numpy-2.0.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:f26b258c385842546006213344c50655ff1555a9338e2e5e02a0756dc3e803dd", size = 19526099 },
    { url = "https://files.pythonhosted.org/packages/26/4c/0eeca4614003077f68bfe7aac8b7496f04221865b3a5e7cb230c9d055afd/numpy-2.0.2-cp39-cp39-musllinux_1_1_x86_64.whl", hash = "sha256:5fec9451a7789926bcf7c2b8d187292c9f93ea30284802a0ab3f5be8ab36865d", size = 19932823 },
    { url = "https://files.pythonhosted.org/packages/f1/46/ea25b98b13dccaebddf1a803f8c748680d972e00507cd9bc6dcdb5aa2ac1/numpy-2.0.2-cp39-cp39-musllinux_1_2_aarch64.whl", hash = "sha256:9189427407d88ff25ecf8f12469d4d39d35bee1db5d39fc5c168c6f088a6956d", size = 14404424 },
    { url = "https://files.pythonhosted.org/packages/c8/a6/177dd88d95ecf07e722d21008b1b40e681a929eb9e329684d449c36586b2/numpy-2.0.2-cp39-cp39-win32.whl", hash = "sha256:905d16e0c60200656500c95b6b8dca5d109e23cb24abc701d41c02d74c6b3afa", size = 6476809 },
    { url = "https://files.pythonhosted.org/packages/ea/2b/7fc9f4e7ae5b507c1a3a21f0f15ed03e794c1242ea8a242ac158beb56034/numpy-2.0.2-cp39-cp39-win_amd64.whl", hash = "sha256:a3f4ab0caa7f053f6797fcd4e1e25caee367db3112ef2b6ef82d749530768c73", size = 15911314 },
    { url = "https://files.pythonhosted.org/packages/8f/3b/df5a870ac6a3be3a86856ce195ef42eec7ae50d2a202be1f5a4b3b340e14/numpy-2.0.2-pp39-pypy39_pp73-macosx_10_9_x86_64.whl", hash = "sha256:7f0a0c6f12e07fa94133c8a67404322845220c06a9e80e85999afe727f7438b8", size = 21025288 },
    { url = "https://files.pythonhosted.org/packages/2c/97/51af92f18d6f6f2d9ad8b482a99fb74e142d71372da5d834b3a2747a446e/numpy-2.0.2-pp39-pypy39_pp73-macosx_14_0_x86_64.whl", hash = "sha256:312950fdd060354350ed123c0e25a71327d3711584beaef30cdaa93320c392d4", size = 6762793 },
    { url = "https://files.pythonhosted.org/packages/12/46/de1fbd0c1b5ccaa7f9a005b66761533e2f6a3e560096682683a223631fe9/numpy-2.0.2-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:26df23238872200f63518dd2aa984cfca675d82469535dc7162dc2ee52d9dd5c", size = 19334885 },
    { url = "https://files.pythonhosted.org/packages/cc/dc/d330a6faefd92b446ec0f0dfea4c3207bb1fef3c4771d19cf4543efd2c78/numpy-2.0.2-pp39-pypy39_pp73-win_amd64.whl", hash = "sha256:a46288ec55ebbd58947d31d72be2c63cbf839f0a63b49cb755022310792a3385", size = 15828784 },
]

[[package]]
name = "numpy"
version = "2.2.6"
source = { registry = "https://pypi.org/simple" }
resolution-markers = [
    "python_full_version == '3.10.*'",
]
sdist = { url = "https://files.pythonhosted.org/packages/76/21/7d2a95e4bba9dc13d043ee156a356c0a8f0c6309dff6b21b4d71a073b8a8/numpy-2.2.6.tar.gz", hash = "sha256:e29554e2bef54a90aa5cc07da6ce955accb83f21ab5de01a62c8478897b264fd", size = 20276440 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/9a/3e/ed6db5be21ce87955c0cbd3009f2803f59fa08df21b5df06862e2d8e2bdd/numpy-2.2.6-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:b412caa66f72040e6d268491a59f2c43bf03eb6c96dd8f0307829feb7fa2b6fb", size = 21165245 },
    { url = "https://files.pythonhosted.org/packages/22/c2/4b9221495b2a132cc9d2eb862e21d42a009f5a60e45fc44b00118c174bff/numpy-2.2.6-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:8e41fd67c52b86603a91c1a505ebaef50b3314de0213461c7a6e99c9a3beff90", size = 14360048 },
    { url = "https://files.pythonhosted.org/packages/fd/77/dc2fcfc66943c6410e2bf598062f5959372735ffda175b39906d54f02349/numpy-2.2.6-cp310-cp310-macosx_14_0_arm64.whl", hash = "sha256:37e990a01ae6ec7fe7fa1c26c55ecb672dd98b19c3d0e1d1f326fa13cb38d163", size = 5340542 },
    { url = "https://files.pythonhosted.org/packages/7a/4f/1cb5fdc353a5f5cc7feb692db9b8ec2c3d6405453f982435efc52561df58/numpy-2.2.6-cp310-cp310-macosx_14_0_x86_64.whl", hash = "sha256:5a6429d4be8ca66d889b7cf70f536a397dc45ba6faeb5f8c5427935d9592e9cf", size = 6878301 },
    { url = "https://files.pythonhosted.org/packages/eb/17/96a3acd228cec142fcb8723bd3cc39c2a474f7dcf0a5d16731980bcafa95/numpy-2.2.6-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:efd28d4e9cd7d7a8d39074a4d44c63eda73401580c5c76acda2ce969e0a38e83", size = 14297320 },
    { url = "https://files.pythonhosted.org/packages/b4/63/3de6a34ad7ad6646ac7d2f55ebc6ad439dbbf9c4370017c50cf403fb19b5/numpy-2.2.6-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:fc7b73d02efb0e18c000e9ad8b83480dfcd5dfd11065997ed4c6747470ae8915", size = 16801050 },
    { url = "https://files.pythonhosted.org/packages/07/b6/89d837eddef52b3d0cec5c6ba0456c1bf1b9ef6a6672fc2b7873c3ec4e2e/numpy-2.2.6-cp310-cp310-musllinux_1_2_aarch64.whl", hash = "sha256:74d4531beb257d2c3f4b261bfb0fc09e0f9ebb8842d82a7b4209415896adc680", size = 15807034 },
    { url = "https://files.pythonhosted.org/packages/01/c8/dc6ae86e3c61cfec1f178e5c9f7858584049b6093f843bca541f94120920/numpy-2.2.6-cp310-cp310-musllinux_1_2_x86_64.whl", hash = "sha256:8fc377d995680230e83241d8a96def29f204b5782f371c532579b4f20607a289", size = 18614185 },
    { url = "https://files.pythonhosted.org/packages/5b/c5/0064b1b7e7c89137b471ccec1fd2282fceaae0ab3a9550f2568782d80357/numpy-2.2.6-cp310-cp310-win32.whl", hash = "sha256:b093dd74e50a8cba3e873868d9e93a85b78e0daf2e98c6797566ad8044e8363d", size = 6527149 },
    { url = "https://files.pythonhosted.org/packages/a3/dd/4b822569d6b96c39d1215dbae0582fd99954dcbcf0c1a13c61783feaca3f/numpy-2.2.6-cp310-cp310-win_amd64.whl", hash = "sha256:f0fd6321b839904e15c46e0d257fdd101dd7f530fe03fd6359c1ea63738703f3", size = 12904620 },
    { url = "https://files.pythonhosted.org/packages/da/a8/4f83e2aa666a9fbf56d6118faaaf5f1974d456b1823fda0a176eff722839/numpy-2.2.6-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:f9f1adb22318e121c5c69a09142811a201ef17ab257a1e66ca3025065b7f53ae", size = 21176963 },
    { url = "https://files.pythonhosted.org/packages/b3/2b/64e1affc7972decb74c9e29e5649fac940514910960ba25cd9af4488b66c/numpy-2.2.6-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:c820a93b0255bc360f53eca31a0e676fd1101f673dda8da93454a12e23fc5f7a", size = 14406743 },
    { url = "https://files.pythonhosted.org/packages/4a/9f/0121e375000b5e50ffdd8b25bf78d8e1a5aa4cca3f185d41265198c7b834/numpy-2.2.6-cp311-cp311-macosx_14_0_arm64.whl", hash = "sha256:3d70692235e759f260c3d837193090014aebdf026dfd167834bcba43e30c2a42", size = 5352616 },
    { url = "https://files.pythonhosted.org/packages/31/0d/b48c405c91693635fbe2dcd7bc84a33a602add5f63286e024d3b6741411c/numpy-2.2.6-cp311-cp311-macosx_14_0_x86_64.whl", hash = "sha256:481b49095335f8eed42e39e8041327c05b0f6f4780488f61286ed3c01368d491", size = 6889579 },
    { url = "https://files.pythonhosted.org/packages/52/b8/7f0554d49b565d0171eab6e99001846882000883998e7b7d9f0d98b1f934/numpy-2.2.6-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:b64d8d4d17135e00c8e346e0a738deb17e754230d7e0810ac5012750bbd85a5a", size = 14312005 },
    { url = "https://files.pythonhosted.org/packages/b3/dd/2238b898e51bd6d389b7389ffb20d7f4c10066d80351187ec8e303a5a475/numpy-2.2.6-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:ba10f8411898fc418a521833e014a77d3ca01c15b0c6cdcce6a0d2897e6dbbdf", size = 16821570 },
    { url = "https://files.pythonhosted.org/packages/83/6c/44d0325722cf644f191042bf47eedad61c1e6df2432ed65cbe28509d404e/numpy-2.2.6-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:bd48227a919f1bafbdda0583705e547892342c26fb127219d60a5c36882609d1", size = 15818548 },
    { url = "https://files.pythonhosted.org/packages/ae/9d/81e8216030ce66be25279098789b665d49ff19eef08bfa8cb96d4957f422/numpy-2.2.6-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:9551a499bf125c1d4f9e250377c1ee2eddd02e01eac6644c080162c0c51778ab", size = 18620521 },
    { url = "https://files.pythonhosted.org/packages/6a/fd/e19617b9530b031db51b0926eed5345ce8ddc669bb3bc0044b23e275ebe8/numpy-2.2.6-cp311-cp311-win32.whl", hash = "sha256:0678000bb9ac1475cd454c6b8c799206af8107e310843532b04d49649c717a47", size = 6525866 },
    { url = "https://files.pythonhosted.org/packages/31/0a/f354fb7176b81747d870f7991dc763e157a934c717b67b58456bc63da3df/numpy-2.2.6-cp311-cp311-win_amd64.whl", hash = "sha256:e8213002e427c69c45a52bbd94163084025f533a55a59d6f9c5b820774ef3303", size = 12907455 },
    { url = "https://files.pythonhosted.org/packages/82/5d/c00588b6cf18e1da539b45d3598d3557084990dcc4331960c15ee776ee41/numpy-2.2.6-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:41c5a21f4a04fa86436124d388f6ed60a9343a6f767fced1a8a71c3fbca038ff", size = 20875348 },
    { url = "https://files.pythonhosted.org/packages/66/ee/560deadcdde6c2f90200450d5938f63a34b37e27ebff162810f716f6a230/numpy-2.2.6-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:de749064336d37e340f640b05f24e9e3dd678c57318c7289d222a8a2f543e90c", size = 14119362 },
    { url = "https://files.pythonhosted.org/packages/3c/65/4baa99f1c53b30adf0acd9a5519078871ddde8d2339dc5a7fde80d9d87da/numpy-2.2.6-cp312-cp312-macosx_14_0_arm64.whl", hash = "sha256:894b3a42502226a1cac872f840030665f33326fc3dac8e57c607905773cdcde3", size = 5084103 },
    { url = "https://files.pythonhosted.org/packages/cc/89/e5a34c071a0570cc40c9a54eb472d113eea6d002e9ae12bb3a8407fb912e/numpy-2.2.6-cp312-cp312-macosx_14_0_x86_64.whl", hash = "sha256:71594f7c51a18e728451bb50cc60a3ce4e6538822731b2933209a1f3614e9282", size = 6625382 },
    { url = "https://files.pythonhosted.org/packages/f8/35/8c80729f1ff76b3921d5c9487c7ac3de9b2a103b1cd05e905b3090513510/numpy-2.2.6-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:f2618db89be1b4e05f7a1a847a9c1c0abd63e63a1607d892dd54668dd92faf87", size = 14018462 },
    { url = "https://files.pythonhosted.org/packages/8c/3d/1e1db36cfd41f895d266b103df00ca5b3cbe965184df824dec5c08c6b803/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:fd83c01228a688733f1ded5201c678f0c53ecc1006ffbc404db9f7a899ac6249", size = 16527618 },
    { url = "https://files.pythonhosted.org/packages/61/c6/03ed30992602c85aa3cd95b9070a514f8b3c33e31124694438d88809ae36/numpy-2.2.6-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:37c0ca431f82cd5fa716eca9506aefcabc247fb27ba69c5062a6d3ade8cf8f49", size = 15505511 },
    { url = "https://files.pythonhosted.org/packages/b7/25/5761d832a81df431e260719ec45de696414266613c9ee268394dd5ad8236/numpy-2.2.6-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:fe27749d33bb772c80dcd84ae7e8df2adc920ae8297400dabec45f0dedb3f6de", size = 18313783 },
    { url = "https://files.pythonhosted.org/packages/57/0a/72d5a3527c5ebffcd47bde9162c39fae1f90138c961e5296491ce778e682/numpy-2.2.6-cp312-cp312-win32.whl", hash = "sha256:4eeaae00d789f66c7a25ac5f34b71a7035bb474e679f410e5e1a94deb24cf2d4", size = 6246506 },
    { url = "https://files.pythonhosted.org/packages/36/fa/8c9210162ca1b88529ab76b41ba02d433fd54fecaf6feb70ef9f124683f1/numpy-2.2.6-cp312-cp312-win_amd64.whl", hash = "sha256:c1f9540be57940698ed329904db803cf7a402f3fc200bfe599334c9bd84a40b2", size = 12614190 },
    { url = "https://files.pythonhosted.org/packages/f9/5c/6657823f4f594f72b5471f1db1ab12e26e890bb2e41897522d134d2a3e81/numpy-2.2.6-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:0811bb762109d9708cca4d0b13c4f67146e3c3b7cf8d34018c722adb2d957c84", size = 20867828 },
    { url = "https://files.pythonhosted.org/packages/dc/9e/14520dc3dadf3c803473bd07e9b2bd1b69bc583cb2497b47000fed2fa92f/numpy-2.2.6-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:287cc3162b6f01463ccd86be154f284d0893d2b3ed7292439ea97eafa8170e0b", size = 14143006 },
    { url = "https://files.pythonhosted.org/packages/4f/06/7e96c57d90bebdce9918412087fc22ca9851cceaf5567a45c1f404480e9e/numpy-2.2.6-cp313-cp313-macosx_14_0_arm64.whl", hash = "sha256:f1372f041402e37e5e633e586f62aa53de2eac8d98cbfb822806ce4bbefcb74d", size = 5076765 },
    { url = "https://files.pythonhosted.org/packages/73/ed/63d920c23b4289fdac96ddbdd6132e9427790977d5457cd132f18e76eae0/numpy-2.2.6-cp313-cp313-macosx_14_0_x86_64.whl", hash = "sha256:55a4d33fa519660d69614a9fad433be87e5252f4b03850642f88993f7b2ca566", size = 6617736 },
    { url = "https://files.pythonhosted.org/packages/85/c5/e19c8f99d83fd377ec8c7e0cf627a8049746da54afc24ef0a0cb73d5dfb5/numpy-2.2.6-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:f92729c95468a2f4f15e9bb94c432a9229d0d50de67304399627a943201baa2f", size = 14010719 },
    { url = "https://files.pythonhosted.org/packages/19/49/4df9123aafa7b539317bf6d342cb6d227e49f7a35b99c287a6109b13dd93/numpy-2.2.6-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:1bc23a79bfabc5d056d106f9befb8d50c31ced2fbc70eedb8155aec74a45798f", size = 16526072 },
    { url = "https://files.pythonhosted.org/packages/b2/6c/04b5f47f4f32f7c2b0e7260442a8cbcf8168b0e1a41ff1495da42f42a14f/numpy-2.2.6-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:e3143e4451880bed956e706a3220b4e5cf6172ef05fcc397f6f36a550b1dd868", size = 15503213 },
    { url = "https://files.pythonhosted.org/packages/17/0a/5cd92e352c1307640d5b6fec1b2ffb06cd0dabe7d7b8227f97933d378422/numpy-2.2.6-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:b4f13750ce79751586ae2eb824ba7e1e8dba64784086c98cdbbcc6a42112ce0d", size = 18316632 },
    { url = "https://files.pythonhosted.org/packages/f0/3b/5cba2b1d88760ef86596ad0f3d484b1cbff7c115ae2429678465057c5155/numpy-2.2.6-cp313-cp313-win32.whl", hash = "sha256:5beb72339d9d4fa36522fc63802f469b13cdbe4fdab4a288f0c441b74272ebfd", size = 6244532 },
    { url = "https://files.pythonhosted.org/packages/cb/3b/d58c12eafcb298d4e6d0d40216866ab15f59e55d148a5658bb3132311fcf/numpy-2.2.6-cp313-cp313-win_amd64.whl", hash = "sha256:b0544343a702fa80c95ad5d3d608ea3599dd54d4632df855e4c8d24eb6ecfa1c", size = 12610885 },
    { url = "https://files.pythonhosted.org/packages/6b/9e/4bf918b818e516322db999ac25d00c75788ddfd2d2ade4fa66f1f38097e1/numpy-2.2.6-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:0bca768cd85ae743b2affdc762d617eddf3bcf8724435498a1e80132d04879e6", size = 20963467 },
    { url = "https://files.pythonhosted.org/packages/61/66/d2de6b291507517ff2e438e13ff7b1e2cdbdb7cb40b3ed475377aece69f9/numpy-2.2.6-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:fc0c5673685c508a142ca65209b4e79ed6740a4ed6b2267dbba90f34b0b3cfda", size = 14225144 },
    { url = "https://files.pythonhosted.org/packages/e4/25/480387655407ead912e28ba3a820bc69af9adf13bcbe40b299d454ec011f/numpy-2.2.6-cp313-cp313t-macosx_14_0_arm64.whl", hash = "sha256:5bd4fc3ac8926b3819797a7c0e2631eb889b4118a9898c84f585a54d475b7e40", size = 5200217 },
    { url = "https://files.pythonhosted.org/packages/aa/4a/6e313b5108f53dcbf3aca0c0f3e9c92f4c10ce57a0a721851f9785872895/numpy-2.2.6-cp313-cp313t-macosx_14_0_x86_64.whl", hash = "sha256:fee4236c876c4e8369388054d02d0e9bb84821feb1a64dd59e137e6511a551f8", size = 6712014 },
    { url = "https://files.pythonhosted.org/packages/b7/30/172c2d5c4be71fdf476e9de553443cf8e25feddbe185e0bd88b096915bcc/numpy-2.2.6-cp313-cp313t-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:e1dda9c7e08dc141e0247a5b8f49cf05984955246a327d4c48bda16821947b2f", size = 14077935 },
    { url = "https://files.pythonhosted.org/packages/12/fb/9e743f8d4e4d3c710902cf87af3512082ae3d43b945d5d16563f26ec251d/numpy-2.2.6-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:f447e6acb680fd307f40d3da4852208af94afdfab89cf850986c3ca00562f4fa", size = 16600122 },
    { url = "https://files.pythonhosted.org/packages/12/75/ee20da0e58d3a66f204f38916757e01e33a9737d0b22373b3eb5a27358f9/numpy-2.2.6-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:389d771b1623ec92636b0786bc4ae56abafad4a4c513d36a55dce14bd9ce8571", size = 15586143 },
    { url = "https://files.pythonhosted.org/packages/76/95/bef5b37f29fc5e739947e9ce5179ad402875633308504a52d188302319c8/numpy-2.2.6-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:8e9ace4a37db23421249ed236fdcdd457d671e25146786dfc96835cd951aa7c1", size = 18385260 },
    { url = "https://files.pythonhosted.org/packages/09/04/f2f83279d287407cf36a7a8053a5abe7be3622a4363337338f2585e4afda/numpy-2.2.6-cp313-cp313t-win32.whl", hash = "sha256:038613e9fb8c72b0a41f025a7e4c3f0b7a1b5d768ece4796b674c8f3fe13efff", size = 6377225 },
    { url = "https://files.pythonhosted.org/packages/67/0e/35082d13c09c02c011cf21570543d202ad929d961c02a147493cb0c2bdf5/numpy-2.2.6-cp313-cp313t-win_amd64.whl", hash = "sha256:6031dd6dfecc0cf9f668681a37648373bddd6421fff6c66ec1624eed0180ee06", size = 12771374 },
    { url = "https://files.pythonhosted.org/packages/9e/3b/d94a75f4dbf1ef5d321523ecac21ef23a3cd2ac8b78ae2aac40873590229/numpy-2.2.6-pp310-pypy310_pp73-macosx_10_15_x86_64.whl", hash = "sha256:0b605b275d7bd0c640cad4e5d30fa701a8d59302e127e5f79138ad62762c3e3d", size = 21040391 },
    { url = "https://files.pythonhosted.org/packages/17/f4/09b2fa1b58f0fb4f7c7963a1649c64c4d315752240377ed74d9cd878f7b5/numpy-2.2.6-pp310-pypy310_pp73-macosx_14_0_x86_64.whl", hash = "sha256:7befc596a7dc9da8a337f79802ee8adb30a552a94f792b9c9d18c840055907db", size = 6786754 },
    { url = "https://files.pythonhosted.org/packages/af/30/feba75f143bdc868a1cc3f44ccfa6c4b9ec522b36458e738cd00f67b573f/numpy-2.2.6-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:ce47521a4754c8f4593837384bd3424880629f718d87c5d44f8ed763edd63543", size = 16643476 },
    { url = "https://files.pythonhosted.org/packages/37/48/ac2a9584402fb6c0cd5b5d1a91dcf176b15760130dd386bbafdbfe3640bf/numpy-2.2.6-pp310-pypy310_pp73-win_amd64.whl", hash = "sha256:d042d24c90c41b54fd506da306759e06e568864df8ec17ccc17e9e884634fd00", size = 12812666 },
]

[[package]]
name = "numpy"
version = "2.3.1"
source = { registry = "https://pypi.org/simple" }
resolution-markers = [
    "python_full_version >= '3.11'",
]
sdist = { url = "https://files.pythonhosted.org/packages/2e/19/d7c972dfe90a353dbd3efbbe1d14a5951de80c99c9dc1b93cd998d51dc0f/numpy-2.3.1.tar.gz", hash = "sha256:1ec9ae20a4226da374362cca3c62cd753faf2f951440b0e3b98e93c235441d2b", size = 20390372 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b0/c7/87c64d7ab426156530676000c94784ef55676df2f13b2796f97722464124/numpy-2.3.1-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:6ea9e48336a402551f52cd8f593343699003d2353daa4b72ce8d34f66b722070", size = 21199346 },
    { url = "https://files.pythonhosted.org/packages/58/0e/0966c2f44beeac12af8d836e5b5f826a407cf34c45cb73ddcdfce9f5960b/numpy-2.3.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:5ccb7336eaf0e77c1635b232c141846493a588ec9ea777a7c24d7166bb8533ae", size = 14361143 },
    { url = "https://files.pythonhosted.org/packages/7d/31/6e35a247acb1bfc19226791dfc7d4c30002cd4e620e11e58b0ddf836fe52/numpy-2.3.1-cp311-cp311-macosx_14_0_arm64.whl", hash = "sha256:0bb3a4a61e1d327e035275d2a993c96fa786e4913aa089843e6a2d9dd205c66a", size = 5378989 },
    { url = "https://files.pythonhosted.org/packages/b0/25/93b621219bb6f5a2d4e713a824522c69ab1f06a57cd571cda70e2e31af44/numpy-2.3.1-cp311-cp311-macosx_14_0_x86_64.whl", hash = "sha256:e344eb79dab01f1e838ebb67aab09965fb271d6da6b00adda26328ac27d4a66e", size = 6912890 },
    { url = "https://files.pythonhosted.org/packages/ef/60/6b06ed98d11fb32e27fb59468b42383f3877146d3ee639f733776b6ac596/numpy-2.3.1-cp311-cp311-manylinux_2_28_aarch64.whl", hash = "sha256:467db865b392168ceb1ef1ffa6f5a86e62468c43e0cfb4ab6da667ede10e58db", size = 14569032 },
    { url = "https://files.pythonhosted.org/packages/75/c9/9bec03675192077467a9c7c2bdd1f2e922bd01d3a69b15c3a0fdcd8548f6/numpy-2.3.1-cp311-cp311-manylinux_2_28_x86_64.whl", hash = "sha256:afed2ce4a84f6b0fc6c1ce734ff368cbf5a5e24e8954a338f3bdffa0718adffb", size = 16930354 },
    { url = "https://files.pythonhosted.org/packages/6a/e2/5756a00cabcf50a3f527a0c968b2b4881c62b1379223931853114fa04cda/numpy-2.3.1-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:0025048b3c1557a20bc80d06fdeb8cc7fc193721484cca82b2cfa072fec71a93", size = 15879605 },
    { url = "https://files.pythonhosted.org/packages/ff/86/a471f65f0a86f1ca62dcc90b9fa46174dd48f50214e5446bc16a775646c5/numpy-2.3.1-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:a5ee121b60aa509679b682819c602579e1df14a5b07fe95671c8849aad8f2115", size = 18666994 },
    { url = "https://files.pythonhosted.org/packages/43/a6/482a53e469b32be6500aaf61cfafd1de7a0b0d484babf679209c3298852e/numpy-2.3.1-cp311-cp311-win32.whl", hash = "sha256:a8b740f5579ae4585831b3cf0e3b0425c667274f82a484866d2adf9570539369", size = 6603672 },
    { url = "https://files.pythonhosted.org/packages/6b/fb/bb613f4122c310a13ec67585c70e14b03bfc7ebabd24f4d5138b97371d7c/numpy-2.3.1-cp311-cp311-win_amd64.whl", hash = "sha256:d4580adadc53311b163444f877e0789f1c8861e2698f6b2a4ca852fda154f3ff", size = 13024015 },
    { url = "https://files.pythonhosted.org/packages/51/58/2d842825af9a0c041aca246dc92eb725e1bc5e1c9ac89712625db0c4e11c/numpy-2.3.1-cp311-cp311-win_arm64.whl", hash = "sha256:ec0bdafa906f95adc9a0c6f26a4871fa753f25caaa0e032578a30457bff0af6a", size = 10456989 },
    { url = "https://files.pythonhosted.org/packages/c6/56/71ad5022e2f63cfe0ca93559403d0edef14aea70a841d640bd13cdba578e/numpy-2.3.1-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:2959d8f268f3d8ee402b04a9ec4bb7604555aeacf78b360dc4ec27f1d508177d", size = 20896664 },
    { url = "https://files.pythonhosted.org/packages/25/65/2db52ba049813670f7f987cc5db6dac9be7cd95e923cc6832b3d32d87cef/numpy-2.3.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:762e0c0c6b56bdedfef9a8e1d4538556438288c4276901ea008ae44091954e29", size = 14131078 },
    { url = "https://files.pythonhosted.org/packages/57/dd/28fa3c17b0e751047ac928c1e1b6990238faad76e9b147e585b573d9d1bd/numpy-2.3.1-cp312-cp312-macosx_14_0_arm64.whl", hash = "sha256:867ef172a0976aaa1f1d1b63cf2090de8b636a7674607d514505fb7276ab08fc", size = 5112554 },
    { url = "https://files.pythonhosted.org/packages/c9/fc/84ea0cba8e760c4644b708b6819d91784c290288c27aca916115e3311d17/numpy-2.3.1-cp312-cp312-macosx_14_0_x86_64.whl", hash = "sha256:4e602e1b8682c2b833af89ba641ad4176053aaa50f5cacda1a27004352dde943", size = 6646560 },
    { url = "https://files.pythonhosted.org/packages/61/b2/512b0c2ddec985ad1e496b0bd853eeb572315c0f07cd6997473ced8f15e2/numpy-2.3.1-cp312-cp312-manylinux_2_28_aarch64.whl", hash = "sha256:8e333040d069eba1652fb08962ec5b76af7f2c7bce1df7e1418c8055cf776f25", size = 14260638 },
    { url = "https://files.pythonhosted.org/packages/6e/45/c51cb248e679a6c6ab14b7a8e3ead3f4a3fe7425fc7a6f98b3f147bec532/numpy-2.3.1-cp312-cp312-manylinux_2_28_x86_64.whl", hash = "sha256:e7cbf5a5eafd8d230a3ce356d892512185230e4781a361229bd902ff403bc660", size = 16632729 },
    { url = "https://files.pythonhosted.org/packages/e4/ff/feb4be2e5c09a3da161b412019caf47183099cbea1132fd98061808c2df2/numpy-2.3.1-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:5f1b8f26d1086835f442286c1d9b64bb3974b0b1e41bb105358fd07d20872952", size = 15565330 },
    { url = "https://files.pythonhosted.org/packages/bc/6d/ceafe87587101e9ab0d370e4f6e5f3f3a85b9a697f2318738e5e7e176ce3/numpy-2.3.1-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:ee8340cb48c9b7a5899d1149eece41ca535513a9698098edbade2a8e7a84da77", size = 18361734 },
    { url = "https://files.pythonhosted.org/packages/2b/19/0fb49a3ea088be691f040c9bf1817e4669a339d6e98579f91859b902c636/numpy-2.3.1-cp312-cp312-win32.whl", hash = "sha256:e772dda20a6002ef7061713dc1e2585bc1b534e7909b2030b5a46dae8ff077ab", size = 6320411 },
    { url = "https://files.pythonhosted.org/packages/b1/3e/e28f4c1dd9e042eb57a3eb652f200225e311b608632bc727ae378623d4f8/numpy-2.3.1-cp312-cp312-win_amd64.whl", hash = "sha256:cfecc7822543abdea6de08758091da655ea2210b8ffa1faf116b940693d3df76", size = 12734973 },
    { url = "https://files.pythonhosted.org/packages/04/a8/8a5e9079dc722acf53522b8f8842e79541ea81835e9b5483388701421073/numpy-2.3.1-cp312-cp312-win_arm64.whl", hash = "sha256:7be91b2239af2658653c5bb6f1b8bccafaf08226a258caf78ce44710a0160d30", size = 10191491 },
    { url = "https://files.pythonhosted.org/packages/d4/bd/35ad97006d8abff8631293f8ea6adf07b0108ce6fec68da3c3fcca1197f2/numpy-2.3.1-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:25a1992b0a3fdcdaec9f552ef10d8103186f5397ab45e2d25f8ac51b1a6b97e8", size = 20889381 },
    { url = "https://files.pythonhosted.org/packages/f1/4f/df5923874d8095b6062495b39729178eef4a922119cee32a12ee1bd4664c/numpy-2.3.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:7dea630156d39b02a63c18f508f85010230409db5b2927ba59c8ba4ab3e8272e", size = 14152726 },
    { url = "https://files.pythonhosted.org/packages/8c/0f/a1f269b125806212a876f7efb049b06c6f8772cf0121139f97774cd95626/numpy-2.3.1-cp313-cp313-macosx_14_0_arm64.whl", hash = "sha256:bada6058dd886061f10ea15f230ccf7dfff40572e99fef440a4a857c8728c9c0", size = 5105145 },
    { url = "https://files.pythonhosted.org/packages/6d/63/a7f7fd5f375b0361682f6ffbf686787e82b7bbd561268e4f30afad2bb3c0/numpy-2.3.1-cp313-cp313-macosx_14_0_x86_64.whl", hash = "sha256:a894f3816eb17b29e4783e5873f92faf55b710c2519e5c351767c51f79d8526d", size = 6639409 },
    { url = "https://files.pythonhosted.org/packages/bf/0d/1854a4121af895aab383f4aa233748f1df4671ef331d898e32426756a8a6/numpy-2.3.1-cp313-cp313-manylinux_2_28_aarch64.whl", hash = "sha256:18703df6c4a4fee55fd3d6e5a253d01c5d33a295409b03fda0c86b3ca2ff41a1", size = 14257630 },
    { url = "https://files.pythonhosted.org/packages/50/30/af1b277b443f2fb08acf1c55ce9d68ee540043f158630d62cef012750f9f/numpy-2.3.1-cp313-cp313-manylinux_2_28_x86_64.whl", hash = "sha256:5902660491bd7a48b2ec16c23ccb9124b8abfd9583c5fdfa123fe6b421e03de1", size = 16627546 },
    { url = "https://files.pythonhosted.org/packages/6e/ec/3b68220c277e463095342d254c61be8144c31208db18d3fd8ef02712bcd6/numpy-2.3.1-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:36890eb9e9d2081137bd78d29050ba63b8dab95dff7912eadf1185e80074b2a0", size = 15562538 },
    { url = "https://files.pythonhosted.org/packages/77/2b/4014f2bcc4404484021c74d4c5ee8eb3de7e3f7ac75f06672f8dcf85140a/numpy-2.3.1-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:a780033466159c2270531e2b8ac063704592a0bc62ec4a1b991c7c40705eb0e8", size = 18360327 },
    { url = "https://files.pythonhosted.org/packages/40/8d/2ddd6c9b30fcf920837b8672f6c65590c7d92e43084c25fc65edc22e93ca/numpy-2.3.1-cp313-cp313-win32.whl", hash = "sha256:39bff12c076812595c3a306f22bfe49919c5513aa1e0e70fac756a0be7c2a2b8", size = 6312330 },
    { url = "https://files.pythonhosted.org/packages/dd/c8/beaba449925988d415efccb45bf977ff8327a02f655090627318f6398c7b/numpy-2.3.1-cp313-cp313-win_amd64.whl", hash = "sha256:8d5ee6eec45f08ce507a6570e06f2f879b374a552087a4179ea7838edbcbfa42", size = 12731565 },
    { url = "https://files.pythonhosted.org/packages/0b/c3/5c0c575d7ec78c1126998071f58facfc124006635da75b090805e642c62e/numpy-2.3.1-cp313-cp313-win_arm64.whl", hash = "sha256:0c4d9e0a8368db90f93bd192bfa771ace63137c3488d198ee21dfb8e7771916e", size = 10190262 },
    { url = "https://files.pythonhosted.org/packages/ea/19/a029cd335cf72f79d2644dcfc22d90f09caa86265cbbde3b5702ccef6890/numpy-2.3.1-cp313-cp313t-macosx_10_13_x86_64.whl", hash = "sha256:b0b5397374f32ec0649dd98c652a1798192042e715df918c20672c62fb52d4b8", size = 20987593 },
    { url = "https://files.pythonhosted.org/packages/25/91/8ea8894406209107d9ce19b66314194675d31761fe2cb3c84fe2eeae2f37/numpy-2.3.1-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:c5bdf2015ccfcee8253fb8be695516ac4457c743473a43290fd36eba6a1777eb", size = 14300523 },
    { url = "https://files.pythonhosted.org/packages/a6/7f/06187b0066eefc9e7ce77d5f2ddb4e314a55220ad62dd0bfc9f2c44bac14/numpy-2.3.1-cp313-cp313t-macosx_14_0_arm64.whl", hash = "sha256:d70f20df7f08b90a2062c1f07737dd340adccf2068d0f1b9b3d56e2038979fee", size = 5227993 },
    { url = "https://files.pythonhosted.org/packages/e8/ec/a926c293c605fa75e9cfb09f1e4840098ed46d2edaa6e2152ee35dc01ed3/numpy-2.3.1-cp313-cp313t-macosx_14_0_x86_64.whl", hash = "sha256:2fb86b7e58f9ac50e1e9dd1290154107e47d1eef23a0ae9145ded06ea606f992", size = 6736652 },
    { url = "https://files.pythonhosted.org/packages/e3/62/d68e52fb6fde5586650d4c0ce0b05ff3a48ad4df4ffd1b8866479d1d671d/numpy-2.3.1-cp313-cp313t-manylinux_2_28_aarch64.whl", hash = "sha256:23ab05b2d241f76cb883ce8b9a93a680752fbfcbd51c50eff0b88b979e471d8c", size = 14331561 },
    { url = "https://files.pythonhosted.org/packages/fc/ec/b74d3f2430960044bdad6900d9f5edc2dc0fb8bf5a0be0f65287bf2cbe27/numpy-2.3.1-cp313-cp313t-manylinux_2_28_x86_64.whl", hash = "sha256:ce2ce9e5de4703a673e705183f64fd5da5bf36e7beddcb63a25ee2286e71ca48", size = 16693349 },
    { url = "https://files.pythonhosted.org/packages/0d/15/def96774b9d7eb198ddadfcbd20281b20ebb510580419197e225f5c55c3e/numpy-2.3.1-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:c4913079974eeb5c16ccfd2b1f09354b8fed7e0d6f2cab933104a09a6419b1ee", size = 15642053 },
    { url = "https://files.pythonhosted.org/packages/2b/57/c3203974762a759540c6ae71d0ea2341c1fa41d84e4971a8e76d7141678a/numpy-2.3.1-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:010ce9b4f00d5c036053ca684c77441f2f2c934fd23bee058b4d6f196efd8280", size = 18434184 },
    { url = "https://files.pythonhosted.org/packages/22/8a/ccdf201457ed8ac6245187850aff4ca56a79edbea4829f4e9f14d46fa9a5/numpy-2.3.1-cp313-cp313t-win32.whl", hash = "sha256:6269b9edfe32912584ec496d91b00b6d34282ca1d07eb10e82dfc780907d6c2e", size = 6440678 },
    { url = "https://files.pythonhosted.org/packages/f1/7e/7f431d8bd8eb7e03d79294aed238b1b0b174b3148570d03a8a8a8f6a0da9/numpy-2.3.1-cp313-cp313t-win_amd64.whl", hash = "sha256:2a809637460e88a113e186e87f228d74ae2852a2e0c44de275263376f17b5bdc", size = 12870697 },
    { url = "https://files.pythonhosted.org/packages/d4/ca/af82bf0fad4c3e573c6930ed743b5308492ff19917c7caaf2f9b6f9e2e98/numpy-2.3.1-cp313-cp313t-win_arm64.whl", hash = "sha256:eccb9a159db9aed60800187bc47a6d3451553f0e1b08b068d8b277ddfbb9b244", size = 10260376 },
    { url = "https://files.pythonhosted.org/packages/e8/34/facc13b9b42ddca30498fc51f7f73c3d0f2be179943a4b4da8686e259740/numpy-2.3.1-pp311-pypy311_pp73-macosx_10_15_x86_64.whl", hash = "sha256:ad506d4b09e684394c42c966ec1527f6ebc25da7f4da4b1b056606ffe446b8a3", size = 21070637 },
    { url = "https://files.pythonhosted.org/packages/65/b6/41b705d9dbae04649b529fc9bd3387664c3281c7cd78b404a4efe73dcc45/numpy-2.3.1-pp311-pypy311_pp73-macosx_14_0_arm64.whl", hash = "sha256:ebb8603d45bc86bbd5edb0d63e52c5fd9e7945d3a503b77e486bd88dde67a19b", size = 5304087 },
    { url = "https://files.pythonhosted.org/packages/7a/b4/fe3ac1902bff7a4934a22d49e1c9d71a623204d654d4cc43c6e8fe337fcb/numpy-2.3.1-pp311-pypy311_pp73-macosx_14_0_x86_64.whl", hash = "sha256:15aa4c392ac396e2ad3d0a2680c0f0dee420f9fed14eef09bdb9450ee6dcb7b7", size = 6817588 },
    { url = "https://files.pythonhosted.org/packages/ae/ee/89bedf69c36ace1ac8f59e97811c1f5031e179a37e4821c3a230bf750142/numpy-2.3.1-pp311-pypy311_pp73-manylinux_2_28_aarch64.whl", hash = "sha256:c6e0bf9d1a2f50d2b65a7cf56db37c095af17b59f6c132396f7c6d5dd76484df", size = 14399010 },
    { url = "https://files.pythonhosted.org/packages/15/08/e00e7070ede29b2b176165eba18d6f9784d5349be3c0c1218338e79c27fd/numpy-2.3.1-pp311-pypy311_pp73-manylinux_2_28_x86_64.whl", hash = "sha256:eabd7e8740d494ce2b4ea0ff05afa1b7b291e978c0ae075487c51e8bd93c0c68", size = 16752042 },
    { url = "https://files.pythonhosted.org/packages/48/6b/1c6b515a83d5564b1698a61efa245727c8feecf308f4091f565988519d20/numpy-2.3.1-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:e610832418a2bc09d974cc9fecebfa51e9532d6190223bc5ef6a7402ebf3b5cb", size = 12927246 },
]

[[package]]
name = "packaging"
version = "25.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a1/d4/1fc4078c65507b51b96ca8f8c3ba19e6a61c8253c72794544580a7b6c24d/packaging-25.0.tar.gz", hash = "sha256:d443872c98d677bf60f6a1f2f8c1cb748e8fe762d2bf9d3148b5599295b0fc4f", size = 165727 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/20/12/38679034af332785aac8774540895e234f4d07f7545804097de4b666afd8/packaging-25.0-py3-none-any.whl", hash = "sha256:29572ef2b1f17581046b3a2227d5c611fb25ec70ca1ba8554b24b0e69331a484", size = 66469 },
]

[[package]]
name = "paho-mqtt"
version = "2.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/39/15/0a6214e76d4d32e7f663b109cf71fb22561c2be0f701d67f93950cd40542/paho_mqtt-2.1.0.tar.gz", hash = "sha256:12d6e7511d4137555a3f6ea167ae846af2c7357b10bc6fa4f7c3968fc1723834", size = 148848 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c4/cb/00451c3cf31790287768bb12c6bec834f5d292eaf3022afc88e14b8afc94/paho_mqtt-2.1.0-py3-none-any.whl", hash = "sha256:6db9ba9b34ed5bc6b6e3812718c7e06e2fd7444540df2455d2c51bd58808feee", size = 67219 },
]

[[package]]
name = "pluggy"
version = "1.6.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f9/e2/3e91f31a7d2b083fe6ef3fa267035b518369d9511ffab804f839851d2779/pluggy-1.6.0.tar.gz", hash = "sha256:7dcc130b76258d33b90f61b658791dede3486c3e6bfb003ee5c9bfb396dd22f3", size = 69412 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/54/20/4d324d65cc6d9205fabedc306948156824eb9f0ee1633355a8f7ec5c66bf/pluggy-1.6.0-py3-none-any.whl", hash = "sha256:e920276dd6813095e9377c0bc5566d94c932c33b27a3e3945d8389c374dd4746", size = 20538 },
]

[[package]]
name = "psutil"
version = "7.0.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/2a/80/336820c1ad9286a4ded7e845b2eccfcb27851ab8ac6abece774a6ff4d3de/psutil-7.0.0.tar.gz", hash = "sha256:7be9c3eba38beccb6495ea33afd982a44074b78f28c434a1f51cc07fd315c456", size = 497003 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/ed/e6/2d26234410f8b8abdbf891c9da62bee396583f713fb9f3325a4760875d22/psutil-7.0.0-cp36-abi3-macosx_10_9_x86_64.whl", hash = "sha256:101d71dc322e3cffd7cea0650b09b3d08b8e7c4109dd6809fe452dfd00e58b25", size = 238051 },
    { url = "https://files.pythonhosted.org/packages/04/8b/30f930733afe425e3cbfc0e1468a30a18942350c1a8816acfade80c005c4/psutil-7.0.0-cp36-abi3-macosx_11_0_arm64.whl", hash = "sha256:39db632f6bb862eeccf56660871433e111b6ea58f2caea825571951d4b6aa3da", size = 239535 },
    { url = "https://files.pythonhosted.org/packages/2a/ed/d362e84620dd22876b55389248e522338ed1bf134a5edd3b8231d7207f6d/psutil-7.0.0-cp36-abi3-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:1fcee592b4c6f146991ca55919ea3d1f8926497a713ed7faaf8225e174581e91", size = 275004 },
    { url = "https://files.pythonhosted.org/packages/bf/b9/b0eb3f3cbcb734d930fdf839431606844a825b23eaf9a6ab371edac8162c/psutil-7.0.0-cp36-abi3-manylinux_2_12_x86_64.manylinux2010_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:4b1388a4f6875d7e2aff5c4ca1cc16c545ed41dd8bb596cefea80111db353a34", size = 277986 },
    { url = "https://files.pythonhosted.org/packages/eb/a2/709e0fe2f093556c17fbafda93ac032257242cabcc7ff3369e2cb76a97aa/psutil-7.0.0-cp36-abi3-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a5f098451abc2828f7dc6b58d44b532b22f2088f4999a937557b603ce72b1993", size = 279544 },
    { url = "https://files.pythonhosted.org/packages/50/e6/eecf58810b9d12e6427369784efe814a1eec0f492084ce8eb8f4d89d6d61/psutil-7.0.0-cp37-abi3-win32.whl", hash = "sha256:ba3fcef7523064a6c9da440fc4d6bd07da93ac726b5733c29027d7dc95b39d99", size = 241053 },
    { url = "https://files.pythonhosted.org/packages/50/1b/6921afe68c74868b4c9fa424dad3be35b095e16687989ebbb50ce4fceb7c/psutil-7.0.0-cp37-abi3-win_amd64.whl", hash = "sha256:4cf3d4eb1aa9b348dec30105c55cd9b7d4629285735a102beb4441e38db90553", size = 244885 },
]

[[package]]
name = "pydantic"
version = "2.11.7"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "annotated-types" },
    { name = "pydantic-core" },
    { name = "typing-extensions" },
    { name = "typing-inspection" },
]
sdist = { url = "https://files.pythonhosted.org/packages/00/dd/4325abf92c39ba8623b5af936ddb36ffcfe0beae70405d456ab1fb2f5b8c/pydantic-2.11.7.tar.gz", hash = "sha256:d989c3c6cb79469287b1569f7447a17848c998458d49ebe294e975b9baf0f0db", size = 788350 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6a/c0/ec2b1c8712ca690e5d61979dee872603e92b8a32f94cc1b72d53beab008a/pydantic-2.11.7-py3-none-any.whl", hash = "sha256:dde5df002701f6de26248661f6835bbe296a47bf73990135c7d07ce741b9623b", size = 444782 },
]

[[package]]
name = "pydantic-core"
version = "2.33.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/ad/88/5f2260bdfae97aabf98f1778d43f69574390ad787afb646292a638c923d4/pydantic_core-2.33.2.tar.gz", hash = "sha256:7cb8bc3605c29176e1b105350d2e6474142d7c1bd1d9327c4a9bdb46bf827acc", size = 435195 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e5/92/b31726561b5dae176c2d2c2dc43a9c5bfba5d32f96f8b4c0a600dd492447/pydantic_core-2.33.2-cp310-cp310-macosx_10_12_x86_64.whl", hash = "sha256:2b3d326aaef0c0399d9afffeb6367d5e26ddc24d351dbc9c636840ac355dc5d8", size = 2028817 },
    { url = "https://files.pythonhosted.org/packages/a3/44/3f0b95fafdaca04a483c4e685fe437c6891001bf3ce8b2fded82b9ea3aa1/pydantic_core-2.33.2-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:0e5b2671f05ba48b94cb90ce55d8bdcaaedb8ba00cc5359f6810fc918713983d", size = 1861357 },
    { url = "https://files.pythonhosted.org/packages/30/97/e8f13b55766234caae05372826e8e4b3b96e7b248be3157f53237682e43c/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0069c9acc3f3981b9ff4cdfaf088e98d83440a4c7ea1bc07460af3d4dc22e72d", size = 1898011 },
    { url = "https://files.pythonhosted.org/packages/9b/a3/99c48cf7bafc991cc3ee66fd544c0aae8dc907b752f1dad2d79b1b5a471f/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:d53b22f2032c42eaaf025f7c40c2e3b94568ae077a606f006d206a463bc69572", size = 1982730 },
    { url = "https://files.pythonhosted.org/packages/de/8e/a5b882ec4307010a840fb8b58bd9bf65d1840c92eae7534c7441709bf54b/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:0405262705a123b7ce9f0b92f123334d67b70fd1f20a9372b907ce1080c7ba02", size = 2136178 },
    { url = "https://files.pythonhosted.org/packages/e4/bb/71e35fc3ed05af6834e890edb75968e2802fe98778971ab5cba20a162315/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:4b25d91e288e2c4e0662b8038a28c6a07eaac3e196cfc4ff69de4ea3db992a1b", size = 2736462 },
    { url = "https://files.pythonhosted.org/packages/31/0d/c8f7593e6bc7066289bbc366f2235701dcbebcd1ff0ef8e64f6f239fb47d/pydantic_core-2.33.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:6bdfe4b3789761f3bcb4b1ddf33355a71079858958e3a552f16d5af19768fef2", size = 2005652 },
    { url = "https://files.pythonhosted.org/packages/d2/7a/996d8bd75f3eda405e3dd219ff5ff0a283cd8e34add39d8ef9157e722867/pydantic_core-2.33.2-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:efec8db3266b76ef9607c2c4c419bdb06bf335ae433b80816089ea7585816f6a", size = 2113306 },
    { url = "https://files.pythonhosted.org/packages/ff/84/daf2a6fb2db40ffda6578a7e8c5a6e9c8affb251a05c233ae37098118788/pydantic_core-2.33.2-cp310-cp310-musllinux_1_1_aarch64.whl", hash = "sha256:031c57d67ca86902726e0fae2214ce6770bbe2f710dc33063187a68744a5ecac", size = 2073720 },
    { url = "https://files.pythonhosted.org/packages/77/fb/2258da019f4825128445ae79456a5499c032b55849dbd5bed78c95ccf163/pydantic_core-2.33.2-cp310-cp310-musllinux_1_1_armv7l.whl", hash = "sha256:f8de619080e944347f5f20de29a975c2d815d9ddd8be9b9b7268e2e3ef68605a", size = 2244915 },
    { url = "https://files.pythonhosted.org/packages/d8/7a/925ff73756031289468326e355b6fa8316960d0d65f8b5d6b3a3e7866de7/pydantic_core-2.33.2-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:73662edf539e72a9440129f231ed3757faab89630d291b784ca99237fb94db2b", size = 2241884 },
    { url = "https://files.pythonhosted.org/packages/0b/b0/249ee6d2646f1cdadcb813805fe76265745c4010cf20a8eba7b0e639d9b2/pydantic_core-2.33.2-cp310-cp310-win32.whl", hash = "sha256:0a39979dcbb70998b0e505fb1556a1d550a0781463ce84ebf915ba293ccb7e22", size = 1910496 },
    { url = "https://files.pythonhosted.org/packages/66/ff/172ba8f12a42d4b552917aa65d1f2328990d3ccfc01d5b7c943ec084299f/pydantic_core-2.33.2-cp310-cp310-win_amd64.whl", hash = "sha256:b0379a2b24882fef529ec3b4987cb5d003b9cda32256024e6fe1586ac45fc640", size = 1955019 },
    { url = "https://files.pythonhosted.org/packages/3f/8d/71db63483d518cbbf290261a1fc2839d17ff89fce7089e08cad07ccfce67/pydantic_core-2.33.2-cp311-cp311-macosx_10_12_x86_64.whl", hash = "sha256:4c5b0a576fb381edd6d27f0a85915c6daf2f8138dc5c267a57c08a62900758c7", size = 2028584 },
    { url = "https://files.pythonhosted.org/packages/24/2f/3cfa7244ae292dd850989f328722d2aef313f74ffc471184dc509e1e4e5a/pydantic_core-2.33.2-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:e799c050df38a639db758c617ec771fd8fb7a5f8eaaa4b27b101f266b216a246", size = 1855071 },
    { url = "https://files.pythonhosted.org/packages/b3/d3/4ae42d33f5e3f50dd467761304be2fa0a9417fbf09735bc2cce003480f2a/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:dc46a01bf8d62f227d5ecee74178ffc448ff4e5197c756331f71efcc66dc980f", size = 1897823 },
    { url = "https://files.pythonhosted.org/packages/f4/f3/aa5976e8352b7695ff808599794b1fba2a9ae2ee954a3426855935799488/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:a144d4f717285c6d9234a66778059f33a89096dfb9b39117663fd8413d582dcc", size = 1983792 },
    { url = "https://files.pythonhosted.org/packages/d5/7a/cda9b5a23c552037717f2b2a5257e9b2bfe45e687386df9591eff7b46d28/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:73cf6373c21bc80b2e0dc88444f41ae60b2f070ed02095754eb5a01df12256de", size = 2136338 },
    { url = "https://files.pythonhosted.org/packages/2b/9f/b8f9ec8dd1417eb9da784e91e1667d58a2a4a7b7b34cf4af765ef663a7e5/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:3dc625f4aa79713512d1976fe9f0bc99f706a9dee21dfd1810b4bbbf228d0e8a", size = 2730998 },
    { url = "https://files.pythonhosted.org/packages/47/bc/cd720e078576bdb8255d5032c5d63ee5c0bf4b7173dd955185a1d658c456/pydantic_core-2.33.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:881b21b5549499972441da4758d662aeea93f1923f953e9cbaff14b8b9565aef", size = 2003200 },
    { url = "https://files.pythonhosted.org/packages/ca/22/3602b895ee2cd29d11a2b349372446ae9727c32e78a94b3d588a40fdf187/pydantic_core-2.33.2-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:bdc25f3681f7b78572699569514036afe3c243bc3059d3942624e936ec93450e", size = 2113890 },
    { url = "https://files.pythonhosted.org/packages/ff/e6/e3c5908c03cf00d629eb38393a98fccc38ee0ce8ecce32f69fc7d7b558a7/pydantic_core-2.33.2-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:fe5b32187cbc0c862ee201ad66c30cf218e5ed468ec8dc1cf49dec66e160cc4d", size = 2073359 },
    { url = "https://files.pythonhosted.org/packages/12/e7/6a36a07c59ebefc8777d1ffdaf5ae71b06b21952582e4b07eba88a421c79/pydantic_core-2.33.2-cp311-cp311-musllinux_1_1_armv7l.whl", hash = "sha256:bc7aee6f634a6f4a95676fcb5d6559a2c2a390330098dba5e5a5f28a2e4ada30", size = 2245883 },
    { url = "https://files.pythonhosted.org/packages/16/3f/59b3187aaa6cc0c1e6616e8045b284de2b6a87b027cce2ffcea073adf1d2/pydantic_core-2.33.2-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:235f45e5dbcccf6bd99f9f472858849f73d11120d76ea8707115415f8e5ebebf", size = 2241074 },
    { url = "https://files.pythonhosted.org/packages/e0/ed/55532bb88f674d5d8f67ab121a2a13c385df382de2a1677f30ad385f7438/pydantic_core-2.33.2-cp311-cp311-win32.whl", hash = "sha256:6368900c2d3ef09b69cb0b913f9f8263b03786e5b2a387706c5afb66800efd51", size = 1910538 },
    { url = "https://files.pythonhosted.org/packages/fe/1b/25b7cccd4519c0b23c2dd636ad39d381abf113085ce4f7bec2b0dc755eb1/pydantic_core-2.33.2-cp311-cp311-win_amd64.whl", hash = "sha256:1e063337ef9e9820c77acc768546325ebe04ee38b08703244c1309cccc4f1bab", size = 1952909 },
    { url = "https://files.pythonhosted.org/packages/49/a9/d809358e49126438055884c4366a1f6227f0f84f635a9014e2deb9b9de54/pydantic_core-2.33.2-cp311-cp311-win_arm64.whl", hash = "sha256:6b99022f1d19bc32a4c2a0d544fc9a76e3be90f0b3f4af413f87d38749300e65", size = 1897786 },
    { url = "https://files.pythonhosted.org/packages/18/8a/2b41c97f554ec8c71f2a8a5f85cb56a8b0956addfe8b0efb5b3d77e8bdc3/pydantic_core-2.33.2-cp312-cp312-macosx_10_12_x86_64.whl", hash = "sha256:a7ec89dc587667f22b6a0b6579c249fca9026ce7c333fc142ba42411fa243cdc", size = 2009000 },
    { url = "https://files.pythonhosted.org/packages/a1/02/6224312aacb3c8ecbaa959897af57181fb6cf3a3d7917fd44d0f2917e6f2/pydantic_core-2.33.2-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:3c6db6e52c6d70aa0d00d45cdb9b40f0433b96380071ea80b09277dba021ddf7", size = 1847996 },
    { url = "https://files.pythonhosted.org/packages/d6/46/6dcdf084a523dbe0a0be59d054734b86a981726f221f4562aed313dbcb49/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:4e61206137cbc65e6d5256e1166f88331d3b6238e082d9f74613b9b765fb9025", size = 1880957 },
    { url = "https://files.pythonhosted.org/packages/ec/6b/1ec2c03837ac00886ba8160ce041ce4e325b41d06a034adbef11339ae422/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:eb8c529b2819c37140eb51b914153063d27ed88e3bdc31b71198a198e921e011", size = 1964199 },
    { url = "https://files.pythonhosted.org/packages/2d/1d/6bf34d6adb9debd9136bd197ca72642203ce9aaaa85cfcbfcf20f9696e83/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:c52b02ad8b4e2cf14ca7b3d918f3eb0ee91e63b3167c32591e57c4317e134f8f", size = 2120296 },
    { url = "https://files.pythonhosted.org/packages/e0/94/2bd0aaf5a591e974b32a9f7123f16637776c304471a0ab33cf263cf5591a/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:96081f1605125ba0855dfda83f6f3df5ec90c61195421ba72223de35ccfb2f88", size = 2676109 },
    { url = "https://files.pythonhosted.org/packages/f9/41/4b043778cf9c4285d59742281a769eac371b9e47e35f98ad321349cc5d61/pydantic_core-2.33.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:8f57a69461af2a5fa6e6bbd7a5f60d3b7e6cebb687f55106933188e79ad155c1", size = 2002028 },
    { url = "https://files.pythonhosted.org/packages/cb/d5/7bb781bf2748ce3d03af04d5c969fa1308880e1dca35a9bd94e1a96a922e/pydantic_core-2.33.2-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:572c7e6c8bb4774d2ac88929e3d1f12bc45714ae5ee6d9a788a9fb35e60bb04b", size = 2100044 },
    { url = "https://files.pythonhosted.org/packages/fe/36/def5e53e1eb0ad896785702a5bbfd25eed546cdcf4087ad285021a90ed53/pydantic_core-2.33.2-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:db4b41f9bd95fbe5acd76d89920336ba96f03e149097365afe1cb092fceb89a1", size = 2058881 },
    { url = "https://files.pythonhosted.org/packages/01/6c/57f8d70b2ee57fc3dc8b9610315949837fa8c11d86927b9bb044f8705419/pydantic_core-2.33.2-cp312-cp312-musllinux_1_1_armv7l.whl", hash = "sha256:fa854f5cf7e33842a892e5c73f45327760bc7bc516339fda888c75ae60edaeb6", size = 2227034 },
    { url = "https://files.pythonhosted.org/packages/27/b9/9c17f0396a82b3d5cbea4c24d742083422639e7bb1d5bf600e12cb176a13/pydantic_core-2.33.2-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:5f483cfb75ff703095c59e365360cb73e00185e01aaea067cd19acffd2ab20ea", size = 2234187 },
    { url = "https://files.pythonhosted.org/packages/b0/6a/adf5734ffd52bf86d865093ad70b2ce543415e0e356f6cacabbc0d9ad910/pydantic_core-2.33.2-cp312-cp312-win32.whl", hash = "sha256:9cb1da0f5a471435a7bc7e439b8a728e8b61e59784b2af70d7c169f8dd8ae290", size = 1892628 },
    { url = "https://files.pythonhosted.org/packages/43/e4/5479fecb3606c1368d496a825d8411e126133c41224c1e7238be58b87d7e/pydantic_core-2.33.2-cp312-cp312-win_amd64.whl", hash = "sha256:f941635f2a3d96b2973e867144fde513665c87f13fe0e193c158ac51bfaaa7b2", size = 1955866 },
    { url = "https://files.pythonhosted.org/packages/0d/24/8b11e8b3e2be9dd82df4b11408a67c61bb4dc4f8e11b5b0fc888b38118b5/pydantic_core-2.33.2-cp312-cp312-win_arm64.whl", hash = "sha256:cca3868ddfaccfbc4bfb1d608e2ccaaebe0ae628e1416aeb9c4d88c001bb45ab", size = 1888894 },
    { url = "https://files.pythonhosted.org/packages/46/8c/99040727b41f56616573a28771b1bfa08a3d3fe74d3d513f01251f79f172/pydantic_core-2.33.2-cp313-cp313-macosx_10_12_x86_64.whl", hash = "sha256:1082dd3e2d7109ad8b7da48e1d4710c8d06c253cbc4a27c1cff4fbcaa97a9e3f", size = 2015688 },
    { url = "https://files.pythonhosted.org/packages/3a/cc/5999d1eb705a6cefc31f0b4a90e9f7fc400539b1a1030529700cc1b51838/pydantic_core-2.33.2-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:f517ca031dfc037a9c07e748cefd8d96235088b83b4f4ba8939105d20fa1dcd6", size = 1844808 },
    { url = "https://files.pythonhosted.org/packages/6f/5e/a0a7b8885c98889a18b6e376f344da1ef323d270b44edf8174d6bce4d622/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0a9f2c9dd19656823cb8250b0724ee9c60a82f3cdf68a080979d13092a3b0fef", size = 1885580 },
    { url = "https://files.pythonhosted.org/packages/3b/2a/953581f343c7d11a304581156618c3f592435523dd9d79865903272c256a/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:2b0a451c263b01acebe51895bfb0e1cc842a5c666efe06cdf13846c7418caa9a", size = 1973859 },
    { url = "https://files.pythonhosted.org/packages/e6/55/f1a813904771c03a3f97f676c62cca0c0a4138654107c1b61f19c644868b/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:1ea40a64d23faa25e62a70ad163571c0b342b8bf66d5fa612ac0dec4f069d916", size = 2120810 },
    { url = "https://files.pythonhosted.org/packages/aa/c3/053389835a996e18853ba107a63caae0b9deb4a276c6b472931ea9ae6e48/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:0fb2d542b4d66f9470e8065c5469ec676978d625a8b7a363f07d9a501a9cb36a", size = 2676498 },
    { url = "https://files.pythonhosted.org/packages/eb/3c/f4abd740877a35abade05e437245b192f9d0ffb48bbbbd708df33d3cda37/pydantic_core-2.33.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9fdac5d6ffa1b5a83bca06ffe7583f5576555e6c8b3a91fbd25ea7780f825f7d", size = 2000611 },
    { url = "https://files.pythonhosted.org/packages/59/a7/63ef2fed1837d1121a894d0ce88439fe3e3b3e48c7543b2a4479eb99c2bd/pydantic_core-2.33.2-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:04a1a413977ab517154eebb2d326da71638271477d6ad87a769102f7c2488c56", size = 2107924 },
    { url = "https://files.pythonhosted.org/packages/04/8f/2551964ef045669801675f1cfc3b0d74147f4901c3ffa42be2ddb1f0efc4/pydantic_core-2.33.2-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:c8e7af2f4e0194c22b5b37205bfb293d166a7344a5b0d0eaccebc376546d77d5", size = 2063196 },
    { url = "https://files.pythonhosted.org/packages/26/bd/d9602777e77fc6dbb0c7db9ad356e9a985825547dce5ad1d30ee04903918/pydantic_core-2.33.2-cp313-cp313-musllinux_1_1_armv7l.whl", hash = "sha256:5c92edd15cd58b3c2d34873597a1e20f13094f59cf88068adb18947df5455b4e", size = 2236389 },
    { url = "https://files.pythonhosted.org/packages/42/db/0e950daa7e2230423ab342ae918a794964b053bec24ba8af013fc7c94846/pydantic_core-2.33.2-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:65132b7b4a1c0beded5e057324b7e16e10910c106d43675d9bd87d4f38dde162", size = 2239223 },
    { url = "https://files.pythonhosted.org/packages/58/4d/4f937099c545a8a17eb52cb67fe0447fd9a373b348ccfa9a87f141eeb00f/pydantic_core-2.33.2-cp313-cp313-win32.whl", hash = "sha256:52fb90784e0a242bb96ec53f42196a17278855b0f31ac7c3cc6f5c1ec4811849", size = 1900473 },
    { url = "https://files.pythonhosted.org/packages/a0/75/4a0a9bac998d78d889def5e4ef2b065acba8cae8c93696906c3a91f310ca/pydantic_core-2.33.2-cp313-cp313-win_amd64.whl", hash = "sha256:c083a3bdd5a93dfe480f1125926afcdbf2917ae714bdb80b36d34318b2bec5d9", size = 1955269 },
    { url = "https://files.pythonhosted.org/packages/f9/86/1beda0576969592f1497b4ce8e7bc8cbdf614c352426271b1b10d5f0aa64/pydantic_core-2.33.2-cp313-cp313-win_arm64.whl", hash = "sha256:e80b087132752f6b3d714f041ccf74403799d3b23a72722ea2e6ba2e892555b9", size = 1893921 },
    { url = "https://files.pythonhosted.org/packages/a4/7d/e09391c2eebeab681df2b74bfe6c43422fffede8dc74187b2b0bf6fd7571/pydantic_core-2.33.2-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:61c18fba8e5e9db3ab908620af374db0ac1baa69f0f32df4f61ae23f15e586ac", size = 1806162 },
    { url = "https://files.pythonhosted.org/packages/f1/3d/847b6b1fed9f8ed3bb95a9ad04fbd0b212e832d4f0f50ff4d9ee5a9f15cf/pydantic_core-2.33.2-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:95237e53bb015f67b63c91af7518a62a8660376a6a0db19b89acc77a4d6199f5", size = 1981560 },
    { url = "https://files.pythonhosted.org/packages/6f/9a/e73262f6c6656262b5fdd723ad90f518f579b7bc8622e43a942eec53c938/pydantic_core-2.33.2-cp313-cp313t-win_amd64.whl", hash = "sha256:c2fc0a768ef76c15ab9238afa6da7f69895bb5d1ee83aeea2e3509af4472d0b9", size = 1935777 },
    { url = "https://files.pythonhosted.org/packages/53/ea/bbe9095cdd771987d13c82d104a9c8559ae9aec1e29f139e286fd2e9256e/pydantic_core-2.33.2-cp39-cp39-macosx_10_12_x86_64.whl", hash = "sha256:a2b911a5b90e0374d03813674bf0a5fbbb7741570dcd4b4e85a2e48d17def29d", size = 2028677 },
    { url = "https://files.pythonhosted.org/packages/49/1d/4ac5ed228078737d457a609013e8f7edc64adc37b91d619ea965758369e5/pydantic_core-2.33.2-cp39-cp39-macosx_11_0_arm64.whl", hash = "sha256:6fa6dfc3e4d1f734a34710f391ae822e0a8eb8559a85c6979e14e65ee6ba2954", size = 1864735 },
    { url = "https://files.pythonhosted.org/packages/23/9a/2e70d6388d7cda488ae38f57bc2f7b03ee442fbcf0d75d848304ac7e405b/pydantic_core-2.33.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:c54c939ee22dc8e2d545da79fc5381f1c020d6d3141d3bd747eab59164dc89fb", size = 1898467 },
    { url = "https://files.pythonhosted.org/packages/ff/2e/1568934feb43370c1ffb78a77f0baaa5a8b6897513e7a91051af707ffdc4/pydantic_core-2.33.2-cp39-cp39-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:53a57d2ed685940a504248187d5685e49eb5eef0f696853647bf37c418c538f7", size = 1983041 },
    { url = "https://files.pythonhosted.org/packages/01/1a/1a1118f38ab64eac2f6269eb8c120ab915be30e387bb561e3af904b12499/pydantic_core-2.33.2-cp39-cp39-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:09fb9dd6571aacd023fe6aaca316bd01cf60ab27240d7eb39ebd66a3a15293b4", size = 2136503 },
    { url = "https://files.pythonhosted.org/packages/5c/da/44754d1d7ae0f22d6d3ce6c6b1486fc07ac2c524ed8f6eca636e2e1ee49b/pydantic_core-2.33.2-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:0e6116757f7959a712db11f3e9c0a99ade00a5bbedae83cb801985aa154f071b", size = 2736079 },
    { url = "https://files.pythonhosted.org/packages/4d/98/f43cd89172220ec5aa86654967b22d862146bc4d736b1350b4c41e7c9c03/pydantic_core-2.33.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:8d55ab81c57b8ff8548c3e4947f119551253f4e3787a7bbc0b6b3ca47498a9d3", size = 2006508 },
    { url = "https://files.pythonhosted.org/packages/2b/cc/f77e8e242171d2158309f830f7d5d07e0531b756106f36bc18712dc439df/pydantic_core-2.33.2-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:c20c462aa4434b33a2661701b861604913f912254e441ab8d78d30485736115a", size = 2113693 },
    { url = "https://files.pythonhosted.org/packages/54/7a/7be6a7bd43e0a47c147ba7fbf124fe8aaf1200bc587da925509641113b2d/pydantic_core-2.33.2-cp39-cp39-musllinux_1_1_aarch64.whl", hash = "sha256:44857c3227d3fb5e753d5fe4a3420d6376fa594b07b621e220cd93703fe21782", size = 2074224 },
    { url = "https://files.pythonhosted.org/packages/2a/07/31cf8fadffbb03be1cb520850e00a8490c0927ec456e8293cafda0726184/pydantic_core-2.33.2-cp39-cp39-musllinux_1_1_armv7l.whl", hash = "sha256:eb9b459ca4df0e5c87deb59d37377461a538852765293f9e6ee834f0435a93b9", size = 2245403 },
    { url = "https://files.pythonhosted.org/packages/b6/8d/bbaf4c6721b668d44f01861f297eb01c9b35f612f6b8e14173cb204e6240/pydantic_core-2.33.2-cp39-cp39-musllinux_1_1_x86_64.whl", hash = "sha256:9fcd347d2cc5c23b06de6d3b7b8275be558a0c90549495c699e379a80bf8379e", size = 2242331 },
    { url = "https://files.pythonhosted.org/packages/bb/93/3cc157026bca8f5006250e74515119fcaa6d6858aceee8f67ab6dc548c16/pydantic_core-2.33.2-cp39-cp39-win32.whl", hash = "sha256:83aa99b1285bc8f038941ddf598501a86f1536789740991d7d8756e34f1e74d9", size = 1910571 },
    { url = "https://files.pythonhosted.org/packages/5b/90/7edc3b2a0d9f0dda8806c04e511a67b0b7a41d2187e2003673a996fb4310/pydantic_core-2.33.2-cp39-cp39-win_amd64.whl", hash = "sha256:f481959862f57f29601ccced557cc2e817bce7533ab8e01a797a48b49c9692b3", size = 1956504 },
    { url = "https://files.pythonhosted.org/packages/30/68/373d55e58b7e83ce371691f6eaa7175e3a24b956c44628eb25d7da007917/pydantic_core-2.33.2-pp310-pypy310_pp73-macosx_10_12_x86_64.whl", hash = "sha256:5c4aa4e82353f65e548c476b37e64189783aa5384903bfea4f41580f255fddfa", size = 2023982 },
    { url = "https://files.pythonhosted.org/packages/a4/16/145f54ac08c96a63d8ed6442f9dec17b2773d19920b627b18d4f10a061ea/pydantic_core-2.33.2-pp310-pypy310_pp73-macosx_11_0_arm64.whl", hash = "sha256:d946c8bf0d5c24bf4fe333af284c59a19358aa3ec18cb3dc4370080da1e8ad29", size = 1858412 },
    { url = "https://files.pythonhosted.org/packages/41/b1/c6dc6c3e2de4516c0bb2c46f6a373b91b5660312342a0cf5826e38ad82fa/pydantic_core-2.33.2-pp310-pypy310_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:87b31b6846e361ef83fedb187bb5b4372d0da3f7e28d85415efa92d6125d6e6d", size = 1892749 },
    { url = "https://files.pythonhosted.org/packages/12/73/8cd57e20afba760b21b742106f9dbdfa6697f1570b189c7457a1af4cd8a0/pydantic_core-2.33.2-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:aa9d91b338f2df0508606f7009fde642391425189bba6d8c653afd80fd6bb64e", size = 2067527 },
    { url = "https://files.pythonhosted.org/packages/e3/d5/0bb5d988cc019b3cba4a78f2d4b3854427fc47ee8ec8e9eaabf787da239c/pydantic_core-2.33.2-pp310-pypy310_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:2058a32994f1fde4ca0480ab9d1e75a0e8c87c22b53a3ae66554f9af78f2fe8c", size = 2108225 },
    { url = "https://files.pythonhosted.org/packages/f1/c5/00c02d1571913d496aabf146106ad8239dc132485ee22efe08085084ff7c/pydantic_core-2.33.2-pp310-pypy310_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:0e03262ab796d986f978f79c943fc5f620381be7287148b8010b4097f79a39ec", size = 2069490 },
    { url = "https://files.pythonhosted.org/packages/22/a8/dccc38768274d3ed3a59b5d06f59ccb845778687652daa71df0cab4040d7/pydantic_core-2.33.2-pp310-pypy310_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:1a8695a8d00c73e50bff9dfda4d540b7dee29ff9b8053e38380426a85ef10052", size = 2237525 },
    { url = "https://files.pythonhosted.org/packages/d4/e7/4f98c0b125dda7cf7ccd14ba936218397b44f50a56dd8c16a3091df116c3/pydantic_core-2.33.2-pp310-pypy310_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:fa754d1850735a0b0e03bcffd9d4b4343eb417e47196e4485d9cca326073a42c", size = 2238446 },
    { url = "https://files.pythonhosted.org/packages/ce/91/2ec36480fdb0b783cd9ef6795753c1dea13882f2e68e73bce76ae8c21e6a/pydantic_core-2.33.2-pp310-pypy310_pp73-win_amd64.whl", hash = "sha256:a11c8d26a50bfab49002947d3d237abe4d9e4b5bdc8846a63537b6488e197808", size = 2066678 },
    { url = "https://files.pythonhosted.org/packages/7b/27/d4ae6487d73948d6f20dddcd94be4ea43e74349b56eba82e9bdee2d7494c/pydantic_core-2.33.2-pp311-pypy311_pp73-macosx_10_12_x86_64.whl", hash = "sha256:dd14041875d09cc0f9308e37a6f8b65f5585cf2598a53aa0123df8b129d481f8", size = 2025200 },
    { url = "https://files.pythonhosted.org/packages/f1/b8/b3cb95375f05d33801024079b9392a5ab45267a63400bf1866e7ce0f0de4/pydantic_core-2.33.2-pp311-pypy311_pp73-macosx_11_0_arm64.whl", hash = "sha256:d87c561733f66531dced0da6e864f44ebf89a8fba55f31407b00c2f7f9449593", size = 1859123 },
    { url = "https://files.pythonhosted.org/packages/05/bc/0d0b5adeda59a261cd30a1235a445bf55c7e46ae44aea28f7bd6ed46e091/pydantic_core-2.33.2-pp311-pypy311_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:2f82865531efd18d6e07a04a17331af02cb7a651583c418df8266f17a63c6612", size = 1892852 },
    { url = "https://files.pythonhosted.org/packages/3e/11/d37bdebbda2e449cb3f519f6ce950927b56d62f0b84fd9cb9e372a26a3d5/pydantic_core-2.33.2-pp311-pypy311_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:2bfb5112df54209d820d7bf9317c7a6c9025ea52e49f46b6a2060104bba37de7", size = 2067484 },
    { url = "https://files.pythonhosted.org/packages/8c/55/1f95f0a05ce72ecb02a8a8a1c3be0579bbc29b1d5ab68f1378b7bebc5057/pydantic_core-2.33.2-pp311-pypy311_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:64632ff9d614e5eecfb495796ad51b0ed98c453e447a76bcbeeb69615079fc7e", size = 2108896 },
    { url = "https://files.pythonhosted.org/packages/53/89/2b2de6c81fa131f423246a9109d7b2a375e83968ad0800d6e57d0574629b/pydantic_core-2.33.2-pp311-pypy311_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:f889f7a40498cc077332c7ab6b4608d296d852182211787d4f3ee377aaae66e8", size = 2069475 },
    { url = "https://files.pythonhosted.org/packages/b8/e9/1f7efbe20d0b2b10f6718944b5d8ece9152390904f29a78e68d4e7961159/pydantic_core-2.33.2-pp311-pypy311_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:de4b83bb311557e439b9e186f733f6c645b9417c84e2eb8203f3f820a4b988bf", size = 2239013 },
    { url = "https://files.pythonhosted.org/packages/3c/b2/5309c905a93811524a49b4e031e9851a6b00ff0fb668794472ea7746b448/pydantic_core-2.33.2-pp311-pypy311_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:82f68293f055f51b51ea42fafc74b6aad03e70e191799430b90c13d643059ebb", size = 2238715 },
    { url = "https://files.pythonhosted.org/packages/32/56/8a7ca5d2cd2cda1d245d34b1c9a942920a718082ae8e54e5f3e5a58b7add/pydantic_core-2.33.2-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:329467cecfb529c925cf2bbd4d60d2c509bc2fb52a20c1045bf09bb70971a9c1", size = 2066757 },
    { url = "https://files.pythonhosted.org/packages/08/98/dbf3fdfabaf81cda5622154fda78ea9965ac467e3239078e0dcd6df159e7/pydantic_core-2.33.2-pp39-pypy39_pp73-macosx_10_12_x86_64.whl", hash = "sha256:87acbfcf8e90ca885206e98359d7dca4bcbb35abdc0ff66672a293e1d7a19101", size = 2024034 },
    { url = "https://files.pythonhosted.org/packages/8d/99/7810aa9256e7f2ccd492590f86b79d370df1e9292f1f80b000b6a75bd2fb/pydantic_core-2.33.2-pp39-pypy39_pp73-macosx_11_0_arm64.whl", hash = "sha256:7f92c15cd1e97d4b12acd1cc9004fa092578acfa57b67ad5e43a197175d01a64", size = 1858578 },
    { url = "https://files.pythonhosted.org/packages/d8/60/bc06fa9027c7006cc6dd21e48dbf39076dc39d9abbaf718a1604973a9670/pydantic_core-2.33.2-pp39-pypy39_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:d3f26877a748dc4251cfcfda9dfb5f13fcb034f5308388066bcfe9031b63ae7d", size = 1892858 },
    { url = "https://files.pythonhosted.org/packages/f2/40/9d03997d9518816c68b4dfccb88969756b9146031b61cd37f781c74c9b6a/pydantic_core-2.33.2-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:dac89aea9af8cd672fa7b510e7b8c33b0bba9a43186680550ccf23020f32d535", size = 2068498 },
    { url = "https://files.pythonhosted.org/packages/d8/62/d490198d05d2d86672dc269f52579cad7261ced64c2df213d5c16e0aecb1/pydantic_core-2.33.2-pp39-pypy39_pp73-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:970919794d126ba8645f3837ab6046fb4e72bbc057b3709144066204c19a455d", size = 2108428 },
    { url = "https://files.pythonhosted.org/packages/9a/ec/4cd215534fd10b8549015f12ea650a1a973da20ce46430b68fc3185573e8/pydantic_core-2.33.2-pp39-pypy39_pp73-musllinux_1_1_aarch64.whl", hash = "sha256:3eb3fe62804e8f859c49ed20a8451342de53ed764150cb14ca71357c765dc2a6", size = 2069854 },
    { url = "https://files.pythonhosted.org/packages/1a/1a/abbd63d47e1d9b0d632fee6bb15785d0889c8a6e0a6c3b5a8e28ac1ec5d2/pydantic_core-2.33.2-pp39-pypy39_pp73-musllinux_1_1_armv7l.whl", hash = "sha256:3abcd9392a36025e3bd55f9bd38d908bd17962cc49bc6da8e7e96285336e2bca", size = 2237859 },
    { url = "https://files.pythonhosted.org/packages/80/1c/fa883643429908b1c90598fd2642af8839efd1d835b65af1f75fba4d94fe/pydantic_core-2.33.2-pp39-pypy39_pp73-musllinux_1_1_x86_64.whl", hash = "sha256:3a1c81334778f9e3af2f8aeb7a960736e5cab1dfebfb26aabca09afd2906c039", size = 2239059 },
    { url = "https://files.pythonhosted.org/packages/d4/29/3cade8a924a61f60ccfa10842f75eb12787e1440e2b8660ceffeb26685e7/pydantic_core-2.33.2-pp39-pypy39_pp73-win_amd64.whl", hash = "sha256:2807668ba86cb38c6817ad9bc66215ab8584d1d304030ce4f0887336f28a5e27", size = 2066661 },
]

[[package]]
name = "pygments"
version = "2.19.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/b0/77/a5b8c569bf593b0140bde72ea885a803b82086995367bf2037de0159d924/pygments-2.19.2.tar.gz", hash = "sha256:636cb2477cec7f8952536970bc533bc43743542f70392ae026374600add5b887", size = 4968631 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c7/21/705964c7812476f378728bdf590ca4b771ec72385c533964653c68e86bdc/pygments-2.19.2-py3-none-any.whl", hash = "sha256:86540386c03d588bb81d44bc3928634ff26449851e99741617ecb9037ee5ec0b", size = 1225217 },
]

[[package]]
name = "pytest"
version = "8.4.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama", marker = "sys_platform == 'win32'" },
    { name = "exceptiongroup", marker = "python_full_version < '3.11'" },
    { name = "iniconfig" },
    { name = "packaging" },
    { name = "pluggy" },
    { name = "pygments" },
    { name = "tomli", marker = "python_full_version < '3.11'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/08/ba/45911d754e8eba3d5a841a5ce61a65a685ff1798421ac054f85aa8747dfb/pytest-8.4.1.tar.gz", hash = "sha256:7c67fd69174877359ed9371ec3af8a3d2b04741818c51e5e99cc1742251fa93c", size = 1517714 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/29/16/c8a903f4c4dffe7a12843191437d7cd8e32751d5de349d45d3fe69544e87/pytest-8.4.1-py3-none-any.whl", hash = "sha256:539c70ba6fcead8e78eebbf1115e8b589e7565830d7d006a8723f19ac8a0afb7", size = 365474 },
]

[[package]]
name = "pyyaml"
version = "6.0.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/54/ed/79a089b6be93607fa5cdaedf301d7dfb23af5f25c398d5ead2525b063e17/pyyaml-6.0.2.tar.gz", hash = "sha256:d584d9ec91ad65861cc08d42e834324ef890a082e591037abe114850ff7bbc3e", size = 130631 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/9b/95/a3fac87cb7158e231b5a6012e438c647e1a87f09f8e0d123acec8ab8bf71/PyYAML-6.0.2-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:0a9a2848a5b7feac301353437eb7d5957887edbf81d56e903999a75a3d743086", size = 184199 },
    { url = "https://files.pythonhosted.org/packages/c7/7a/68bd47624dab8fd4afbfd3c48e3b79efe09098ae941de5b58abcbadff5cb/PyYAML-6.0.2-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:29717114e51c84ddfba879543fb232a6ed60086602313ca38cce623c1d62cfbf", size = 171758 },
    { url = "https://files.pythonhosted.org/packages/49/ee/14c54df452143b9ee9f0f29074d7ca5516a36edb0b4cc40c3f280131656f/PyYAML-6.0.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:8824b5a04a04a047e72eea5cec3bc266db09e35de6bdfe34c9436ac5ee27d237", size = 718463 },
    { url = "https://files.pythonhosted.org/packages/4d/61/de363a97476e766574650d742205be468921a7b532aa2499fcd886b62530/PyYAML-6.0.2-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:7c36280e6fb8385e520936c3cb3b8042851904eba0e58d277dca80a5cfed590b", size = 719280 },
    { url = "https://files.pythonhosted.org/packages/6b/4e/1523cb902fd98355e2e9ea5e5eb237cbc5f3ad5f3075fa65087aa0ecb669/PyYAML-6.0.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:ec031d5d2feb36d1d1a24380e4db6d43695f3748343d99434e6f5f9156aaa2ed", size = 751239 },
    { url = "https://files.pythonhosted.org/packages/b7/33/5504b3a9a4464893c32f118a9cc045190a91637b119a9c881da1cf6b7a72/PyYAML-6.0.2-cp310-cp310-musllinux_1_1_aarch64.whl", hash = "sha256:936d68689298c36b53b29f23c6dbb74de12b4ac12ca6cfe0e047bedceea56180", size = 695802 },
    { url = "https://files.pythonhosted.org/packages/5c/20/8347dcabd41ef3a3cdc4f7b7a2aff3d06598c8779faa189cdbf878b626a4/PyYAML-6.0.2-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:23502f431948090f597378482b4812b0caae32c22213aecf3b55325e049a6c68", size = 720527 },
    { url = "https://files.pythonhosted.org/packages/be/aa/5afe99233fb360d0ff37377145a949ae258aaab831bde4792b32650a4378/PyYAML-6.0.2-cp310-cp310-win32.whl", hash = "sha256:2e99c6826ffa974fe6e27cdb5ed0021786b03fc98e5ee3c5bfe1fd5015f42b99", size = 144052 },
    { url = "https://files.pythonhosted.org/packages/b5/84/0fa4b06f6d6c958d207620fc60005e241ecedceee58931bb20138e1e5776/PyYAML-6.0.2-cp310-cp310-win_amd64.whl", hash = "sha256:a4d3091415f010369ae4ed1fc6b79def9416358877534caf6a0fdd2146c87a3e", size = 161774 },
    { url = "https://files.pythonhosted.org/packages/f8/aa/7af4e81f7acba21a4c6be026da38fd2b872ca46226673c89a758ebdc4fd2/PyYAML-6.0.2-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:cc1c1159b3d456576af7a3e4d1ba7e6924cb39de8f67111c735f6fc832082774", size = 184612 },
    { url = "https://files.pythonhosted.org/packages/8b/62/b9faa998fd185f65c1371643678e4d58254add437edb764a08c5a98fb986/PyYAML-6.0.2-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:1e2120ef853f59c7419231f3bf4e7021f1b936f6ebd222406c3b60212205d2ee", size = 172040 },
    { url = "https://files.pythonhosted.org/packages/ad/0c/c804f5f922a9a6563bab712d8dcc70251e8af811fce4524d57c2c0fd49a4/PyYAML-6.0.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:5d225db5a45f21e78dd9358e58a98702a0302f2659a3c6cd320564b75b86f47c", size = 736829 },
    { url = "https://files.pythonhosted.org/packages/51/16/6af8d6a6b210c8e54f1406a6b9481febf9c64a3109c541567e35a49aa2e7/PyYAML-6.0.2-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:5ac9328ec4831237bec75defaf839f7d4564be1e6b25ac710bd1a96321cc8317", size = 764167 },
    { url = "https://files.pythonhosted.org/packages/75/e4/2c27590dfc9992f73aabbeb9241ae20220bd9452df27483b6e56d3975cc5/PyYAML-6.0.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:3ad2a3decf9aaba3d29c8f537ac4b243e36bef957511b4766cb0057d32b0be85", size = 762952 },
    { url = "https://files.pythonhosted.org/packages/9b/97/ecc1abf4a823f5ac61941a9c00fe501b02ac3ab0e373c3857f7d4b83e2b6/PyYAML-6.0.2-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:ff3824dc5261f50c9b0dfb3be22b4567a6f938ccce4587b38952d85fd9e9afe4", size = 735301 },
    { url = "https://files.pythonhosted.org/packages/45/73/0f49dacd6e82c9430e46f4a027baa4ca205e8b0a9dce1397f44edc23559d/PyYAML-6.0.2-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:797b4f722ffa07cc8d62053e4cff1486fa6dc094105d13fea7b1de7d8bf71c9e", size = 756638 },
    { url = "https://files.pythonhosted.org/packages/22/5f/956f0f9fc65223a58fbc14459bf34b4cc48dec52e00535c79b8db361aabd/PyYAML-6.0.2-cp311-cp311-win32.whl", hash = "sha256:11d8f3dd2b9c1207dcaf2ee0bbbfd5991f571186ec9cc78427ba5bd32afae4b5", size = 143850 },
    { url = "https://files.pythonhosted.org/packages/ed/23/8da0bbe2ab9dcdd11f4f4557ccaf95c10b9811b13ecced089d43ce59c3c8/PyYAML-6.0.2-cp311-cp311-win_amd64.whl", hash = "sha256:e10ce637b18caea04431ce14fabcf5c64a1c61ec9c56b071a4b7ca131ca52d44", size = 161980 },
    { url = "https://files.pythonhosted.org/packages/86/0c/c581167fc46d6d6d7ddcfb8c843a4de25bdd27e4466938109ca68492292c/PyYAML-6.0.2-cp312-cp312-macosx_10_9_x86_64.whl", hash = "sha256:c70c95198c015b85feafc136515252a261a84561b7b1d51e3384e0655ddf25ab", size = 183873 },
    { url = "https://files.pythonhosted.org/packages/a8/0c/38374f5bb272c051e2a69281d71cba6fdb983413e6758b84482905e29a5d/PyYAML-6.0.2-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:ce826d6ef20b1bc864f0a68340c8b3287705cae2f8b4b1d932177dcc76721725", size = 173302 },
    { url = "https://files.pythonhosted.org/packages/c3/93/9916574aa8c00aa06bbac729972eb1071d002b8e158bd0e83a3b9a20a1f7/PyYAML-6.0.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:1f71ea527786de97d1a0cc0eacd1defc0985dcf6b3f17bb77dcfc8c34bec4dc5", size = 739154 },
    { url = "https://files.pythonhosted.org/packages/95/0f/b8938f1cbd09739c6da569d172531567dbcc9789e0029aa070856f123984/PyYAML-6.0.2-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:9b22676e8097e9e22e36d6b7bda33190d0d400f345f23d4065d48f4ca7ae0425", size = 766223 },
    { url = "https://files.pythonhosted.org/packages/b9/2b/614b4752f2e127db5cc206abc23a8c19678e92b23c3db30fc86ab731d3bd/PyYAML-6.0.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:80bab7bfc629882493af4aa31a4cfa43a4c57c83813253626916b8c7ada83476", size = 767542 },
    { url = "https://files.pythonhosted.org/packages/d4/00/dd137d5bcc7efea1836d6264f049359861cf548469d18da90cd8216cf05f/PyYAML-6.0.2-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:0833f8694549e586547b576dcfaba4a6b55b9e96098b36cdc7ebefe667dfed48", size = 731164 },
    { url = "https://files.pythonhosted.org/packages/c9/1f/4f998c900485e5c0ef43838363ba4a9723ac0ad73a9dc42068b12aaba4e4/PyYAML-6.0.2-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:8b9c7197f7cb2738065c481a0461e50ad02f18c78cd75775628afb4d7137fb3b", size = 756611 },
    { url = "https://files.pythonhosted.org/packages/df/d1/f5a275fdb252768b7a11ec63585bc38d0e87c9e05668a139fea92b80634c/PyYAML-6.0.2-cp312-cp312-win32.whl", hash = "sha256:ef6107725bd54b262d6dedcc2af448a266975032bc85ef0172c5f059da6325b4", size = 140591 },
    { url = "https://files.pythonhosted.org/packages/0c/e8/4f648c598b17c3d06e8753d7d13d57542b30d56e6c2dedf9c331ae56312e/PyYAML-6.0.2-cp312-cp312-win_amd64.whl", hash = "sha256:7e7401d0de89a9a855c839bc697c079a4af81cf878373abd7dc625847d25cbd8", size = 156338 },
    { url = "https://files.pythonhosted.org/packages/ef/e3/3af305b830494fa85d95f6d95ef7fa73f2ee1cc8ef5b495c7c3269fb835f/PyYAML-6.0.2-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:efdca5630322a10774e8e98e1af481aad470dd62c3170801852d752aa7a783ba", size = 181309 },
    { url = "https://files.pythonhosted.org/packages/45/9f/3b1c20a0b7a3200524eb0076cc027a970d320bd3a6592873c85c92a08731/PyYAML-6.0.2-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:50187695423ffe49e2deacb8cd10510bc361faac997de9efef88badc3bb9e2d1", size = 171679 },
    { url = "https://files.pythonhosted.org/packages/7c/9a/337322f27005c33bcb656c655fa78325b730324c78620e8328ae28b64d0c/PyYAML-6.0.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:0ffe8360bab4910ef1b9e87fb812d8bc0a308b0d0eef8c8f44e0254ab3b07133", size = 733428 },
    { url = "https://files.pythonhosted.org/packages/a3/69/864fbe19e6c18ea3cc196cbe5d392175b4cf3d5d0ac1403ec3f2d237ebb5/PyYAML-6.0.2-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:17e311b6c678207928d649faa7cb0d7b4c26a0ba73d41e99c4fff6b6c3276484", size = 763361 },
    { url = "https://files.pythonhosted.org/packages/04/24/b7721e4845c2f162d26f50521b825fb061bc0a5afcf9a386840f23ea19fa/PyYAML-6.0.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:70b189594dbe54f75ab3a1acec5f1e3faa7e8cf2f1e08d9b561cb41b845f69d5", size = 759523 },
    { url = "https://files.pythonhosted.org/packages/2b/b2/e3234f59ba06559c6ff63c4e10baea10e5e7df868092bf9ab40e5b9c56b6/PyYAML-6.0.2-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:41e4e3953a79407c794916fa277a82531dd93aad34e29c2a514c2c0c5fe971cc", size = 726660 },
    { url = "https://files.pythonhosted.org/packages/fe/0f/25911a9f080464c59fab9027482f822b86bf0608957a5fcc6eaac85aa515/PyYAML-6.0.2-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:68ccc6023a3400877818152ad9a1033e3db8625d899c72eacb5a668902e4d652", size = 751597 },
    { url = "https://files.pythonhosted.org/packages/14/0d/e2c3b43bbce3cf6bd97c840b46088a3031085179e596d4929729d8d68270/PyYAML-6.0.2-cp313-cp313-win32.whl", hash = "sha256:bc2fa7c6b47d6bc618dd7fb02ef6fdedb1090ec036abab80d4681424b84c1183", size = 140527 },
    { url = "https://files.pythonhosted.org/packages/fa/de/02b54f42487e3d3c6efb3f89428677074ca7bf43aae402517bc7cca949f3/PyYAML-6.0.2-cp313-cp313-win_amd64.whl", hash = "sha256:8388ee1976c416731879ac16da0aff3f63b286ffdd57cdeb95f3f2e085687563", size = 156446 },
    { url = "https://files.pythonhosted.org/packages/65/d8/b7a1db13636d7fb7d4ff431593c510c8b8fca920ade06ca8ef20015493c5/PyYAML-6.0.2-cp39-cp39-macosx_10_9_x86_64.whl", hash = "sha256:688ba32a1cffef67fd2e9398a2efebaea461578b0923624778664cc1c914db5d", size = 184777 },
    { url = "https://files.pythonhosted.org/packages/0a/02/6ec546cd45143fdf9840b2c6be8d875116a64076218b61d68e12548e5839/PyYAML-6.0.2-cp39-cp39-macosx_11_0_arm64.whl", hash = "sha256:a8786accb172bd8afb8be14490a16625cbc387036876ab6ba70912730faf8e1f", size = 172318 },
    { url = "https://files.pythonhosted.org/packages/0e/9a/8cc68be846c972bda34f6c2a93abb644fb2476f4dcc924d52175786932c9/PyYAML-6.0.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:d8e03406cac8513435335dbab54c0d385e4a49e4945d2909a581c83647ca0290", size = 720891 },
    { url = "https://files.pythonhosted.org/packages/e9/6c/6e1b7f40181bc4805e2e07f4abc10a88ce4648e7e95ff1abe4ae4014a9b2/PyYAML-6.0.2-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:f753120cb8181e736c57ef7636e83f31b9c0d1722c516f7e86cf15b7aa57ff12", size = 722614 },
    { url = "https://files.pythonhosted.org/packages/3d/32/e7bd8535d22ea2874cef6a81021ba019474ace0d13a4819c2a4bce79bd6a/PyYAML-6.0.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:3b1fdb9dc17f5a7677423d508ab4f243a726dea51fa5e70992e59a7411c89d19", size = 737360 },
    { url = "https://files.pythonhosted.org/packages/d7/12/7322c1e30b9be969670b672573d45479edef72c9a0deac3bb2868f5d7469/PyYAML-6.0.2-cp39-cp39-musllinux_1_1_aarch64.whl", hash = "sha256:0b69e4ce7a131fe56b7e4d770c67429700908fc0752af059838b1cfb41960e4e", size = 699006 },
    { url = "https://files.pythonhosted.org/packages/82/72/04fcad41ca56491995076630c3ec1e834be241664c0c09a64c9a2589b507/PyYAML-6.0.2-cp39-cp39-musllinux_1_1_x86_64.whl", hash = "sha256:a9f8c2e67970f13b16084e04f134610fd1d374bf477b17ec1599185cf611d725", size = 723577 },
    { url = "https://files.pythonhosted.org/packages/ed/5e/46168b1f2757f1fcd442bc3029cd8767d88a98c9c05770d8b420948743bb/PyYAML-6.0.2-cp39-cp39-win32.whl", hash = "sha256:6395c297d42274772abc367baaa79683958044e5d3835486c16da75d2a694631", size = 144593 },
    { url = "https://files.pythonhosted.org/packages/19/87/5124b1c1f2412bb95c59ec481eaf936cd32f0fe2a7b16b97b81c4c017a6a/PyYAML-6.0.2-cp39-cp39-win_amd64.whl", hash = "sha256:39693e1f8320ae4f43943590b49779ffb98acb81f788220ea932a6b6c51004d8", size = 162312 },
]

[[package]]
name = "simpy"
version = "4.1.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a8/66/860505ec021a16f9d8cf4b8c4d60ee07bb427649b643312303698c93b551/simpy-4.1.1.tar.gz", hash = "sha256:06d0750a7884b11e0e8e20ce0bc7c6d4ed5f1743d456695340d13fdff95001a6", size = 408997 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/48/72/920ed1224c94a8a5a69e6c1275ac7fe4eb911ba8feffddf469f1629d47f3/simpy-4.1.1-py3-none-any.whl", hash = "sha256:7c5ae380240fd2238671160e4830956f8055830a8317edf5c05e495b3823cd88", size = 27224 },
]

[[package]]
name = "supcon-adventurex-factory-sim"
version = "1.0.0"
source = { editable = "." }
dependencies = [
    { name = "numpy", version = "2.0.2", source = { registry = "https://pypi.org/simple" }, marker = "python_full_version < '3.10'" },
    { name = "numpy", version = "2.2.6", source = { registry = "https://pypi.org/simple" }, marker = "python_full_version == '3.10.*'" },
    { name = "numpy", version = "2.3.1", source = { registry = "https://pypi.org/simple" }, marker = "python_full_version >= '3.11'" },
    { name = "paho-mqtt" },
    { name = "psutil" },
    { name = "pydantic" },
    { name = "pyyaml" },
    { name = "simpy" },
]

[package.dev-dependencies]
dev = [
    { name = "pytest" },
]

[package.metadata]
requires-dist = [
    { name = "numpy" },
    { name = "paho-mqtt" },
    { name = "psutil" },
    { name = "pydantic" },
    { name = "pyyaml" },
    { name = "simpy" },
]

[package.metadata.requires-dev]
dev = [{ name = "pytest" }]

[[package]]
name = "tomli"
version = "2.2.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/18/87/302344fed471e44a87289cf4967697d07e532f2421fdaf868a303cbae4ff/tomli-2.2.1.tar.gz", hash = "sha256:cd45e1dc79c835ce60f7404ec8119f2eb06d38b1deba146f07ced3bbc44505ff", size = 17175 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/43/ca/75707e6efa2b37c77dadb324ae7d9571cb424e61ea73fad7c56c2d14527f/tomli-2.2.1-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:678e4fa69e4575eb77d103de3df8a895e1591b48e740211bd1067378c69e8249", size = 131077 },
    { url = "https://files.pythonhosted.org/packages/c7/16/51ae563a8615d472fdbffc43a3f3d46588c264ac4f024f63f01283becfbb/tomli-2.2.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:023aa114dd824ade0100497eb2318602af309e5a55595f76b626d6d9f3b7b0a6", size = 123429 },
    { url = "https://files.pythonhosted.org/packages/f1/dd/4f6cd1e7b160041db83c694abc78e100473c15d54620083dbd5aae7b990e/tomli-2.2.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:ece47d672db52ac607a3d9599a9d48dcb2f2f735c6c2d1f34130085bb12b112a", size = 226067 },
    { url = "https://files.pythonhosted.org/packages/a9/6b/c54ede5dc70d648cc6361eaf429304b02f2871a345bbdd51e993d6cdf550/tomli-2.2.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:6972ca9c9cc9f0acaa56a8ca1ff51e7af152a9f87fb64623e31d5c83700080ee", size = 236030 },
    { url = "https://files.pythonhosted.org/packages/1f/47/999514fa49cfaf7a92c805a86c3c43f4215621855d151b61c602abb38091/tomli-2.2.1-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:c954d2250168d28797dd4e3ac5cf812a406cd5a92674ee4c8f123c889786aa8e", size = 240898 },
    { url = "https://files.pythonhosted.org/packages/73/41/0a01279a7ae09ee1573b423318e7934674ce06eb33f50936655071d81a24/tomli-2.2.1-cp311-cp311-musllinux_1_2_aarch64.whl", hash = "sha256:8dd28b3e155b80f4d54beb40a441d366adcfe740969820caf156c019fb5c7ec4", size = 229894 },
    { url = "https://files.pythonhosted.org/packages/55/18/5d8bc5b0a0362311ce4d18830a5d28943667599a60d20118074ea1b01bb7/tomli-2.2.1-cp311-cp311-musllinux_1_2_i686.whl", hash = "sha256:e59e304978767a54663af13c07b3d1af22ddee3bb2fb0618ca1593e4f593a106", size = 245319 },
    { url = "https://files.pythonhosted.org/packages/92/a3/7ade0576d17f3cdf5ff44d61390d4b3febb8a9fc2b480c75c47ea048c646/tomli-2.2.1-cp311-cp311-musllinux_1_2_x86_64.whl", hash = "sha256:33580bccab0338d00994d7f16f4c4ec25b776af3ffaac1ed74e0b3fc95e885a8", size = 238273 },
    { url = "https://files.pythonhosted.org/packages/72/6f/fa64ef058ac1446a1e51110c375339b3ec6be245af9d14c87c4a6412dd32/tomli-2.2.1-cp311-cp311-win32.whl", hash = "sha256:465af0e0875402f1d226519c9904f37254b3045fc5084697cefb9bdde1ff99ff", size = 98310 },
    { url = "https://files.pythonhosted.org/packages/6a/1c/4a2dcde4a51b81be3530565e92eda625d94dafb46dbeb15069df4caffc34/tomli-2.2.1-cp311-cp311-win_amd64.whl", hash = "sha256:2d0f2fdd22b02c6d81637a3c95f8cd77f995846af7414c5c4b8d0545afa1bc4b", size = 108309 },
    { url = "https://files.pythonhosted.org/packages/52/e1/f8af4c2fcde17500422858155aeb0d7e93477a0d59a98e56cbfe75070fd0/tomli-2.2.1-cp312-cp312-macosx_10_13_x86_64.whl", hash = "sha256:4a8f6e44de52d5e6c657c9fe83b562f5f4256d8ebbfe4ff922c495620a7f6cea", size = 132762 },
    { url = "https://files.pythonhosted.org/packages/03/b8/152c68bb84fc00396b83e7bbddd5ec0bd3dd409db4195e2a9b3e398ad2e3/tomli-2.2.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:8d57ca8095a641b8237d5b079147646153d22552f1c637fd3ba7f4b0b29167a8", size = 123453 },
    { url = "https://files.pythonhosted.org/packages/c8/d6/fc9267af9166f79ac528ff7e8c55c8181ded34eb4b0e93daa767b8841573/tomli-2.2.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:4e340144ad7ae1533cb897d406382b4b6fede8890a03738ff1683af800d54192", size = 233486 },
    { url = "https://files.pythonhosted.org/packages/5c/51/51c3f2884d7bab89af25f678447ea7d297b53b5a3b5730a7cb2ef6069f07/tomli-2.2.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:db2b95f9de79181805df90bedc5a5ab4c165e6ec3fe99f970d0e302f384ad222", size = 242349 },
    { url = "https://files.pythonhosted.org/packages/ab/df/bfa89627d13a5cc22402e441e8a931ef2108403db390ff3345c05253935e/tomli-2.2.1-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:40741994320b232529c802f8bc86da4e1aa9f413db394617b9a256ae0f9a7f77", size = 252159 },
    { url = "https://files.pythonhosted.org/packages/9e/6e/fa2b916dced65763a5168c6ccb91066f7639bdc88b48adda990db10c8c0b/tomli-2.2.1-cp312-cp312-musllinux_1_2_aarch64.whl", hash = "sha256:400e720fe168c0f8521520190686ef8ef033fb19fc493da09779e592861b78c6", size = 237243 },
    { url = "https://files.pythonhosted.org/packages/b4/04/885d3b1f650e1153cbb93a6a9782c58a972b94ea4483ae4ac5cedd5e4a09/tomli-2.2.1-cp312-cp312-musllinux_1_2_i686.whl", hash = "sha256:02abe224de6ae62c19f090f68da4e27b10af2b93213d36cf44e6e1c5abd19fdd", size = 259645 },
    { url = "https://files.pythonhosted.org/packages/9c/de/6b432d66e986e501586da298e28ebeefd3edc2c780f3ad73d22566034239/tomli-2.2.1-cp312-cp312-musllinux_1_2_x86_64.whl", hash = "sha256:b82ebccc8c8a36f2094e969560a1b836758481f3dc360ce9a3277c65f374285e", size = 244584 },
    { url = "https://files.pythonhosted.org/packages/1c/9a/47c0449b98e6e7d1be6cbac02f93dd79003234ddc4aaab6ba07a9a7482e2/tomli-2.2.1-cp312-cp312-win32.whl", hash = "sha256:889f80ef92701b9dbb224e49ec87c645ce5df3fa2cc548664eb8a25e03127a98", size = 98875 },
    { url = "https://files.pythonhosted.org/packages/ef/60/9b9638f081c6f1261e2688bd487625cd1e660d0a85bd469e91d8db969734/tomli-2.2.1-cp312-cp312-win_amd64.whl", hash = "sha256:7fc04e92e1d624a4a63c76474610238576942d6b8950a2d7f908a340494e67e4", size = 109418 },
    { url = "https://files.pythonhosted.org/packages/04/90/2ee5f2e0362cb8a0b6499dc44f4d7d48f8fff06d28ba46e6f1eaa61a1388/tomli-2.2.1-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:f4039b9cbc3048b2416cc57ab3bda989a6fcf9b36cf8937f01a6e731b64f80d7", size = 132708 },
    { url = "https://files.pythonhosted.org/packages/c0/ec/46b4108816de6b385141f082ba99e315501ccd0a2ea23db4a100dd3990ea/tomli-2.2.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:286f0ca2ffeeb5b9bd4fcc8d6c330534323ec51b2f52da063b11c502da16f30c", size = 123582 },
    { url = "https://files.pythonhosted.org/packages/a0/bd/b470466d0137b37b68d24556c38a0cc819e8febe392d5b199dcd7f578365/tomli-2.2.1-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a92ef1a44547e894e2a17d24e7557a5e85a9e1d0048b0b5e7541f76c5032cb13", size = 232543 },
    { url = "https://files.pythonhosted.org/packages/d9/e5/82e80ff3b751373f7cead2815bcbe2d51c895b3c990686741a8e56ec42ab/tomli-2.2.1-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:9316dc65bed1684c9a98ee68759ceaed29d229e985297003e494aa825ebb0281", size = 241691 },
    { url = "https://files.pythonhosted.org/packages/05/7e/2a110bc2713557d6a1bfb06af23dd01e7dde52b6ee7dadc589868f9abfac/tomli-2.2.1-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:e85e99945e688e32d5a35c1ff38ed0b3f41f43fad8df0bdf79f72b2ba7bc5272", size = 251170 },
    { url = "https://files.pythonhosted.org/packages/64/7b/22d713946efe00e0adbcdfd6d1aa119ae03fd0b60ebed51ebb3fa9f5a2e5/tomli-2.2.1-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:ac065718db92ca818f8d6141b5f66369833d4a80a9d74435a268c52bdfa73140", size = 236530 },
    { url = "https://files.pythonhosted.org/packages/38/31/3a76f67da4b0cf37b742ca76beaf819dca0ebef26d78fc794a576e08accf/tomli-2.2.1-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:d920f33822747519673ee656a4b6ac33e382eca9d331c87770faa3eef562aeb2", size = 258666 },
    { url = "https://files.pythonhosted.org/packages/07/10/5af1293da642aded87e8a988753945d0cf7e00a9452d3911dd3bb354c9e2/tomli-2.2.1-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:a198f10c4d1b1375d7687bc25294306e551bf1abfa4eace6650070a5c1ae2744", size = 243954 },
    { url = "https://files.pythonhosted.org/packages/5b/b9/1ed31d167be802da0fc95020d04cd27b7d7065cc6fbefdd2f9186f60d7bd/tomli-2.2.1-cp313-cp313-win32.whl", hash = "sha256:d3f5614314d758649ab2ab3a62d4f2004c825922f9e370b29416484086b264ec", size = 98724 },
    { url = "https://files.pythonhosted.org/packages/c7/32/b0963458706accd9afcfeb867c0f9175a741bf7b19cd424230714d722198/tomli-2.2.1-cp313-cp313-win_amd64.whl", hash = "sha256:a38aa0308e754b0e3c67e344754dff64999ff9b513e691d0e786265c93583c69", size = 109383 },
    { url = "https://files.pythonhosted.org/packages/6e/c2/61d3e0f47e2b74ef40a68b9e6ad5984f6241a942f7cd3bbfbdbd03861ea9/tomli-2.2.1-py3-none-any.whl", hash = "sha256:cb55c73c5f4408779d0cf3eef9f762b9c9f147a77de7b258bef0a5628adc85cc", size = 14257 },
]

[[package]]
name = "typing-extensions"
version = "4.14.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d1/bc/51647cd02527e87d05cb083ccc402f93e441606ff1f01739a62c8ad09ba5/typing_extensions-4.14.0.tar.gz", hash = "sha256:8676b788e32f02ab42d9e7c61324048ae4c6d844a399eebace3d4979d75ceef4", size = 107423 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/69/e0/552843e0d356fbb5256d21449fa957fa4eff3bbc135a74a691ee70c7c5da/typing_extensions-4.14.0-py3-none-any.whl", hash = "sha256:a1514509136dd0b477638fc68d6a91497af5076466ad0fa6c338e44e359944af", size = 43839 },
]

[[package]]
name = "typing-inspection"
version = "0.4.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/f8/b1/0c11f5058406b3af7609f121aaa6b609744687f1d158b3c3a5bf4cc94238/typing_inspection-0.4.1.tar.gz", hash = "sha256:6ae134cc0203c33377d43188d4064e9b357dba58cff3185f22924610e70a9d28", size = 75726 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/17/69/cd203477f944c353c31bade965f880aa1061fd6bf05ded0726ca845b6ff7/typing_inspection-0.4.1-py3-none-any.whl", hash = "sha256:389055682238f53b04f7badcb49b989835495a96700ced5dab2d8feae4b26f51", size = 14552 },
]



================================================
File: .python-version
================================================
3.11



================================================
File: config/factory_layout.yml
================================================
# SUPCON Factory Layout Configuration
# This file defines the physical layout and parameters of the factory simulation

factory:
  name: "SUPCON AdventureX NLDF"
  description: "Ëá™ÁÑ∂ËØ≠Ë®ÄÈ©±Âä®Êô∫ËÉΩÂà∂ÈÄ†‰ªøÁúüÂ∑•ÂéÇ"

# Â∑•Á´ôÈÖçÁΩÆ
stations:
  - id: "StationA"
    # name: "ÁªÑË£ÖÂ∑•Á´ô"
    position: [15, 20]
    buffer_size: 3
    processing_times: # ‰∫ßÂìÅÁ±ªÂûã: [ÊúÄÂ∞èÊó∂Èó¥, ÊúÄÂ§ßÊó∂Èó¥] (Áßí)
      P1: [5, 5] #[30, 45]
      P2: [5, 5] #[40, 60]
      P3: [5, 5] #[35, 50]
    interacting_points: [P1]

  - id: "StationB"
    # name: "ÁÑäÊé•Â∑•Á´ô"
    position: [35, 20]
    buffer_size: 3
    processing_times:
      P1: [5, 5] #[45, 60]
      P2: [5, 5] #[60, 80]
      P3: [5, 5] #[50, 70]
    interacting_points: [P3]

  - id: "StationC"
    # name: "ÊµãËØïÂ∑•Á´ô"
    position: [55, 20]
    buffer_size: 3
    processing_times:
      P1: [5, 5] #[20, 30]
      P2: [5, 5] #[30, 40]
      P3: [5, 5] #[25, 35]
    interacting_points: [P5]

  - id: "QualityCheck"
    # name: "Ë¥®ÈáèÊ£ÄÊµãÁ´ô"
    position: [75, 20]
    buffer_size: 1
    processing_times:
      P1: [5, 5] #[15, 25]
      P2: [5, 5] #[20, 30]
      P3: [5, 5] #[20, 30]
    output_buffer_capacity: 4
    interacting_points: [P7, P8]

# AGVÈÖçÁΩÆ
agvs:
  - id: "AGV_1"
    position: [10, 10] # initial position
    path_points:
      P0: [5, 15] # raw material warehouse
      P1: [12, 15] # StationA
      P2: [25, 15] # Conveyor_AB
      P3: [32, 15] # StationB
      P4: [45, 15] # Conveyor_BC
      P5: [52, 15] # StationC
      P6: [65, 10] # Conveyor_CQ_lower
      P7: [72, 15] # QualityChecker
      P8: [80, 15] # QualityChecker_output
      P9: [95, 15] # Warehouse
      P10: [10, 10] # Charging Area
    speed_mps: 2.0 # ÁßªÂä®ÈÄüÂ∫¶ (Á±≥/Áßí)
    payload_capacity: 2 # ÊúÄÂ§ßËΩΩË¥ßÊï∞Èáè
    low_battery_threshold: 5.0 # ‰ΩéÁîµÈáèÈòàÂÄº
    charging_point: P10 # ÂÖÖÁîµÁÇπÂùêÊ†á
    charging_speed: 3.33 # ÂÖÖÁîµÈÄüÂ∫¶(30ÁßíÂÖÖÊª°)
    battery_consumption_per_meter: 0.1 # ÊØèÁ±≥Ê∂àËÄó0.1%ÁîµÈáè
    battery_consumption_per_action: 0.5 # ÊØèÊ¨°Êìç‰ΩúÊ∂àËÄó0.5%ÁîµÈáè

  - id: "AGV_2"
    position: [10, 30]
    path_points:
      P0: [5, 25]
      P1: [12, 25]
      P2: [25, 25]
      P3: [32, 25]
      P4: [45, 25]
      P5: [52, 25]
      P6: [65, 25]
      P7: [72, 25]
      P8: [80, 25]
      P9: [95, 25]
      P10: [10, 30]
    speed_mps: 2.0
    payload_capacity: 2
    low_battery_threshold: 5.0
    charging_point: P10
    charging_speed: 3.33
    battery_consumption_per_meter: 0.1
    battery_consumption_per_action: 0.5

conveyors:
  - id: "Conveyor_AB"
    position: [25, 20]
    transfer_time: 5.0
    capacity: 3
    interacting_points: [P2]

  - id: "Conveyor_BC"
    position: [45, 20]
    transfer_time: 5.0
    capacity: 3
    interacting_points: [P4]

  - id: "Conveyor_CQ"
    position: [65, 20]
    transfer_time: 5.0
    main_capacity: 4
    upper_capacity: 2
    lower_capacity: 2
    interacting_points: [P6]

warehouses:
  - id: "RawMaterial"
    position: [0, 20]
    interacting_points: [P0]

  - id: "Warehouse"
    position: [95, 20]
    interacting_points: [P9]

# ËÆ¢ÂçïÁîüÊàêÂô®ÈÖçÁΩÆ
order_generator:
  generation_interval_range: [10, 10] # ÊúÄÂ∞è/ÊúÄÂ§ßÈó¥Èöî (Áßí)
  quantity_weights:
    1: 0.40
    2: 0.30
    3: 0.20
    4: 0.07
    5: 0.03
  product_distribution:
    P1: 0.60
    P2: 0.30
    P3: 0.10
  priority_distribution:
    low: 0.70
    medium: 0.25
    high: 0.05
  deadline_multipliers:
    low: 3.0
    medium: 2.0
    high: 1.5
  theoretical_production_times:
    P1: 160
    P2: 200
    P3: 250

# ÊïÖÈöúÁ≥ªÁªüÂèÇÊï∞
fault_system:
  fault_injection_interval: [120, 180] # ÊïÖÈöúÊ≥®ÂÖ•Èó¥Èöî (2-3ÂàÜÈíü)
  auto_recovery_time: [600, 1800] # Ëá™Âä®ÊÅ¢Â§çÊó∂Èó¥ (10-30ÂàÜÈíü)
  device_relationships:
    StationA: ["StationB", "AGV_1"]
    StationB: ["StationA", "StationC", "AGV_1", "AGV_2"]
    StationC: ["StationB", "QualityCheck", "AGV_2"]
    QualityCheck: ["StationC"]
    AGV_1: ["StationA", "StationB"]
    AGV_2: ["StationB", "StationC"]

# KPIËÆ°ÁÆóÊùÉÈáç
kpi_weights:
  production_efficiency: 0.40 # Áîü‰∫ßÊïàÁéá 40%
  quality_cost: 0.30 # Ë¥®Èáè‰∏éÊàêÊú¨ 30%
  agv_efficiency: 0.30 # AGVÊìçÊéßÊïàÁéá 30%
  
  # Áîü‰∫ßÊïàÁéáÂ≠êÊùÉÈáç (ÊÄªÂíåÂ∫î‰∏∫1.0)
  efficiency_components:
    order_completion: 0.40    # ËÆ¢ÂçïÂÆåÊàêÁéáÊùÉÈáç
    production_cycle: 0.40    # Áîü‰∫ßÂë®ÊúüÊïàÁéáÊùÉÈáç
    device_utilization: 0.20  # ËÆæÂ§áÂà©Áî®ÁéáÊùÉÈáç
  
  # Ë¥®ÈáèÊàêÊú¨Â≠êÊùÉÈáç (ÊÄªÂíåÂ∫î‰∏∫1.0)
  quality_cost_components:
    first_pass_rate: 0.40     # ‰∏ÄÊ¨°ÈÄöËøáÁéáÊùÉÈáç
    cost_efficiency: 0.60     # ÊàêÊú¨ÊïàÁéáÊùÉÈáç
  
  # AGVÊïàÁéáÂ≠êÊùÉÈáç (ÊÄªÂíåÂ∫î‰∏∫1.0)
  agv_components:
    charge_strategy: 0.30     # ÂÖÖÁîµÁ≠ñÁï•ÊïàÁéáÊùÉÈáç
    energy_efficiency: 0.40   # ËÉΩÊïàÊØîÊùÉÈáç
    utilization: 0.30         # AGVÂà©Áî®ÁéáÊùÉÈáç

# KPIÊàêÊú¨ÂèÇÊï∞
kpi_costs:
  material_cost_per_product:
    P1: 10.0
    P2: 15.0
    P3: 20.0
  energy_cost_per_second: 0.2
  energy_cost_multiplier_peak: 1.5
  maintenance_cost_base: 8.0  # ~25% of average product cost, ~80s of energy cost
  scrap_cost_multiplier: 0.8

# Á≥ªÁªüÊÄßËÉΩÂèÇÊï∞
system:
  status_publish_interval: 10.0 # Áä∂ÊÄÅÂèëÂ∏ÉÈó¥Èöî (Áßí)
  simulation_step_size: 0.1 # ‰ªøÁúüÊ≠•Èïø (Áßí)
  max_concurrent_orders: 20 # ÊúÄÂ§ßÂπ∂ÂèëËÆ¢ÂçïÊï∞



================================================
File: config/factory_layout_multi.yml
================================================
# SUPCON Factory Layout Configuration for Multiple Lines
# This file defines the physical layout and parameters of the factory simulation

factory:
  name: "SUPCON AdventureX NLDF"
  description: "Ëá™ÁÑ∂ËØ≠Ë®ÄÈ©±Âä®Êô∫ËÉΩÂà∂ÈÄ†‰ªøÁúüÂ∑•ÂéÇ"

# # Á≥ªÁªüÊÄßËÉΩÂèÇÊï∞ (Global)
# system:
#   status_publish_interval: 10.0  # Áä∂ÊÄÅÂèëÂ∏ÉÈó¥Èöî (Áßí)
#   simulation_step_size: 0.1      # ‰ªøÁúüÊ≠•Èïø (Áßí)
#   max_concurrent_orders: 20      # ÊúÄÂ§ßÂπ∂ÂèëËÆ¢ÂçïÊï∞

warehouses:
  - id: "RawMaterial"
    position: [0, 20]
    interacting_points: [P0]
  - id: "Warehouse"
    position: [95, 20]
    interacting_points: [P9]

order_generator:
  generation_interval_range: [10, 10]
  quantity_weights: {1: 0.4, 2: 0.3, 3: 0.2, 4: 0.07, 5: 0.03}
  product_distribution: {P1: 0.6, P2: 0.3, P3: 0.1}
  priority_distribution: {low: 0.7, medium: 0.25, high: 0.05}
  deadline_multipliers: {low: 3.0, medium: 2.0, high: 1.5}
  theoretical_production_times: {P1: 160, P2: 200, P3: 250}

production_lines:
  - name: "line1"
    stations:
      - id: "StationA"
        position: [15, 20]
        buffer_size: 2
        processing_times:
          P1: [5, 5]
          P2: [5, 5]
          P3: [5, 5]
        interacting_points: [P1]

      - id: "StationB"
        position: [35, 20]
        buffer_size: 2
        processing_times:
          P1: [5, 5]
          P2: [5, 5]
          P3: [5, 5]
        interacting_points: [P3]

      - id: "StationC"
        position: [55, 20]
        buffer_size: 2
        processing_times:
          P1: [5, 5]
          P2: [5, 5]
          P3: [5, 5]
        interacting_points: [P5]

      - id: "QualityCheck"
        position: [75, 20]
        buffer_size: 2
        processing_times:
          P1: [5, 5]
          P2: [5, 5]
          P3: [5, 5]
        output_buffer_capacity: 4
        interacting_points: [P7, P8]
        # pass_threshold: 99
        # scrap_threshold: 98
        
    agvs:
      - id: "AGV_1"
        position: [10, 10]
        path_points:
          P0: [5, 15]
          P1: [12, 15]
          P2: [25, 15]
          P3: [32, 15]
          P4: [45, 15]
          P5: [52, 15]
          P6: [65, 10]
          P7: [72, 15]
          P8: [80, 15]
          P9: [95, 15]
          P10: [10, 10]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.1
        battery_consumption_per_action: 0.5
      - id: "AGV_2"
        position: [10, 30]
        path_points:
          P0: [5, 25]
          P1: [12, 25]
          P2: [25, 25]
          P3: [32, 25]
          P4: [45, 25]
          P5: [52, 25]
          P6: [65, 25]
          P7: [72, 25]
          P8: [80, 25]
          P9: [95, 25]
          P10: [10, 30]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.5
        battery_consumption_per_action: 0.5
    agv_operations:
      AGV_1:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "lower", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
      AGV_2:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "upper", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
    conveyors:
      - id: "Conveyor_AB"
        position: [25, 20]
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P2]
      - id: "Conveyor_BC"
        position: [45, 20]
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P4]
      - id: "Conveyor_CQ"
        position: [65, 20]
        transfer_time: 5.0
        main_capacity: 4
        upper_capacity: 2
        lower_capacity: 2
        interacting_points: [P6]

    fault_system:
      fault_injection_interval: [120, 180]
      auto_recovery_time: [600, 1800]
      device_relationships:
        StationA: ["StationB", "AGV_1"]
        StationB: ["StationA", "StationC", "AGV_1", "AGV_2"]
        StationC: ["StationB", "QualityCheck", "AGV_2"]
        QualityCheck: ["StationC"]
        AGV_1: ["StationA", "StationB"]
        AGV_2: ["StationB", "StationC"]

  - name: "line2"
    stations:
      - id: "StationA"
        position: [15, 60] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P1]
      - id: "StationB"
        position: [35, 60] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P3]
      - id: "StationC"
        position: [55, 60] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P5]
      - id: "QualityCheck"
        position: [75, 60] # Changed Y coordinate
        buffer_size: 1
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        output_buffer_capacity: 4
        interacting_points: [P7, P8]
    agvs:
      - id: "AGV_1"
        position: [10, 50] # Changed Y coordinate
        path_points:
          P0: [5, 55]
          P1: [12, 55]
          P2: [25, 55]
          P3: [32, 55]
          P4: [45, 55]
          P5: [52, 55]
          P6: [65, 50]
          P7: [72, 55]
          P8: [80, 55]
          P9: [95, 55]
          P10: [10, 50]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.1
        battery_consumption_per_action: 0.5
      - id: "AGV_2"
        position: [10, 70] # Changed Y coordinate
        path_points:
          P0: [5, 65]
          P1: [12, 65]
          P2: [25, 65]
          P3: [32, 65]
          P4: [45, 65]
          P5: [52, 65]
          P6: [65, 65]
          P7: [72, 65]
          P8: [80, 65]
          P9: [95, 65]
          P10: [10, 70]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.1
        battery_consumption_per_action: 0.5
    agv_operations:
      AGV_1:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "lower", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
      AGV_2:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "upper", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
    conveyors:
      - id: "Conveyor_AB"
        position: [25, 60] # Changed Y coordinate
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P2]
      - id: "Conveyor_BC"
        position: [45, 60] # Changed Y coordinate
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P4]
      - id: "Conveyor_CQ"
        position: [65, 60] # Changed Y coordinate
        transfer_time: 5.0
        main_capacity: 4
        upper_capacity: 2
        lower_capacity: 2
        interacting_points: [P6]
    fault_system:
      fault_injection_interval: [120, 180]
      auto_recovery_time: [600, 1800]
      device_relationships:
        StationA: ["StationB", "AGV_1"]
        StationB: ["StationA", "StationC", "AGV_1", "AGV_2"]
        StationC: ["StationB", "QualityCheck", "AGV_2"]
        QualityCheck: ["StationC"]
        AGV_1: ["StationA", "StationB"]
        AGV_2: ["StationB", "StationC"]

  - name: "line3"
    stations:
      - id: "StationA"
        position: [15, 100] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P1]
      - id: "StationB"
        position: [35, 100] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P3]
      - id: "StationC"
        position: [55, 100] # Changed Y coordinate
        buffer_size: 3
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        interacting_points: [P5]
      - id: "QualityCheck"
        position: [75, 100] # Changed Y coordinate
        buffer_size: 1
        processing_times: {P1: [5, 5], P2: [5, 5], P3: [5, 5]}
        output_buffer_capacity: 4
        interacting_points: [P7, P8]
    agvs:
      - id: "AGV_1"
        position: [10, 90] # Changed Y coordinate
        path_points:
          P0: [5, 95]
          P1: [12, 95]
          P2: [25, 95]
          P3: [32, 95]
          P4: [45, 95]
          P5: [52, 95]
          P6: [65, 90]
          P7: [72, 95]
          P8: [80, 95]
          P9: [95, 95]
          P10: [10, 90]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.1
        battery_consumption_per_action: 0.5
      - id: "AGV_2"
        position: [10, 110] # Changed Y coordinate
        path_points:
          P0: [5, 105]
          P1: [12, 105]
          P2: [25, 105]
          P3: [32, 105]
          P4: [45, 105]
          P5: [52, 105]
          P6: [65, 105]
          P7: [72, 105]
          P8: [80, 105]
          P9: [95, 105]
          P10: [10, 110]
        speed_mps: 2.0
        battery_level: 50.0
        payload_capacity: 2
        low_battery_threshold: 10.0
        charging_point: P10
        charging_speed: 3.33
        battery_consumption_per_meter: 0.1
        battery_consumption_per_action: 0.5
    agv_operations:
      AGV_1:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "lower", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
      AGV_2:
        P0: {device: "RawMaterial", operations: ["load"]}
        P1: {device: "StationA", operations: ["unload", "load"]}
        P2: {device: "Conveyor_AB", operations: ["load"]}
        P3: {device: "StationB", operations: ["unload", "load"]}
        P4: {device: "Conveyor_BC", operations: ["load"]}
        P5: {device: "StationC", operations: ["unload", "load"]}
        P6: {device: "Conveyor_CQ", buffer: "upper", operations: ["load"]}
        P7: {device: "QualityCheck", buffer: "buffer", operations: ["unload"]}
        P8: {device: "QualityCheck", buffer: "output_buffer", operations: ["load"]}
        P9: {device: "Warehouse", operations: ["unload"]}
    conveyors:
      - id: "Conveyor_AB"
        position: [25, 100] # Changed Y coordinate
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P2]
      - id: "Conveyor_BC"
        position: [45, 100] # Changed Y coordinate
        transfer_time: 5.0
        capacity: 3
        interacting_points: [P4]
      - id: "Conveyor_CQ"
        position: [65, 100] # Changed Y coordinate
        transfer_time: 5.0
        main_capacity: 4
        upper_capacity: 2
        lower_capacity: 2
        interacting_points: [P6]
    fault_system:
      fault_injection_interval: [120, 180]
      auto_recovery_time: [600, 1800]
      device_relationships:
        StationA: ["StationB", "AGV_1"]
        StationB: ["StationA", "StationC", "AGV_1", "AGV_2"]
        StationC: ["StationB", "QualityCheck", "AGV_2"]
        QualityCheck: ["StationC"]
        AGV_1: ["StationA", "StationB"]
        AGV_2: ["StationB", "StationC"] 


================================================
File: config/path_timing.py
================================================
# config/path_timing.py
"""
Path segment timing configuration for AGV navigation.
Defines the time required to travel between specific path points.
This file is auto-generated from AGVPathInfos.json by tools/process_path_data.py
"""

from typing import Dict, Tuple

# Path segment timing hashtable
# Key: (point_from, point_to) tuple
# Value: travel time in seconds
PATH_SEGMENT_TIMES: Dict[Tuple[str, str], float] = {
    ("P0", "P1"): 5.91666651,
    ("P0", "P10"): 8.949999,
    ("P0", "P11"): 2.98333287,
    ("P0", "P12"): 2.48000026,
    ("P0", "P13"): 16.6035519,
    ("P0", "P14"): 13.7135525,
    ("P0", "P15"): 2.50333285,
    ("P0", "P16"): 6.083333,
    ("P0", "P17"): 6.72,
    ("P0", "P18"): 9.636667,
    ("P0", "P19"): 11.3233328,
    ("P0", "P2"): 9.02,
    ("P0", "P20"): 12.1602192,
    ("P0", "P3"): 9.656666,
    ("P0", "P4"): 11.8866653,
    ("P0", "P5"): 12.5733328,
    ("P0", "P6"): 13.63335,
    ("P0", "P7"): 15.0968876,
    ("P0", "P8"): 16.65022,
    ("P0", "P9"): 19.54022,
    ("P1", "P10"): 11.8600006,
    ("P1", "P11"): 2.9333334,
    ("P1", "P12"): 5.436666,
    ("P1", "P13"): 19.5135536,
    ("P1", "P14"): 16.6235542,
    ("P1", "P15"): 3.41333342,
    ("P1", "P16"): 8.993334,
    ("P1", "P17"): 9.630001,
    ("P1", "P18"): 12.5466671,
    ("P1", "P19"): 14.2333336,
    ("P1", "P2"): 11.93,
    ("P1", "P20"): 15.0702209,
    ("P1", "P3"): 12.5666676,
    ("P1", "P4"): 14.7966661,
    ("P1", "P5"): 15.4833336,
    ("P1", "P6"): 16.54335,
    ("P1", "P7"): 18.0068874,
    ("P1", "P8"): 19.56022,
    ("P1", "P9"): 22.45022,
    ("P10", "P11"): 10.9266663,
    ("P10", "P12"): 11.43,
    ("P10", "P13"): 9.653553,
    ("P10", "P14"): 6.76355362,
    ("P10", "P15"): 8.446667,
    ("P10", "P16"): 4.866666,
    ("P10", "P17"): 4.22999954,
    ("P10", "P18"): 2.6866672,
    ("P10", "P19"): 4.37333345,
    ("P10", "P20"): 5.21022034,
    ("P11", "P12"): 2.50333285,
    ("P11", "P13"): 18.58022,
    ("P11", "P14"): 15.69022,
    ("P11", "P15"): 2.48000026,
    ("P11", "P16"): 8.06,
    ("P11", "P17"): 8.696667,
    ("P11", "P18"): 11.6133327,
    ("P11", "P19"): 13.3,
    ("P11", "P20"): 14.1368866,
    ("P12", "P13"): 19.0835514,
    ("P12", "P14"): 16.193552,
    ("P12", "P15"): 4.983333,
    ("P12", "P16"): 8.56333351,
    ("P12", "P17"): 9.2,
    ("P12", "P18"): 12.1166658,
    ("P12", "P19"): 13.8033323,
    ("P12", "P20"): 14.6402187,
    ("P13", "P14"): 4.88999939,
    ("P13", "P15"): 16.10022,
    ("P13", "P16"): 12.52022,
    ("P13", "P17"): 11.8835526,
    ("P13", "P18"): 8.96688652,
    ("P13", "P19"): 7.28,
    ("P13", "P20"): 6.443333,
    ("P14", "P15"): 13.21022,
    ("P14", "P16"): 9.630219,
    ("P14", "P17"): 8.993553,
    ("P14", "P18"): 6.076886,
    ("P14", "P19"): 4.39000034,
    ("P14", "P20"): 3.55333328,
    ("P15", "P16"): 5.58,
    ("P15", "P17"): 6.2166667,
    ("P15", "P18"): 9.133333,
    ("P15", "P19"): 10.8200006,
    ("P15", "P20"): 11.6568871,
    ("P16", "P17"): 2.63666654,
    ("P16", "P18"): 5.55333328,
    ("P16", "P19"): 7.24,
    ("P16", "P20"): 8.076886,
    ("P17", "P18"): 4.916667,
    ("P17", "P19"): 6.603333,
    ("P17", "P20"): 7.44022,
    ("P18", "P19"): 3.68666649,
    ("P18", "P20"): 4.523553,
    ("P19", "P20"): 2.83666682,
    ("P2", "P10"): 7.80333328,
    ("P2", "P11"): 10.9966679,
    ("P2", "P12"): 11.5,
    ("P2", "P13"): 15.4568863,
    ("P2", "P14"): 12.5668869,
    ("P2", "P15"): 8.516666,
    ("P2", "P16"): 2.93666673,
    ("P2", "P17"): 3.57333326,
    ("P2", "P18"): 6.49000025,
    ("P2", "P19"): 10.1766663,
    ("P2", "P20"): 11.0135527,
    ("P2", "P3"): 2.63666654,
    ("P2", "P4"): 4.866666,
    ("P2", "P5"): 5.55333328,
    ("P2", "P6"): 12.4866829,
    ("P2", "P7"): 13.9502192,
    ("P2", "P8"): 15.5035534,
    ("P2", "P9"): 18.3935528,
    ("P3", "P10"): 7.166666,
    ("P3", "P11"): 11.6333332,
    ("P3", "P12"): 12.1366673,
    ("P3", "P13"): 14.820219,
    ("P3", "P14"): 11.93022,
    ("P3", "P15"): 9.153334,
    ("P3", "P16"): 3.57333326,
    ("P3", "P17"): 2.93666673,
    ("P3", "P18"): 5.85333347,
    ("P3", "P19"): 9.539999,
    ("P3", "P20"): 10.3768864,
    ("P3", "P4"): 4.22999954,
    ("P3", "P5"): 4.916667,
    ("P3", "P6"): 11.8500156,
    ("P3", "P7"): 13.3135529,
    ("P3", "P8"): 14.8668861,
    ("P3", "P9"): 17.7568855,
    ("P4", "P10"): 2.93666673,
    ("P4", "P11"): 13.8633327,
    ("P4", "P12"): 14.3666658,
    ("P4", "P13"): 12.5902195,
    ("P4", "P14"): 9.70022,
    ("P4", "P15"): 11.3833332,
    ("P4", "P16"): 5.80333328,
    ("P4", "P17"): 7.166666,
    ("P4", "P18"): 3.623334,
    ("P4", "P19"): 7.31000042,
    ("P4", "P20"): 8.146887,
    ("P4", "P5"): 2.6866672,
    ("P4", "P6"): 9.620016,
    ("P4", "P7"): 11.0835533,
    ("P4", "P8"): 12.6368866,
    ("P4", "P9"): 15.526886,
    ("P5", "P10"): 3.623334,
    ("P5", "P11"): 14.55,
    ("P5", "P12"): 15.0533333,
    ("P5", "P13"): 11.903553,
    ("P5", "P14"): 9.013554,
    ("P5", "P15"): 12.0700006,
    ("P5", "P16"): 6.49000025,
    ("P5", "P17"): 7.85333347,
    ("P5", "P18"): 2.93666673,
    ("P5", "P19"): 6.623333,
    ("P5", "P20"): 7.46022,
    ("P5", "P6"): 8.93335,
    ("P5", "P7"): 10.3968868,
    ("P5", "P8"): 11.95022,
    ("P5", "P9"): 14.8402195,
    ("P6", "P10"): 6.68335056,
    ("P6", "P11"): 15.6100159,
    ("P6", "P12"): 16.11335,
    ("P6", "P13"): 9.576327,
    ("P6", "P14"): 6.686328,
    ("P6", "P15"): 13.1300163,
    ("P6", "P16"): 9.550016,
    ("P6", "P17"): 8.91335,
    ("P6", "P18"): 5.9966836,
    ("P6", "P19"): 2.310018,
    ("P6", "P20"): 5.13299465,
    ("P6", "P7"): 8.069662,
    ("P6", "P8"): 9.622995,
    ("P6", "P9"): 12.5129948,
    ("P7", "P10"): 8.146887,
    ("P7", "P11"): 17.0735531,
    ("P7", "P12"): 17.5768871,
    ("P7", "P13"): 9.379999,
    ("P7", "P14"): 6.49,
    ("P7", "P15"): 14.5935535,
    ("P7", "P16"): 11.0135536,
    ("P7", "P17"): 10.3768864,
    ("P7", "P18"): 7.46022,
    ("P7", "P19"): 5.77333355,
    ("P7", "P20"): 2.93666673,
    ("P7", "P8"): 3.55333328,
    ("P7", "P9"): 6.443333,
    ("P8", "P10"): 9.70022,
    ("P8", "P11"): 18.6268883,
    ("P8", "P12"): 19.13022,
    ("P8", "P13"): 7.826667,
    ("P8", "P14"): 2.93666673,
    ("P8", "P15"): 16.1468868,
    ("P8", "P16"): 12.5668869,
    ("P8", "P17"): 11.93022,
    ("P8", "P18"): 9.013554,
    ("P8", "P19"): 7.326667,
    ("P8", "P20"): 6.49,
    ("P8", "P9"): 4.88999939,
    ("P9", "P10"): 12.5902195,
    ("P9", "P11"): 21.5168877,
    ("P9", "P12"): 22.0202179,
    ("P9", "P13"): 2.93666673,
    ("P9", "P14"): 7.826667,
    ("P9", "P15"): 19.0368862,
    ("P9", "P16"): 15.4568863,
    ("P9", "P17"): 14.820219,
    ("P9", "P18"): 11.903553,
    ("P9", "P19"): 10.2166672,
    ("P9", "P20"): 9.379999,
}


def get_travel_time(from_point: str, to_point: str) -> float:
    """
    Get travel time between two path points, considering bidirectional paths.
    
    Args:
        from_point: Starting path point (e.g., "P0")
        to_point: Destination path point (e.g., "P1")
        
    Returns:
        Travel time in seconds, or -1.0 if path not found
    """
    segment = (from_point, to_point)
    segment_reverse = (to_point, from_point)
    if segment in PATH_SEGMENT_TIMES:
        return PATH_SEGMENT_TIMES[segment]
    elif segment_reverse in PATH_SEGMENT_TIMES:
        return PATH_SEGMENT_TIMES[segment_reverse]
    else:
        return -1.0


def get_all_reachable_points(from_point: str) -> Dict[str, float]:
    """
    Get all points reachable from a given point with their travel times.
    This function considers paths to be bidirectional.
    
    Args:
        from_point: Starting path point
        
    Returns:
        Dictionary mapping destination points to travel times
    """
    reachable = {}
    for (start, end), time in PATH_SEGMENT_TIMES.items():
        if start == from_point:
            reachable[end] = time
        elif end == from_point:
            reachable[start] = time
    return reachable


def is_path_available(from_point: str, to_point: str) -> bool:
    """
    Check if a direct path exists between two points, considering bidirectional paths.
    
    Args:
        from_point: Starting path point
        to_point: Destination path point
        
    Returns:
        True if direct path exists, False otherwise
    """
    segment = (from_point, to_point)
    segment_reverse = (to_point, from_point)
    return segment in PATH_SEGMENT_TIMES or segment_reverse in PATH_SEGMENT_TIMES



================================================
File: config/schemas.py
================================================
# config/schemas.py
from typing import Optional, Dict, Any, List
from pydantic import BaseModel, Field
from enum import Enum
from src.simulation.entities.product import Product

# --- Enums for Statuses and Priorities ---

class DeviceStatus(str, Enum):
    IDLE = "idle"
    PROCESSING = "processing"
    MAINTENANCE = "maintenance"
    SCRAP = "scrap"

    WORKING = "working"    # Ê≠£Â∏∏Â∑•‰Ωú‰∏≠
    BLOCKED = "blocked"    # Ë¢´Â†µÂ°û
    FAULT = "fault"        # ÊïÖÈöúÁä∂ÊÄÅ

    # AGV
    MOVING = "moving"
    INTERACTING = "interacting"  # New status for device-to-device interaction
    CHARGING = "charging"

class OrderPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

# --- Êñ∞Â¢ûÔºöËÆæÂ§áËØ¶ÁªÜÁä∂ÊÄÅ‰ø°ÊÅØ ---

class DeviceDetailedStatus(BaseModel):
    """ËÆæÂ§áËØ¶ÁªÜÁä∂ÊÄÅ‰ø°ÊÅØÔºåÁî®‰∫éinspectÂäüËÉΩ"""
    # Âü∫Á°Ä‰ø°ÊÅØ
    device_id: str = Field(..., description="ËÆæÂ§áID")
    device_type: str = Field(..., description="ËÆæÂ§áÁ±ªÂûãÔºàstation/agvÔºâ")
    current_status: DeviceStatus = Field(..., description="ÂΩìÂâçËÆæÂ§áÁä∂ÊÄÅ")
    
    # ÊÄßËÉΩÊåáÊ†á
    temperature: float = Field(..., description="ËÆæÂ§áÊ∏©Â∫¶Ôºà¬∞CÔºâ")
    vibration_level: float = Field(..., description="ÊåØÂä®Ê∞¥Âπ≥Ôºàmm/sÔºâ")
    power_consumption: float = Field(..., description="ÂäüËÄóÔºàWÔºâ")
    efficiency_rate: float = Field(..., description="ÊïàÁéáÁéáÔºà%Ôºâ")
    
    # Â∑•‰ΩúÁä∂ÊÄÅ
    cycle_count: int = Field(..., description="Â∑•‰ΩúÂæ™ÁéØÊ¨°Êï∞")
    last_maintenance_time: float = Field(..., description="‰∏äÊ¨°Áª¥Êä§Êó∂Èó¥")
    operating_hours: float = Field(..., description="ËøêË°åÂ∞èÊó∂Êï∞")
    
    # ÊïÖÈöúÁõ∏ÂÖ≥
    fault_symptom: Optional[str] = Field(None, description="ÊïÖÈöúÁóáÁä∂")
    frozen_until: Optional[float] = Field(None, description="ÂÜªÁªìÂà∞‰ªÄ‰πàÊó∂ÂÄô")
    
    # ÁâπÂÆö‰∫éÂ∑•Á´ôÁöÑÂ±ûÊÄß
    precision_level: Optional[float] = Field(None, description="Âä†Â∑•Á≤æÂ∫¶Ê∞¥Âπ≥")
    tool_wear_level: Optional[float] = Field(None, description="ÂàÄÂÖ∑Á£®ÊçüÁ®ãÂ∫¶")
    lubricant_level: Optional[float] = Field(None, description="Ê∂¶ÊªëÊ≤πÊ∞¥Âπ≥")
    
    # ÁâπÂÆö‰∫éAGVÁöÑÂ±ûÊÄß
    battery_level: Optional[float] = Field(None, description="ÁîµÊ±†ÁîµÈáè")
    position_accuracy: Optional[float] = Field(None, description="ÂÆö‰ΩçÁ≤æÂ∫¶")
    load_weight: Optional[float] = Field(None, description="ÂΩìÂâçËΩΩÈáç")

class DiagnosisResult(BaseModel):
    """ËØäÊñ≠ÁªìÊûúschema"""
    device_id: str = Field(..., description="ËÆæÂ§áID")
    diagnosis_command: str = Field(..., description="ËØäÊñ≠ÂëΩ‰ª§")
    is_correct: bool = Field(..., description="ËØäÊñ≠ÊòØÂê¶Ê≠£Á°Æ")
    repair_time: float = Field(..., description="‰øÆÂ§çÊó∂Èó¥ÔºàÁßíÔºâ")
    penalty_applied: bool = Field(..., description="ÊòØÂê¶Â∫îÁî®‰∫ÜÊÉ©ÁΩö")
    affected_devices: List[str] = Field([], description="ÂèóÂΩ±ÂìçÁöÑÂÖ∂‰ªñËÆæÂ§á")
    can_skip: bool = Field(..., description="ÊòØÂê¶ÂèØ‰ª•Ë∑≥ËøáÁ≠âÂæÖÊó∂Èó¥")

# --- Schemas for MQTT Messages ---

class AgentCommand(BaseModel):
    """
    Schema for commands sent by the agent to the factory.
    Published to: factory/agent/commands
    """
    command_id: Optional[str] = Field(None, description="The ID of the command.")
    action: str = Field(..., description="The action to be performed, e.g., 'move_agv'.")
    target: str = Field(..., description="The ID of the device or entity to act upon.")
    params: Dict[str, Any] = Field({}, description="A dictionary of parameters for the action.")

class SystemResponse(BaseModel):
    """
    Schema for responses sent by the system to the agent.
    Published to: factory/agent/responses
    """
    timestamp: float = Field(..., description="Simulation timestamp of the response.")
    command_id: Optional[str] = Field(None, description="The ID of the command.")
    response: str = Field(..., description="The response to the command.")

class ProductInfo(BaseModel):
    """ÁÆÄÂåñÁöÑ‰∫ßÂìÅ‰ø°ÊÅØÔºåÁî®‰∫éMQTT‰º†Ëæì"""
    id: str = Field(..., description="Product ID")
    product_type: str = Field(..., description="Product type (P1, P2, P3)")
    quality_score: float = Field(..., description="Current quality score")
    rework_count: int = Field(0, description="Number of reworks")

class StationStatus(BaseModel):
    """
    Schema for the status of a production station.
    Published to: NLDF/line1/station/{id}/status
    """
    timestamp: float = Field(..., description="Simulation timestamp of the status update.")
    source_id: str = Field(..., description="ID of the station (e.g., 'Station_A').")
    status: DeviceStatus = Field(..., description="Current status of the station.")
    message: Optional[str] = Field(None, description="Current action message, e.g., 'emergency charging', 'voluntary charging', 'moving to P1'.")
    buffer: List[str] = Field(..., description="List of product IDs in the buffer.")
    stats: Dict[str, Any] = Field(..., description="Statistics of the station.")
    # Optional fields, primarily for QualityChecker
    output_buffer: List[str] = Field([], description="List of product IDs in the output buffer.")

class AGVStatus(BaseModel):
    """
    Schema for the status of an Automated Guided Vehicle (AGV).
    Published to: NLDF/line1/agv/{id}/status
    """
    timestamp: float = Field(..., description="Simulation timestamp of the status update.")
    source_id: str = Field(..., description="ID of the AGV (e.g., 'AGV_1').")
    status: DeviceStatus = Field(..., description="Current status of the AGV.")
    speed_mps: float = Field(..., description="Current speed of the AGV (m/s).")
    current_point: str = Field(..., description="Current point of the AGV, e.g., 'P1'.")
    position: Dict[str, float] = Field(..., description="Current coordinates of the AGV, e.g., {'x': 10.0, 'y': 15.0}.")
    target_point: Optional[str] = Field(None, description="Target point of the AGV if moving. eg. 'P1'")
    estimated_time: float = Field(..., description="Estimated time to complete the task or moving to the target point.")
    payload: List[str] = Field(..., description="List of product IDs currently being carried.")
    battery_level: float = Field(..., ge=0, le=100, description="Current battery level (0-100%).")
    message: Optional[str] = Field(None, description="Current action message, e.g., 'emergency charging', 'voluntary charging', 'moving to P1'.")

class ConveyorStatus(BaseModel):
    """‰º†ÈÄÅÂ∏¶Áä∂ÊÄÅÁöÑÊï∞ÊçÆÊ®°Âûã"""
    timestamp: float = Field(..., description="Simulation timestamp of the status update.")
    source_id: str = Field(..., description="ID of the conveyor (e.g., 'Conveyor_1').")
    status: DeviceStatus = Field(..., description="Current status of the conveyor.")
    message: Optional[str] = Field(None, description="Current action message, e.g., 'emergency charging', 'voluntary charging', 'moving to P1'.")
    # For TripleBufferConveyor, buffer is the main buffer
    buffer: List[str] = Field(..., description="List of product IDs in the buffer.")
    # Only for TripleBufferConveyor
    upper_buffer: Optional[List[str]] = Field(None, description="List of product IDs in the upper buffer.")
    lower_buffer: Optional[List[str]] = Field(None, description="List of product IDs in the lower buffer.")
    # ÂèØÈÄâÔºöÂåÖÂê´ËØ¶ÁªÜ‰∫ßÂìÅ‰ø°ÊÅØ
    # buffer_details: Optional[List[ProductInfo]] = Field(None, description="Detailed product information in buffers")

class WarehouseStatus(BaseModel):
    """
    Schema for the status of a warehouse.
    Published to: NLDF/line1/warehouse/{id}/status
    """
    timestamp: float = Field(..., description="Simulation timestamp of the status update.")
    source_id: str = Field(..., description="ID of the warehouse (e.g., 'Warehouse_1').")
    message: str = Field(..., description="Message of the warehouse.")
    buffer: List[str] = Field(..., description="List of product IDs in the buffer.")
    stats: Dict[str, Any] = Field(..., description="Statistics of the warehouse.")

class OrderItem(BaseModel):
    """A single item within a new order."""
    product_type: str = Field(..., description="Type of the product (e.g., 'P1', 'P2', 'P3').")
    quantity: int = Field(..., gt=0, description="Number of units for this product type.")

class NewOrder(BaseModel):
    """
    Schema for a new manufacturing order.
    Published to: factory/orders/new
    """
    order_id: str = Field(..., description="Unique ID for the new order.")
    created_at: float = Field(..., description="Simulation timestamp when the order was created.")
    items: List[OrderItem] = Field(..., description="List of products and quantities in the order.")
    priority: OrderPriority = Field(..., description="Priority level of the order.")
    deadline: float = Field(..., description="Simulation timestamp by which the order should be completed.")

class FaultAlert(BaseModel):
    """
    Schema for fault alerts.
    Published to: NLDF/line1/alerts/{device_id}
    """
    timestamp: float = Field(..., description="Simulation timestamp of the alert.")
    device_id: str = Field(..., description="ID of the device that triggered the alert.")
    alert_type: str = Field(..., description="Type of the alert.")
    symptom: str = Field(..., description="Symptom of the alert.")
    fault_type: str = Field(..., description="Type of the fault.")
    estimated_duration: float = Field(..., description="Estimated duration of the fault (seconds).")
    message: str = Field(..., description="Message of the alert.")

class KPIUpdate(BaseModel):
    """
    Schema for Key Performance Indicator (KPI) updates.
    Published to: factory/kpi/update
    """
    timestamp: float = Field(..., description="Simulation timestamp of the KPI update.")
    
    # Production Efficiency (40%)
    order_completion_rate: float = Field(..., description="Percentage of orders completed.")
    average_production_cycle: float = Field(..., description="Weighted average of actual/theoretical production time ratio.")
    on_time_delivery_rate: float = Field(..., description="Percentage of orders completed on time.")
    device_utilization: float = Field(..., description="Average device utilization rate (%).")
    
    # Quality Metrics
    first_pass_rate: float = Field(..., description="Percentage of products passing quality check on first try.")
    
    # Cost Control (30%)
    total_production_cost: float = Field(..., description="Total accumulated production cost.")
    material_costs: float = Field(..., description="Total material costs.")
    energy_costs: float = Field(..., description="Total energy costs.")
    maintenance_costs: float = Field(..., description="Total maintenance costs.")
    scrap_costs: float = Field(..., description="Total costs from scrapped products.")
    
    # AGV Efficiency Metrics
    charge_strategy_efficiency: float = Field(0.0, description="Percentage of active charges vs total charges (%).")
    agv_energy_efficiency: float = Field(0.0, description="AGV tasks completed per minute of charging.")
    agv_utilization: float = Field(0.0, description="Average AGV transport time utilization (%).")
    
    # Raw Counts for Reference
    total_orders: int = Field(..., description="Total number of orders received.")
    completed_orders: int = Field(..., description="Number of completed orders.")
    active_orders: int = Field(..., description="Number of currently active orders.")
    total_products: int = Field(..., description="Total number of products produced.")
    active_faults: int = Field(..., description="Number of currently active faults.")

class FactoryStatus(BaseModel):
    """
    Schema for the overall factory status.
    Published to: factory/status
    """
    timestamp: float = Field(..., description="Simulation timestamp.")
    total_stations: int = Field(..., description="Total number of stations in the factory.")
    total_agvs: int = Field(..., description="Total number of AGVs in the factory.")
    active_orders: int = Field(..., description="Number of currently active orders.")
    total_orders: int = Field(..., description="Total number of orders received.")
    completed_orders: int = Field(..., description="Number of completed orders.")
    active_faults: int = Field(..., description="Number of currently active faults.")
    simulation_time: float = Field(..., description="Current simulation time.") 


================================================
File: config/settings.py
================================================
# config/settings.py

# MQTT Broker Configuration
# As specified in the user request.
MQTT_BROKER_HOST = "supos-ce-instance4.supos.app"
MQTT_BROKER_PORT = 1883

# Simulation Settings
SIMULATION_SPEED = 5  # 1 = real-time, 10 = 10x speed
LOG_LEVEL = "INFO"

# Path to factory layout and game rules configurations
FACTORY_LAYOUT_PATH = "config/factory_layout.yml"
GAME_RULES_PATH = "config/game_rules.yml" 


================================================
File: config/topics.py
================================================
# config/topics.py
# MQTT Topic definitions for the SUPCON AdventureX Factory Simulation

# Device status topics (published by factory devices)
# STATION_STATUS_TOPIC = "NLDF1/{line}/station/{device_id}/status"
# AGV_STATUS_TOPIC = "NLDF1/{line}/resource/{device_id}/status"
# QUALITY_CHECKER_STATUS_TOPIC = "NLDF1/{line}/quality/{device_id}/status"
NEW_FACTORY_STATUS_TOPIC = "NLDF1/{line}/{device_type}/{device_id}/status"
FACTORY_STATUS_TOPIC = "NLDF1/{line}/status"

# Buffer full alert topics (published by fault system)
BUFFER_FULL_ALERT_TOPIC = "NLDF1/line1/alerts/buffer_full"
AGV_BATTERY_LOW_ALERT_TOPIC = "NLDF1/line1/alerts/agv_battery_low"

# Order and KPI topics
NEW_ORDER_TOPIC = "NLDF1/line1/orders/status"
KPI_UPDATE_TOPIC = "NLDF1/line1/kpi/status"
RESULT_TOPIC = "NLDF1/line1/result/status"
# Agent command topics (published by AI agents)
AGENT_COMMANDS_TOPIC = "NLDF1/line1/agent/commands"
# Agent response topics (subscribed by AI agents)
AGENT_RESPONSES_TOPIC = "NLDF1/line1/agent/responses"

# Natural language logs for visualization
NL_LOGS_TOPIC = "NLDF1/{line}/agent/nl_logs"

# Topic patterns for subscription
ALL_STATION_STATUS = "NLDF1/{line}/station/+/status"
ALL_AGV_STATUS = "NLDF1/{line}/resource/+/status"
ALL_FACTORY_TOPICS = "NLDF1/{line}/+"

# Legacy topic definitions (keeping for backward compatibility)
STATION_STATUS_TOPIC_PREFIX = "NLDF1/line1/station"
CONVEYOR_STATUS_TOPIC_PREFIX = "NLDF1/line1/conveyor"
AGV_STATUS_TOPIC_PREFIX = "NLDF1/line1/agv"
WAREHOUSE_STATUS_TOPIC_PREFIX = "NLDF1/line1/warehouse"
DEVICE_ALERT_TOPIC = "NLDF1/line1/alerts"

def get_station_status_topic(station_id: str) -> str:
    """Returns the status topic for a specific station."""
    return f"{STATION_STATUS_TOPIC_PREFIX}/{station_id}/status"

def get_conveyor_status_topic(conveyor_id: str) -> str:
    """Returns the status topic for a specific conveyor."""
    return f"{CONVEYOR_STATUS_TOPIC_PREFIX}/{conveyor_id}/status"

def get_agv_status_topic(agv_id: str) -> str:
    """Returns the status topic for a specific AGV."""
    return f"{AGV_STATUS_TOPIC_PREFIX}/{agv_id}/status" 

def get_warehouse_status_topic(warehouse_id: str) -> str:
    """Returns the status topic for a specific warehouse."""
    return f"{WAREHOUSE_STATUS_TOPIC_PREFIX}/{warehouse_id}/status"




================================================
File: src/main.py
================================================
#!/usr/bin/env python3
# src/main.py

"""
Main entry point for the SUPCON Factory Simulation.

This script initializes and runs the complete simulation environment:
- Factory with stations and AGVs
- MQTT connectivity for agent communication
- Command handling for external control
"""

import logging
import signal
import sys
import time
import argparse
from typing import Optional

from src.simulation.factory import Factory
from src.utils.config_loader import load_factory_config
from src.utils.mqtt_client import MQTTClient
from src.agent_interface.command_handler import CommandHandler
from src.user_input import menu_input_thread
from config.settings import MQTT_BROKER_HOST, MQTT_BROKER_PORT, LOG_LEVEL
from src.game_logic.fault_system import FaultType

# Configure logging
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class FactorySimulation:
    """
    Main orchestrator class that combines all components of the factory simulation.
    """
    
    def __init__(self):
        self.factory: Optional[Factory] = None
        self.mqtt_client: Optional[MQTTClient] = None
        self.command_handler: Optional[CommandHandler] = None
        self.running = False

    def initialize(self, no_faults: bool = False):
        """Initialize all simulation components."""
        logger.info("üè≠ Initializing Factory Simulation...")
        
        # Create MQTT client first
        self.mqtt_client = MQTTClient(MQTT_BROKER_HOST, MQTT_BROKER_PORT, "factory_simulation")
        
        # Connect to MQTT
        self.mqtt_client.connect()
        logger.info(f"üì° Connecting to MQTT broker at {MQTT_BROKER_HOST}:{MQTT_BROKER_PORT}")

        # Wait for MQTT client to be fully connected
        max_retries = 20
        retry_interval = 0.5
        for i in range(max_retries):
            if self.mqtt_client.is_connected():
                logger.info("‚úÖ MQTT client is fully connected.")
                break
            logger.info(f"Waiting for MQTT connection... ({i+1}/{max_retries})")
            time.sleep(retry_interval)
        else:
            logger.error("‚ùå Failed to connect to MQTT broker within the given time. Exiting simulation.")
            raise ConnectionError("MQTT connection failed.")

        # Create the factory with MQTT client
        self.factory = Factory(load_factory_config(), self.mqtt_client, no_faults=no_faults)
        logger.info(f"‚úÖ Factory created with {len(self.factory.stations)} stations and {len(self.factory.agvs)} AGVs")
        logger.info("üìã Order generation, fault system, and KPI calculation initialized")
        
        # Create command handler (this will start listening for commands)
        self.command_handler = CommandHandler(self.factory, self.mqtt_client)
        logger.info("üéØ Command handler initialized and listening for agent commands")
        
    def _calculate_station_utilization(self, station) -> float:
        """Calculate actual utilization of a station based on processing time and idle time."""
        if not hasattr(station, 'total_processing_time') or not hasattr(station, 'total_idle_time'):
            # If tracking isn't implemented yet, estimate based on status
            if station.status.value == 'processing':
                return 0.85  # High utilization when processing
            elif station.status.value == 'idle':
                return 0.15  # Low utilization when idle
            elif station.status.value == 'error':
                return 0.0   # No utilization during errors
            else:
                return 0.5   # Medium utilization for other states
        
        total_time = station.total_processing_time + station.total_idle_time
        if total_time == 0:
            return 0.0
        
        return min(1.0, station.total_processing_time / total_time)

    def run(self, duration: Optional[int] = None):
        """Run the simulation."""
        if self.factory is None:
            logger.error("‚ùå Factory is not initialized. Call initialize() first.")
            return

        logger.info("üöÄ Starting Factory Simulation...")
        self.running = True
        
        try:
            if duration:
                logger.info(f"‚è±Ô∏è  Running simulation for {duration} seconds")
                self.factory.run(until=duration)
                # For fixed duration, print scores after normal completion
                self.factory.print_final_scores()
            else:
                logger.info("üîÑ Running simulation indefinitely (Ctrl+C to stop)")
                while self.running:
                    # Run simulation for 1 second at a time
                    self.factory.run(until=int(self.factory.env.now) + 1)
                    time.sleep(1)  # Small delay to prevent busy waiting
                    
        except KeyboardInterrupt:
            logger.info("üõë Simulation interrupted by user")
            # Scores will be printed in shutdown()
        except Exception as e:
            logger.error(f"‚ùå Simulation error: {e}")
        finally:
            # For indefinite runs or errors, print scores during shutdown
            if not duration:
                self.shutdown()
            else:
                # For fixed duration runs, just clean up without printing scores again
                logger.info("üßπ Cleaning up resources...")
                self.running = False
                if self.mqtt_client:
                    self.mqtt_client.disconnect()
                logger.info("üëã Factory Simulation stopped")

    def shutdown(self):
        """Clean up resources."""
        logger.info("üßπ Shutting down Factory Simulation...")
        self.running = False
        
        # Print final scores when shutting down
        if self.factory:
            self.factory.print_final_scores()
        
        if self.mqtt_client:
            self.mqtt_client.disconnect()
            
        logger.info("üëã Factory Simulation stopped")

def signal_handler(signum, frame):
    """Handle shutdown signals gracefully."""
    logger.info(f"Received signal {signum}, initiating graceful shutdown...")
    sys.exit(0)


def main(argv=None):
    """Main function."""
    # Add argparse to handle command-line arguments
    parser = argparse.ArgumentParser(description="SUPCON Factory Simulation Launcher")
    parser.add_argument(
        "--no-faults",
        action="store_true", # This makes it a boolean flag
        help="Run the simulation without the fault system enabled."
    )
    parser.add_argument(
        "--menu",
        action="store_true",
        help="Enable the interactive menu for manual control."
    )
    args = parser.parse_args(argv)

    # Set up signal handlers for graceful shutdown
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Create and run simulation
    simulation = FactorySimulation()
    
    try:
        simulation.initialize(no_faults=args.no_faults) # Pass the argument to initialize
        # Start menu input thread if requested
        if args.menu:
            import threading
            threading.Thread(target=menu_input_thread, args=(simulation.mqtt_client, simulation.factory), daemon=True).start()
            logger.info("Interactive menu enabled. Type commands in the console.")

        simulation.run()  # Run indefinitely
    except Exception as e:
        logger.error(f"‚ùå Failed to start simulation: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main()) 


================================================
File: src/user_input.py
================================================
import json
from src.simulation.factory import Factory
from src.utils.mqtt_client import MQTTClient
from config.topics import AGENT_COMMANDS_TOPIC, RESULT_TOPIC
from src.game_logic.fault_system import FaultType

def get_device_map(factory: Factory) -> dict:
    """Creates a mapping from simple codes to full device IDs."""
    device_map = {
        "R": "RawMaterial", "W": "Warehouse",
        "A": "StationA", "B": "StationB", "C": "StationC", "Q": "QualityCheck",
        "C1": "Conveyor_AB", "C2": "Conveyor_BC", "C3": "Conveyor_CQ",
    }
    # Dynamically add AGVs to the map
    for agv in factory.agvs.values():
        agv_num = agv.id.split('_')[-1]
        device_map[agv_num] = agv.id
    return device_map

def menu_input_thread(mqtt_client: MQTTClient, factory: Factory):
    """Thread for handling user menu input for manual control."""
    device_map = get_device_map(factory)
    
    load_unload_devices = {k: v for k, v in device_map.items() if not k.isdigit()}
    fault_devices = device_map

    load_prompt = f"ËØ∑ËæìÂÖ•Ë£ÖËΩΩËÆæÂ§áÁºñÂè∑ ({', '.join(load_unload_devices.keys())}): "
    unload_prompt = f"ËØ∑ËæìÂÖ•Âç∏ËΩΩËÆæÂ§áÁºñÂè∑ ({', '.join(load_unload_devices.keys())}): "
    fault_prompt = f"ËØ∑ËæìÂÖ•ËÆæÂ§áÁºñÂè∑ ({', '.join(fault_devices.keys())}): "

    while True:
        print("\nËØ∑ÈÄâÊã©Êìç‰ΩúÁ±ªÂûãÔºö")
        print("1. ÁßªÂä®AGV")
        print("2. Ë£ÖËΩΩ")
        print("3. Âç∏ËΩΩ")
        print("4. ÂÖÖÁîµ")
        print("5. Ê≥®ÂÖ•ÊïÖÈöú")
        print("6. Êü•ÁúãÁªìÊûú (result)")
        print("7. ÈÄÄÂá∫")
        op = input("> ").strip().lower()

        if op == "1":
            agv_id_short = input("ËØ∑ËæìÂÖ•AGVÁºñÂè∑ (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
            target_point = "P" + input("ËØ∑ËæìÂÖ•ÁõÆÊ†áÁÇπ (e.g., 1): ").strip()
            cmd = {"action": "move", "target": agv_id, "params": {"target_point": target_point}}

        elif op in ["2", "3"]: # Load/Unload
            action = "load" if op == "2" else "unload"
            agv_id_short = input("ËØ∑ËæìÂÖ•AGVÁºñÂè∑ (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
            
            prompt = load_prompt if action == "load" else unload_prompt
            device_id_short = input(prompt).strip().upper()
            device_id = load_unload_devices.get(device_id_short)

            if not device_id:
                print("Êó†ÊïàËÆæÂ§áÁºñÂè∑ÔºåËØ∑ÈáçËØï„ÄÇ")
                continue

            buffer_type = input("ËØ∑ËæìÂÖ•bufferÁ±ªÂûã (N.A./output_buffer/upper/lower): ").strip()
            params = {"device_id": device_id, "buffer_type": buffer_type}

            if action == "load":
                product_id = input("ËØ∑ËæìÂÖ•‰∫ßÂìÅÁºñÂè∑ÔºàÂèØÈÄâÔºâ: ").strip()
                if product_id:
                    params["product_id"] = product_id
            
            cmd = {"action": action, "target": agv_id, "params": params}

        elif op == "4":
            agv_id_short = input("ËØ∑ËæìÂÖ•AGVÁºñÂè∑ (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
            try:
                target_level = float(input("ËØ∑ËæìÂÖ•ÁõÆÊ†áÁîµÈáè (e.g., 80): ").strip())
            except ValueError:
                print("ÁõÆÊ†áÁîµÈáèÈúÄ‰∏∫Êï∞Â≠óÔºÅ")
                continue
            cmd = {"action": "charge", "target": agv_id, "params": {"target_level": target_level}}

        elif op == "5":
            if factory.fault_system is None:
                print("ÊïÖÈöúÁ≥ªÁªüÊú™ÂàùÂßãÂåñÔºåËØ∑ÂÖàÂàùÂßãÂåñÊïÖÈöúÁ≥ªÁªü„ÄÇ")
                continue
            
            # 1:StationB, 2:Conveyor_BC, 3:StationC
            fast_fault = input("ËØ∑ËæìÂÖ•ÊïÖÈöúÁ±ªÂûã (1:StationA for 50s, 2:Conveyor_AB for 50s, 3.StationB for 50s,4, Conveyor_BC for 50s, 5:StationC for 50s) else manual: ").strip()
            if fast_fault == "1":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationA"
                fault_duration = 50.0
            elif fast_fault == "2":
                fault_type = FaultType.CONVEYOR_FAULT
                device_id = "Conveyor_AB"
                fault_duration = 50.0
            elif fast_fault == "3":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationB"
                fault_duration = 50.0
            elif fast_fault == "4":
                fault_type = FaultType.STATION_FAULT
                device_id = "Conveyor_BC"
                fault_duration = 50.0
            elif fast_fault == "5":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationC"
                fault_duration = 50.0
            else:
                print("ÊâãÂä®ËÆæÁΩÆÊïÖÈöúÔºåËØ∑ËæìÂÖ•ËÆæÂ§áÁºñÂè∑: ")
                fault_type_in = input("ËØ∑ËæìÂÖ•ÊïÖÈöúÁ±ªÂûã (1:AGV, 2:Â∑•Á´ô, 3:‰º†ÈÄÅÂ∏¶): ").strip()
                fault_map = {"1": FaultType.AGV_FAULT, "2": FaultType.STATION_FAULT, "3": FaultType.CONVEYOR_FAULT}
                fault_type = fault_map.get(fault_type_in)
                device_id_short = input(fault_prompt).strip().upper()
                device_id = fault_devices.get(device_id_short)
                if not device_id:
                    print("Êó†ÊïàËÆæÂ§áÁºñÂè∑ÔºåËØ∑ÈáçËØï„ÄÇ")
                    continue
                fault_duration = float(input("ËØ∑ËæìÂÖ•ÊïÖÈöúÊåÅÁª≠Êó∂Èó¥ (Áßí): ").strip())
                try:
                    if not fault_type:
                        raise ValueError("Êó†ÊïàÁöÑÊïÖÈöúÁ±ªÂûã")
                except (ValueError, KeyError) as e:
                    print(f"ËæìÂÖ•Êó†Êïà: {e}ÔºÅ")
                    continue
                try:
                    if not fault_type:
                        raise ValueError("Êó†ÊïàÁöÑÊïÖÈöúÁ±ªÂûã")
                except (ValueError, KeyError) as e:
                    print(f"ËæìÂÖ•Êó†Êïà: {e}ÔºÅ")
                    continue
            
            factory.fault_system._inject_fault_now(device_id, fault_type, fault_duration)
            print(f"Â∑≤Ê≥®ÂÖ•ÊïÖÈöú: {device_id} {fault_type.name} {fault_duration}s")
            continue

        elif op == "6" or op == "result":
            # Ëé∑ÂèñÂπ∂ÊòæÁ§∫ÊúÄÁªàÁªìÊûú
            if factory.kpi_calculator:
                final_scores = factory.kpi_calculator.get_final_score()
                
                # ÊâìÂç∞Âà∞ÁªàÁ´ØÔºà‰∏éfactory.print_final_scores()Áõ∏ÂêåÊ†ºÂºèÔºâ
                print(f"\n{'='*60}")
                print("üèÜ ÊúÄÁªàÁ´ûËµõÂæóÂàÜ")
                print(f"{'='*60}")
                print(f"Áîü‰∫ßÊïàÁéáÂæóÂàÜ (40%): {final_scores['efficiency_score']:.2f}")
                print(f"  - ËÆ¢ÂçïÂÆåÊàêÁéá: {final_scores['efficiency_components']['order_completion']:.1f}%")
                print(f"  - Áîü‰∫ßÂë®ÊúüÊïàÁéá: {final_scores['efficiency_components']['production_cycle']:.1f}%")
                print(f"  - ËÆæÂ§áÂà©Áî®Áéá: {final_scores['efficiency_components']['device_utilization']:.1f}%")
                print(f"\nË¥®Èáè‰∏éÊàêÊú¨ÂæóÂàÜ (30%): {final_scores['quality_cost_score']:.2f}")
                print(f"  - ‰∏ÄÊ¨°ÈÄöËøáÁéá: {final_scores['quality_cost_components']['first_pass_rate']:.1f}%")
                print(f"  - ÊàêÊú¨ÊïàÁéá: {final_scores['quality_cost_components']['cost_efficiency']:.1f}%")
                print(f"\nAGVÊïàÁéáÂæóÂàÜ (30%): {final_scores['agv_score']:.2f}")
                print(f"  - ÂÖÖÁîµÁ≠ñÁï•ÊïàÁéá: {final_scores['agv_components']['charge_strategy']:.1f}%")
                print(f"  - ËÉΩÊïàÊØî: {final_scores['agv_components']['energy_efficiency']:.1f}%")
                print(f"  - AGVÂà©Áî®Áéá: {final_scores['agv_components']['utilization']:.1f}%")
                print(f"\nÊÄªÂæóÂàÜ: {final_scores['total_score']:.2f}")
                print(f"{'='*60}\n")
                
                # ÂèëÂ∏ÉÂæóÂàÜÂà∞MQTTÔºà‰∏çÂåÖÂê´ÂéüÂßãÊåáÊ†áÔºâ
                result_topic = RESULT_TOPIC
                

                scores_only = {
                    "total_score": round(final_scores['total_score'], 2),
                    "efficiency_score": round(final_scores['efficiency_score'], 2),
                    "efficiency_components": {k: round(v, 2) for k, v in final_scores['efficiency_components'].items()},
                    "quality_cost_score": round(final_scores['quality_cost_score'], 2),
                    "quality_cost_components": {k: round(v, 2) for k, v in final_scores['quality_cost_components'].items()},
                    "agv_score": round(final_scores['agv_score'], 2),
                    "agv_components": {k: round(v, 2) for k, v in final_scores['agv_components'].items()}
                }
                result_json = json.dumps(scores_only)
            
                mqtt_client.publish(result_topic, result_json)
                print(f"‚úÖ ÁªìÊûúÂ∑≤ÂèëÂ∏ÉÂà∞ {result_topic}")
            else:
                print("‚ùå KPIËÆ°ÁÆóÂô®Êú™ÂàùÂßãÂåñ")
            continue
            
        elif op == "7":
            print("ÈÄÄÂá∫ËèúÂçïËæìÂÖ•Á∫øÁ®ã„ÄÇ")
            break
        else:
            print("Êó†ÊïàÈÄâÊã©ÔºåËØ∑ÈáçËØï„ÄÇ")
            continue
        
        mqtt_client.publish(AGENT_COMMANDS_TOPIC, json.dumps(cmd))
        print(f"Â∑≤ÂèëÈÄÅÂëΩ‰ª§: {cmd}")


================================================
File: src/user_input_multi.py
================================================
import json
import threading
import time
from src.simulation.factory_multi import Factory
from src.utils.mqtt_client import MQTTClient
from config.topics import AGENT_COMMANDS_TOPIC, RESULT_TOPIC
from src.game_logic.fault_system import FaultType
from src.utils.topic_manager import TopicManager
from src.simulation.entities.product import Product

# ÂÖ®Â±ÄÂèòÈáèÊéßÂà∂Ëá™Âä®‰∏äÊñô
auto_feed_threads = {}  # {line_id: {"thread": thread, "active": bool}}

def auto_feed_station_a(factory: Factory, line_id: str, interval: float = 2.0, product_types=None):
    """Ëá™Âä®ËøûÁª≠Ê∑ªÂä†ÂéüÊùêÊñôÂà∞ StationA ÁöÑÁ∫øÁ®ãÂáΩÊï∞
    
    Args:
        factory: Â∑•ÂéÇÂÆû‰æã
        line_id: Áîü‰∫ßÁ∫øID
        interval: ‰∏äÊñôÈó¥ÈöîÊó∂Èó¥ÔºàÁßíÔºâ
        product_types: Ë¶ÅÁîü‰∫ßÁöÑ‰∫ßÂìÅÁ±ªÂûãÂàóË°®ÔºåÂ¶Ç ['P1'], ['P2', 'P3'] Êàñ NoneÔºàÂÖ®ÈÉ®Á±ªÂûãÔºâ
    """
    global auto_feed_threads
    product_count = 0
    
    # Â¶ÇÊûúÊ≤°ÊúâÊåáÂÆö‰∫ßÂìÅÁ±ªÂûãÔºåÂàôÂæ™ÁéØÊâÄÊúâÁ±ªÂûã
    if product_types is None:
        product_types = ['P1', 'P2', 'P3']
    
    type_index = 0
    
    while auto_feed_threads.get(line_id, {}).get("active", False):
        product_count += 1
        
        # Âæ™ÁéØÈÄâÊã©‰∫ßÂìÅÁ±ªÂûã
        product_type = product_types[type_index]
        type_index = (type_index + 1) % len(product_types)
        
        # ÂàõÂª∫ Product ÂØπË±°
        order_id = f"auto_order_{line_id}_{product_count}"
        product = Product(product_type, order_id)
        
        # Áõ¥Êé•Âêë StationA ÁöÑ buffer Ê∑ªÂä†‰∫ßÂìÅ
        try:
            station_a = factory.lines[line_id].stations["StationA"]
            # Ê£ÄÊü• buffer ÊòØÂê¶Â∑≤Êª°
            if len(station_a.buffer.items) < station_a.buffer.capacity:
                station_a.buffer.put(product)
                product.update_location(station_a.id, factory.env.now)
                product.add_history(factory.env.now, f"Auto-fed to StationA in {line_id}")
                print(f"{factory.env.now:.2f} ‚úÖ Ê∑ªÂä†‰∫ßÂìÅ {product.id} (Á±ªÂûã: {product_type}) Âà∞ {line_id} StationA")
                # ÂèëÂ∏ÉÁä∂ÊÄÅÊõ¥Êñ∞
                station_a.publish_status(f"Auto-fed product {product.id} added to buffer")
            else:
                print(f" {factory.env.now:.2f}‚è∏Ô∏è  {line_id} StationA ÁöÑ buffer Â∑≤Êª°ÔºåÁ≠âÂæÖ‰∏ãÊ¨°Â∞ùËØï")
        except Exception as e:
            print(f"[Ëá™Âä®‰∏äÊñô] ‚ùå ÈîôËØØ: {e}")
        
        time.sleep(interval)
    
    print(f"[Ëá™Âä®‰∏äÊñô] {line_id} ÁöÑËá™Âä®‰∏äÊñôÂ∑≤ÂÅúÊ≠¢")

def get_device_map(factory: Factory) -> dict:
    """Creates a mapping from simple codes to full device IDs."""
    device_map = {
        "R": "RawMaterial", "W": "Warehouse",
        "A": "StationA", "B": "StationB", "C": "StationC", "Q": "QualityCheck",
        "C1": "Conveyor_AB", "C2": "Conveyor_BC", "C3": "Conveyor_CQ",
        "1": "AGV_1", "2": "AGV_2"
    }
    return device_map

def menu_input_thread(mqtt_client: MQTTClient, factory: Factory, topic_manager: TopicManager):
    """Thread for handling user menu input for manual control."""
    device_map = get_device_map(factory)
    
    load_unload_devices = {k: v for k, v in device_map.items() if not k.isdigit()}
    fault_devices = device_map

    load_prompt = f"ËØ∑ËæìÂÖ•Ë£ÖËΩΩËÆæÂ§áÁºñÂè∑ ({', '.join(load_unload_devices.keys())}): "
    unload_prompt = f"ËØ∑ËæìÂÖ•Âç∏ËΩΩËÆæÂ§áÁºñÂè∑ ({', '.join(load_unload_devices.keys())}): "
    fault_prompt = f"ËØ∑ËæìÂÖ•ËÆæÂ§áÁºñÂè∑ ({', '.join(fault_devices.keys())}): "

    while True:
        print("\nËØ∑ÈÄâÊã©Êìç‰ΩúÁ±ªÂûãÔºö")
        print("1. ÁßªÂä®AGV")
        print("2. Ë£ÖËΩΩ")
        print("3. Âç∏ËΩΩ")
        print("4. ÂÖÖÁîµ")
        print("5. Ê≥®ÂÖ•ÊïÖÈöú")
        print("6. Êü•ÁúãÁªìÊûú (result)")
        print("7. Ëá™Âä®‰∏äÊñôÊéßÂà∂")
        print("8. ÈÄÄÂá∫")
        op = input("> ").strip().lower()

        if op == "1":
            line_id = f"line{input('ËØ∑ËæìÂÖ•Áîü‰∫ßÁ∫øÁºñÂè∑ (e.g., 1, 2, 3): ').strip()}"
            agv_id_short = input("ËØ∑ËæìÂÖ•AGVÁºñÂè∑ (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
            target_point = "P" + input("ËØ∑ËæìÂÖ•ÁõÆÊ†áÁÇπ (e.g., 1): ").strip()
            cmd = {"action": "move", "target": agv_id, "params": {"target_point": target_point}}

        elif op in ["2", "3"]: # Load/Unload
            action = "load" if op == "2" else "unload"
            line_id = f"line{input('ËØ∑ËæìÂÖ•Áîü‰∫ßÁ∫øÁºñÂè∑ (e.g., 1, 2, 3): ').strip()}"
            agv_id_short = input("ËØ∑ËæìÂÖ•AGVÁºñÂè∑ (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
           
            params = {}
            if action == "load":
                product_id = input("ËØ∑ËæìÂÖ•‰∫ßÂìÅÁºñÂè∑ÔºàÂèØÈÄâÔºâ: ").strip()
                if product_id:
                    params["product_id"] = product_id
            
            cmd = {"action": action, "target": agv_id, "params": params}

        elif op == "4":
            line_id = f"line{input('ËØ∑ËæìÂÖ•Áîü‰∫ßÁ∫øÁºñÂè∑ (e.g., 1, 2, 3): ').strip()}"
            agv_id_short = input("ËØ∑ËæìÂÖ•AGVÁºñÂè∑ (e.g., 1, 2): ").strip()
            agv_id = f"AGV_{agv_id_short}"
            try:
                target_level = float(input("ËØ∑ËæìÂÖ•ÁõÆÊ†áÁîµÈáè (e.g., 80): ").strip())
            except ValueError:
                print("ÁõÆÊ†áÁîµÈáèÈúÄ‰∏∫Êï∞Â≠óÔºÅ")
                continue
            cmd = {"action": "charge", "target": agv_id, "params": {"target_level": target_level}}

        elif op == "5":
            line_id = f"line{input('ËØ∑ËæìÂÖ•Áîü‰∫ßÁ∫øÁºñÂè∑ (e.g., 1, 2, 3): ').strip()}"
            
            if line_id not in factory.lines:
                print(f"Áîü‰∫ßÁ∫ø {line_id} ‰∏çÂ≠òÂú®ÔºÅ")
                continue
            
            if not hasattr(factory.lines[line_id], 'fault_system') or factory.lines[line_id].fault_system is None:
                print("ÊïÖÈöúÁ≥ªÁªüÊú™ÂàùÂßãÂåñÔºåËØ∑ÂÖàÂàùÂßãÂåñÊïÖÈöúÁ≥ªÁªü„ÄÇ")
                continue
            
            # 1:StationB, 2:Conveyor_BC, 3:StationC
            fast_fault = input("ËØ∑ËæìÂÖ•ÊïÖÈöúÁ±ªÂûã (1:StationA for 50s, 2:Conveyor_AB for 50s, 3.StationB for 50s,4, Conveyor_BC for 50s, 5:StationC for 50s) else manual: ").strip()
            if fast_fault == "1":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationA"
                fault_duration = 50.0
            elif fast_fault == "2":
                fault_type = FaultType.CONVEYOR_FAULT
                device_id = "Conveyor_AB"
                fault_duration = 50.0
            elif fast_fault == "3":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationB"
                fault_duration = 50.0
            elif fast_fault == "4":
                fault_type = FaultType.STATION_FAULT
                device_id = "Conveyor_BC"
                fault_duration = 50.0
            elif fast_fault == "5":
                fault_type = FaultType.STATION_FAULT
                device_id = "StationC"
                fault_duration = 50.0
            else:
                print("ÊâãÂä®ËÆæÁΩÆÊïÖÈöúÔºåËØ∑ËæìÂÖ•ËÆæÂ§áÁºñÂè∑: ")
                fault_type_in = input("ËØ∑ËæìÂÖ•ÊïÖÈöúÁ±ªÂûã (1:AGV, 2:Â∑•Á´ô, 3:‰º†ÈÄÅÂ∏¶): ").strip()
                fault_map = {"1": FaultType.AGV_FAULT, "2": FaultType.STATION_FAULT, "3": FaultType.CONVEYOR_FAULT}
                fault_type = fault_map.get(fault_type_in)
                device_id_short = input(fault_prompt).strip().upper()
                device_id = fault_devices.get(device_id_short)
                if not device_id:
                    print("Êó†ÊïàËÆæÂ§áÁºñÂè∑ÔºåËØ∑ÈáçËØï„ÄÇ")
                    continue
                fault_duration = float(input("ËØ∑ËæìÂÖ•ÊïÖÈöúÊåÅÁª≠Êó∂Èó¥ (Áßí): ").strip())
                try:
                    if not fault_type:
                        raise ValueError("Êó†ÊïàÁöÑÊïÖÈöúÁ±ªÂûã")
                except (ValueError, KeyError) as e:
                    print(f"ËæìÂÖ•Êó†Êïà: {e}ÔºÅ")
                    continue
                try:
                    if not fault_type:
                        raise ValueError("Êó†ÊïàÁöÑÊïÖÈöúÁ±ªÂûã")
                except (ValueError, KeyError) as e:
                    print(f"ËæìÂÖ•Êó†Êïà: {e}ÔºÅ")
                    continue
            
            factory.lines[line_id].fault_system._inject_fault_now(device_id, fault_type, fault_duration)
            print(f"Â∑≤Ê≥®ÂÖ•ÊïÖÈöú: {device_id} {fault_type.name} {fault_duration}s")
            continue

        elif op == "6" or op == "result":
            # ÈÄöËøáMQTTÂèëÈÄÅget_resultÂëΩ‰ª§
            line_id = "line1"
            cmd = {
                "command_id": f"get_result_{int(time.time()*1000)}",
                "action": "get_result", 
                "target": "baisuishan",  # target is required by AgentCommand schema
                "params": {}
            }
            
        elif op == "7":
            global auto_feed_threads
            print("\nËá™Âä®‰∏äÊñôÊéßÂà∂:")
            print("1. ÂêØÂä®Ëá™Âä®‰∏äÊñô")
            print("2. ÂÅúÊ≠¢Ëá™Âä®‰∏äÊñô")
            print("3. Êü•ÁúãËá™Âä®‰∏äÊñôÁä∂ÊÄÅ")
            sub_op = input("> ").strip()
            
            if sub_op == "1":
                line_id = f"line{input('ËØ∑ËæìÂÖ•Áîü‰∫ßÁ∫øÁºñÂè∑ (e.g., 1, 2, 3): ').strip()}"
                if line_id in auto_feed_threads and auto_feed_threads[line_id]["active"]:
                    print(f"{line_id} ÁöÑËá™Âä®‰∏äÊñôÂ∑≤Âú®ËøêË°å‰∏≠")
                else:
                    # ÈÄâÊã©‰∫ßÂìÅÁ±ªÂûã
                    print("\nÈÄâÊã©Ë¶ÅÁîü‰∫ßÁöÑ‰∫ßÂìÅÁ±ªÂûã:")
                    print("1. Âè™Áîü‰∫ß P1")
                    print("2. Âè™Áîü‰∫ß P2")
                    print("3. Âè™Áîü‰∫ß P3")
                    print("4. ËΩÆÊµÅÁîü‰∫ß P1 Âíå P2")
                    print("5. ËΩÆÊµÅÁîü‰∫ß P1 Âíå P3")
                    print("6. ËΩÆÊµÅÁîü‰∫ß P2 Âíå P3")
                    print("7. ËΩÆÊµÅÁîü‰∫ßÊâÄÊúâÁ±ªÂûã (P1, P2, P3)")
                    
                    type_choice = input("> ").strip()
                    product_types_map = {
                        "1": ["P1"],
                        "2": ["P2"],
                        "3": ["P3"],
                        "4": ["P1", "P2"],
                        "5": ["P1", "P3"],
                        "6": ["P2", "P3"],
                        "7": ["P1", "P2", "P3"]
                    }
                    
                    product_types = product_types_map.get(type_choice, ["P1", "P2", "P3"])
                    
                    try:
                        interval = float(input("ËØ∑ËæìÂÖ•‰∏äÊñôÈó¥ÈöîÊó∂Èó¥ÔºàÁßíÔºåÈªòËÆ§2.0Ôºâ: ").strip() or "2.0")
                    except ValueError:
                        interval = 2.0
                    
                    # ËÆæÁΩÆÁä∂ÊÄÅ‰∏∫ÊøÄÊ¥ªÔºåÂåÖÂê´‰∫ßÂìÅÁ±ªÂûã‰ø°ÊÅØ
                    auto_feed_threads[line_id] = {
                        "active": True,
                        "product_types": product_types,
                        "interval": interval
                    }
                    # ÂàõÂª∫Âπ∂ÂêØÂä®Á∫øÁ®ã
                    thread = threading.Thread(
                        target=auto_feed_station_a,
                        args=(factory, line_id, interval, product_types),
                        daemon=True
                    )
                    auto_feed_threads[line_id]["thread"] = thread
                    thread.start()
                    print(f"‚úÖ Â∑≤ÂêØÂä® {line_id} ÁöÑËá™Âä®‰∏äÊñô")
                    print(f"   ‰∫ßÂìÅÁ±ªÂûã: {', '.join(product_types)}")
                    print(f"   Èó¥ÈöîÊó∂Èó¥: {interval} Áßí")
            
            elif sub_op == "2":
                line_id = f"line{input('ËØ∑ËæìÂÖ•Áîü‰∫ßÁ∫øÁºñÂè∑ (e.g., 1, 2, 3): ').strip()}"
                if line_id in auto_feed_threads and auto_feed_threads[line_id]["active"]:
                    auto_feed_threads[line_id]["active"] = False
                    print(f"‚úÖ Ê≠£Âú®ÂÅúÊ≠¢ {line_id} ÁöÑËá™Âä®‰∏äÊñô...")
                else:
                    print(f"{line_id} ÁöÑËá™Âä®‰∏äÊñôÊú™Âú®ËøêË°å")
            
            elif sub_op == "3":
                print("\nËá™Âä®‰∏äÊñôÁä∂ÊÄÅ:")
                if not auto_feed_threads:
                    print("Ê≤°ÊúâËá™Âä®‰∏äÊñôÂú®ËøêË°å")
                else:
                    for line_id, info in auto_feed_threads.items():
                        status = "ËøêË°å‰∏≠" if info["active"] else "Â∑≤ÂÅúÊ≠¢"
                        product_types = info.get("product_types", ["Êú™Áü•"])
                        interval = info.get("interval", "Êú™Áü•")
                        print(f"  {line_id}: {status}")
                        if info["active"]:
                            print(f"    - ‰∫ßÂìÅÁ±ªÂûã: {', '.join(product_types)}")
                            print(f"    - Èó¥ÈöîÊó∂Èó¥: {interval} Áßí")
            continue
            
        elif op == "8":
            print("ÈÄÄÂá∫ËèúÂçïËæìÂÖ•Á∫øÁ®ã„ÄÇ")
            break
        else:
            print("Êó†ÊïàÈÄâÊã©ÔºåËØ∑ÈáçËØï„ÄÇ")
            continue
        
        # Only publish command if cmd was defined and line_id exists
        if 'cmd' in locals() and 'line_id' in locals():
            mqtt_client.publish(topic_manager.get_agent_command_topic(line_id), json.dumps(cmd))
            print(f"Â∑≤ÂèëÈÄÅÂëΩ‰ª§: {cmd}")



================================================
File: src/agent_interface/command_handler.py
================================================
# src/agent_interface/command_handler.py
import json
import logging
from typing import Dict, Any, Optional

from config.schemas import AgentCommand, SystemResponse
from config.topics import AGENT_COMMANDS_TOPIC, AGENT_RESPONSES_TOPIC
from src.utils.mqtt_client import MQTTClient

logger = logging.getLogger(__name__)

class CommandHandler:
    """
    Handles MQTT commands received from agents and translates them 
    into method calls on the factory simulation.
    
    This is the bridge between the external MQTT interface and the internal simulation.
    """
    
    def __init__(self, factory, mqtt_client: MQTTClient):
        """
        Args:
            factory: The Factory instance to send commands to.
            mqtt_client: The MQTT client to subscribe to agent commands.
        """
        self.factory = factory
        self.mqtt_client = mqtt_client
        
        # Subscribe to agent commands
        self.mqtt_client.subscribe(AGENT_COMMANDS_TOPIC, self._handle_command_message)
        logger.info(f"CommandHandler initialized and subscribed to {AGENT_COMMANDS_TOPIC}")

    def _handle_command_message(self, topic: str, payload: bytes):
        """
        Callback for incoming MQTT command messages.
        Parses the JSON and validates it against the AgentCommand schema.
        """
        try:
            # Parse JSON payload
            command_data = json.loads(payload.decode('utf-8'))
            
            try:
                # Validate using Pydantic schema
                command = AgentCommand.model_validate(command_data)
            except Exception as e:
                msg = f"Failed to validate command: {e}"    
                logger.error(msg)
                response_payload = SystemResponse(timestamp=self.factory.env.now, response=msg, command_id=command_data.get("command_id")).model_dump_json()
                self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, response_payload)
                return
            
            logger.debug(f"Received valid command: {command.action} for {command.target}")
            
            # Route the command to the appropriate handler
            self._execute_command(command)
            
        except Exception as e:
            msg = f"Failed to process command: {e}"
            logger.error(msg)
            response_payload = SystemResponse(timestamp=self.factory.env.now, command_id=command_data.get("command_id"), response=msg).model_dump_json()
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, response_payload)

    def _execute_command(self, command: AgentCommand):
        """
        Executes a validated command by calling the appropriate factory method.
        """
        action = command.action
        params = command.params
        target = command.target
        command_id = command.command_id
        try:
            if action == "test":
                self._handle_test_command(target, params, command_id)
            elif action == "move":
                self._handle_move_agv(target, params, command_id)
            elif action == "load":
                self._handle_load_agv(target, params, command_id)
            elif action == "unload":
                self._handle_unload_agv(target, params, command_id)
            elif action == "charge":
                self._handle_charge_agv(target, params, command_id)
            elif action == "agv_action_sequence":
                self._handle_agv_action_sequence(target, params)
            elif action == "request_maintenance":
                self._handle_request_maintenance(target, params)
            elif action == "inspect_device":
                self._handle_inspect_device(target, params)
            elif action == "skip_repair_time":
                self._handle_skip_repair_time(target, params)
            elif action == "get_available_devices":
                self._handle_get_available_devices(target, params)
            elif action == "emergency_stop":
                self._handle_emergency_stop(target, params)
            elif action == "adjust_priority":
                self._handle_adjust_priority(target, params)
            elif action == "reroute_order":
                self._handle_reroute_order(target, params)
            else:
                logger.warning(f"Unknown action: {action}")
                
        except Exception as e:
            logger.error(f"Failed to execute command {action}: {e}")

    def _handle_test_command(self, target: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle test MQTT commands."""
        msg = f"Received MQTT test command to {target} with params: {json.dumps(params)}"
        logger.debug(msg)
        payload = SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=msg).model_dump_json()
        self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, payload)
        return True

    def _handle_move_agv(self, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle AGV movement commands.
        params: {target_point: str}
        """
        target_point = params.get("target_point")
        if not target_point:
            msg = "move_agv command missing 'target_point' parameter"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=msg).model_dump_json())
            return
            
        if agv_id not in self.factory.agvs:
            msg = f"AGV {agv_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=msg).model_dump_json())
            return
            
        agv = self.factory.agvs[agv_id]
        
        logger.info(f"Moving {agv_id} from {agv.current_point} to {target_point}")

        def move_process():
            success, message = yield from agv.move_to(target_point)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=message).model_dump_json())
            return success, message
        
        self.factory.env.process(move_process())

    def _handle_load_agv(self, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle AGV load commands.
        params: {device_id: str, buffer_type: str}
        """
        device_id = params.get("device_id")
        buffer_type = params.get("buffer_type")
        product_id = params.get("product_id", None)

        if not device_id:
            msg = "load_agv command missing 'device_id' parameter"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=msg).model_dump_json())
            return
        if agv_id not in self.factory.agvs:
            msg = f"AGV {agv_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=f"AGV {agv_id} not found in factory").model_dump_json())
            return
        agv = self.factory.agvs[agv_id]
        device = self.factory.all_devices.get(device_id)
        if not device:
            msg = f"Device {device_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=f"Device {device_id} not found in factory").model_dump_json())
            return
        logger.info(f"AGV {agv_id} loading from {device_id} with buffer_type {buffer_type}")
        
        def load_process():
            success, message, _ = yield from agv.load_from(device, buffer_type, product_id)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=message).model_dump_json())
            return success, message
        
        self.factory.env.process(load_process())

    def _handle_unload_agv(self, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle AGV unload commands.
        params: {device_id: str, buffer_type: str}
        """
        device_id = params.get("device_id")
        buffer_type = params.get("buffer_type")
        if not device_id:
            msg = "unload_agv command missing 'device_id' parameter"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=msg).model_dump_json())
            return
        if agv_id not in self.factory.agvs:
            msg = f"AGV {agv_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=msg).model_dump_json())
            return
        agv = self.factory.agvs[agv_id]
        device = self.factory.all_devices.get(device_id)
        if not device:
            msg = f"Device {device_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=msg).model_dump_json())
            return
        logger.info(f"AGV {agv_id} unloading {device_id} with buffer_type {buffer_type}")
        
        def unload_process():
            success, message, _ = yield from agv.unload_to(device, buffer_type)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now,command_id=command_id, response=message).model_dump_json())
            return success, message
        
        self.factory.env.process(unload_process())

    def _handle_charge_agv(self, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle AGV charge commands.
        params: {target_level: float, action_time_factor: float}
        """
        target_level = params.get("target_level")
        if not target_level:
            msg = "charge_agv command missing 'target_level' parameter"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=msg).model_dump_json())
            return
        if agv_id not in self.factory.agvs:
            msg = f"AGV {agv_id} not found in factory"
            logger.error(msg)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=msg).model_dump_json())
            return
        agv = self.factory.agvs[agv_id]
        
        def charge_process():
            success, message = yield from agv.voluntary_charge(target_level)
            self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, SystemResponse(timestamp=self.factory.env.now, command_id=command_id, response=message).model_dump_json())
            return success, message
        
        self.factory.env.process(charge_process())

    def _handle_agv_action_sequence(self, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """ÊîØÊåÅagent‰∏ÄÊ¨°‰∏ãÂèë‰∏Ä‰∏≤AGVÂä®‰ΩúÔºå‰ªøÁúüÁ´ØÊåâÂ∫èÊâßË°åÂπ∂ÂèçÈ¶à„ÄÇparams: {actions: [{type, args}]}
        type: move/load/unload; args: dict
        """
        if agv_id not in self.factory.agvs:
            logger.error(f"AGV {agv_id} not found in factory")
            return
        agv = self.factory.agvs[agv_id]
        actions = params.get("actions", [])
        env = self.factory.env
        devices = {**self.factory.stations, **self.factory.agvs}
        # Âä†ÂÖ•conveyor/qualitychecker
        if hasattr(self.factory, 'conveyor_ab'):
            devices['conveyor_ab'] = self.factory.conveyor_ab
        if hasattr(self.factory, 'conveyor_bc'):
            devices['conveyor_bc'] = self.factory.conveyor_bc
        if hasattr(self.factory, 'conveyor_cq'):
            devices['conveyor_cq'] = self.factory.conveyor_cq
        if hasattr(self.factory, 'stations') and 'QualityCheck' in self.factory.stations:
            devices['QualityCheck'] = self.factory.stations['QualityCheck']
        def agv_action_sequence_proc():
            for idx, act in enumerate(actions):
                act_type = act.get('type')
                args = act.get('args', {})
                feedback = ""
                success = False
                # move: args: {target_point: str}
                if act_type == 'move':
                    # ÊîØÊåÅ‰∏§ÁßçÊ†ºÂºèÔºöÂùêÊ†á‰ΩçÁΩÆÊàñË∑ØÂæÑÁÇπÂêçÁß∞
                    if 'target_point' in args:
                        # ‰ΩøÁî®Ë∑ØÂæÑÁÇπÂêçÁß∞ÔºàÊé®ËçêÊñπÂºèÔºâ
                        target_point = args['target_point']
                        success, feedback = yield from agv.move_to(target_point)
                    else:
                        feedback = f"moveÂëΩ‰ª§Áº∫Â∞ëtarget_pointÂèÇÊï∞"
                        success = False
                # load: args: {device_id, buffer_type}
                elif act_type == 'load':
                    device_id = args.get('device_id')
                    buffer_type = args.get('buffer_type')
                    device = devices.get(device_id)
                    if device is None:
                        feedback = f"Êú™ÊâæÂà∞ËÆæÂ§á{device_id}"
                    else:
                        s, f, _ = yield from agv.load_from(device, buffer_type)
                        feedback = f
                        success = s
                # unload: args: {device_id, buffer_type}
                elif act_type == 'unload':
                    device_id = args.get('device_id')
                    buffer_type = args.get('buffer_type')
                    device = devices.get(device_id)
                    if device is None:
                        feedback = f"Êú™ÊâæÂà∞ËÆæÂ§á{device_id}"
                    else:
                        s, f, _ = yield from agv.unload_to(device, buffer_type)
                        feedback = f
                        success = s
                else:
                    feedback = f"Êú™Áü•Âä®‰ΩúÁ±ªÂûã: {act_type}"
                # ÂèçÈ¶à
                resp = SystemResponse(timestamp=env.now, command_id=command_id, response=f"[{idx+1}/{len(actions)}] {act_type}: {feedback}").model_dump_json()
                self.mqtt_client.publish(AGENT_RESPONSES_TOPIC, resp)
                # Ëã•Â§±Ë¥•Âàô‰∏≠Êñ≠ÂêéÁª≠
                if not success:
                    break
        # ÂêØÂä®‰ªøÁúüËøõÁ®ã
        env.process(agv_action_sequence_proc())

    def _handle_request_maintenance(self, device_id: str, params: Dict[str, Any]):
        """Handle maintenance request commands."""
        maintenance_type = params.get("maintenance_type")
        if not maintenance_type:
            logger.error("request_maintenance command missing 'maintenance_type' parameter")
            return
            
        logger.info(f"Requesting {maintenance_type} maintenance for {device_id}")
        
        # Use the factory's maintenance handling system
        diagnosis_result = self.factory.handle_maintenance_request(device_id, maintenance_type)
        
        if diagnosis_result.is_correct:
            logger.info(f"‚úÖ Correct diagnosis for {device_id}, repair time: {diagnosis_result.repair_time:.1f}s")
        else:
            logger.warning(f"‚ùå Incorrect diagnosis for {device_id}, penalty time: {diagnosis_result.repair_time:.1f}s")
            if diagnosis_result.affected_devices:
                logger.warning(f"   Affected devices: {', '.join(diagnosis_result.affected_devices)}")
        
        return diagnosis_result

    def _handle_inspect_device(self, device_id: str, params: Dict[str, Any]):
        """Handle device inspection commands."""
        logger.info(f"Inspecting device {device_id}")
        
        if not hasattr(self.factory, 'fault_system'):
            logger.error("Factory does not have fault system available")
            return None
            
        # Use the fault system's inspect function
        detailed_status = self.factory.fault_system.inspect_device(device_id)
        
        if detailed_status:
            logger.info(f"‚úÖ Device {device_id} inspection completed")
            # ÂèëÂ∏ÉÊ£ÄÊü•ÁªìÊûú‰æõagent‰ΩøÁî®
            self._publish_inspection_result(device_id, detailed_status)
        else:
            logger.warning(f"‚ùå Device {device_id} inspection failed")
        
        return detailed_status

    def _handle_skip_repair_time(self, device_id: str, params: Dict[str, Any]):
        """Handle skip repair time commands."""
        logger.info(f"Attempting to skip repair time for {device_id}")
        
        if not hasattr(self.factory, 'fault_system'):
            logger.error("Factory does not have fault system available")
            return False
            
        # Use the fault system's skip function
        success = self.factory.fault_system.skip_repair_time(device_id)
        
        if success:
            logger.info(f"‚úÖ Successfully skipped repair time for {device_id}")
        else:
            logger.warning(f"‚ùå Failed to skip repair time for {device_id}")
        
        return success

    def _handle_get_available_devices(self, target: str, params: Dict[str, Any]):
        """Handle get available devices commands."""
        logger.info("Retrieving available devices list")
        
        if not hasattr(self.factory, 'fault_system'):
            logger.error("Factory does not have fault system available")
            return []
            
        # Get available devices from fault system
        available_devices = self.factory.fault_system.get_available_devices()
        
        logger.info(f"‚úÖ Available devices: {', '.join(available_devices)}")
        
        # Publish available devices via MQTT
        self._publish_available_devices(available_devices)
        
        return available_devices
        
    def _handle_emergency_stop(self, device_id: str, params: Dict[str, Any]):
        """Handle emergency stop commands."""
        logger.info(f"Emergency stop requested for {device_id}")
        
        success = False
        
        # Handle station emergency stop
        if device_id in self.factory.stations:
            station = self.factory.stations[device_id]
            if hasattr(station, 'emergency_stop'):
                station.emergency_stop()
                success = True
            else:
                # Fallback: force station to idle state
                from src.simulation.entities.base import DeviceStatus
                station.status = DeviceStatus.MAINTENANCE
                logger.info(f"‚úÖ Station {device_id} emergency stopped (forced to maintenance mode)")
                success = True
        
        # Handle AGV emergency stop
        elif device_id in self.factory.agvs:
            agv = self.factory.agvs[device_id]
            if hasattr(agv, 'emergency_stop'):
                agv.emergency_stop()
                success = True
            else:
                # Fallback: force AGV to stop
                agv.is_moving = False
                logger.info(f"‚úÖ AGV {device_id} emergency stopped")
                success = True
        
        # Handle factory-wide emergency stop
        elif device_id == "factory":
            logger.info("üö® Factory-wide emergency stop initiated")
            # Stop all stations
            for station_id, station in self.factory.stations.items():
                if hasattr(station, 'emergency_stop'):
                    station.emergency_stop()
                else:
                    from src.simulation.entities.base import DeviceStatus
                    station.status = DeviceStatus.MAINTENANCE
            
            # Stop all AGVs
            for agv_id, agv in self.factory.agvs.items():
                if hasattr(agv, 'emergency_stop'):
                    agv.emergency_stop()
                else:
                    agv.is_moving = False
            
            success = True
        
        else:
            logger.error(f"‚ùå Unknown device for emergency stop: {device_id}")
            
        if success:
            logger.info(f"‚úÖ Emergency stop completed for {device_id}")
        else:
            logger.error(f"‚ùå Emergency stop failed for {device_id}")
        
        return success
        
    def _handle_adjust_priority(self, order_id: str, params: Dict[str, Any]):
        """Handle order priority adjustment commands."""
        new_priority = params.get("priority")
        if not new_priority:
            logger.error("adjust_priority command missing 'priority' parameter")
            return False
            
        logger.info(f"Adjusting priority of order {order_id} to {new_priority}")
        
        # Validate priority value
        valid_priorities = ["low", "medium", "high"]
        if new_priority not in valid_priorities:
            logger.error(f"Invalid priority '{new_priority}'. Valid priorities: {valid_priorities}")
            return False
        
        success = False
        
        # Try to find and update the order in the order generator
        if hasattr(self.factory, 'order_generator'):
            order_generator = self.factory.order_generator
            
            # Look for the order in active orders
            if hasattr(order_generator, 'active_orders'):
                for order in order_generator.active_orders:
                    if order.order_id == order_id:
                        old_priority = order.priority
                        order.priority = new_priority
                        
                        # Recalculate deadline based on new priority
                        if hasattr(order_generator, '_calculate_deadline'):
                            order.deadline = order_generator._calculate_deadline(new_priority, order.quantity)
                        
                        logger.info(f"‚úÖ Order {order_id} priority changed from {old_priority} to {new_priority}")
                        success = True
                        break
            
            # If not found in active orders, check pending orders
            if not success and hasattr(order_generator, 'pending_orders'):
                for order in order_generator.pending_orders:
                    if order.order_id == order_id:
                        old_priority = order.priority
                        order.priority = new_priority
                        
                        # Recalculate deadline
                        if hasattr(order_generator, '_calculate_deadline'):
                            order.deadline = order_generator._calculate_deadline(new_priority, order.quantity)
                        
                        logger.info(f"‚úÖ Order {order_id} priority changed from {old_priority} to {new_priority}")
                        success = True
                        break
        
        # Also try to update in KPI calculator if it tracks orders
        if hasattr(self.factory, 'kpi_calculator'):
            kpi_calculator = self.factory.kpi_calculator
            if hasattr(kpi_calculator, 'update_order_priority'):
                kpi_calculator.update_order_priority(order_id, new_priority)
        
        if not success:
            logger.error(f"‚ùå Order {order_id} not found or could not be updated")
        
        return success
        
    def _handle_reroute_order(self, order_id: str, params: Dict[str, Any]):
        """Handle order rerouting commands."""
        target_station_id = params.get("target_station_id")
        if not target_station_id:
            logger.error("reroute_order command missing 'target_station_id' parameter")
            return False
            
        logger.info(f"Rerouting order {order_id} to {target_station_id}")
        
        # Validate target station exists
        if target_station_id not in self.factory.stations:
            logger.error(f"Target station '{target_station_id}' does not exist")
            return False
        
        success = False
        
        # Try to find the order and reroute it
        if hasattr(self.factory, 'order_generator'):
            order_generator = self.factory.order_generator
            
            # Look for the order in active orders
            if hasattr(order_generator, 'active_orders'):
                for order in order_generator.active_orders:
                    if order.order_id == order_id:
                        # Check if the order has a route or current station
                        if hasattr(order, 'current_station'):
                            old_station = order.current_station
                            order.current_station = target_station_id
                            logger.info(f"‚úÖ Order {order_id} rerouted from {old_station} to {target_station_id}")
                            success = True
                        elif hasattr(order, 'route'):
                            # Modify the route to include the target station
                            if isinstance(order.route, list):
                                # Insert target station at the beginning of remaining route
                                order.route.insert(0, target_station_id)
                            else:
                                # Simple case: set route to target station
                                order.route = [target_station_id]
                            logger.info(f"‚úÖ Order {order_id} route updated to include {target_station_id}")
                            success = True
                        else:
                            # Create a new route attribute if it doesn't exist
                            order.next_station = target_station_id
                            logger.info(f"‚úÖ Order {order_id} next station set to {target_station_id}")
                            success = True
                        break
        
        # If the order is currently being processed at a station, we might need to stop it
        if success:
            target_station = self.factory.stations[target_station_id]
            
            # Notify the target station about incoming order (if supported)
            if hasattr(target_station, 'notify_incoming_order'):
                target_station.notify_incoming_order(order_id)
            
            # Update KPI calculator if it tracks order routing
            if hasattr(self.factory, 'kpi_calculator'):
                kpi_calculator = self.factory.kpi_calculator
                if hasattr(kpi_calculator, 'update_order_route'):
                    kpi_calculator.update_order_route(order_id, target_station_id)
        
        if not success:
            logger.error(f"‚ùå Order {order_id} not found or could not be rerouted")
        
        return success

    def _publish_inspection_result(self, device_id: str, detailed_status):
        """Publish device inspection result via MQTT."""
        topic = f"factory/inspection/{device_id}/result"
        message = {
            "device_id": device_id,
            "timestamp": self.factory.env.now,
            "status": detailed_status.dict()
        }
        
        try:
            self.mqtt_client.publish(topic, json.dumps(message))
            logger.debug(f"Published inspection result for {device_id}")
        except Exception as e:
            logger.error(f"Failed to publish inspection result: {e}")

    def _publish_available_devices(self, available_devices):
        """Publish available devices list via MQTT."""
        topic = "factory/devices/available"
        message = {
            "timestamp": self.factory.env.now,
            "available_devices": available_devices
        }
        
        try:
            self.mqtt_client.publish(topic, json.dumps(message))
            logger.debug("Published available devices list")
        except Exception as e:
            logger.error(f"Failed to publish available devices: {e}")


================================================
File: src/agent_interface/multi_line_command_handler.py
================================================
# src/agent_interface/multi_line_command_handler.py
import json
import logging
from typing import Dict, Any, Optional

from config.schemas import AgentCommand, SystemResponse
from src.utils.mqtt_client import MQTTClient
from src.utils.topic_manager import TopicManager

logger = logging.getLogger(__name__)

class MultiLineCommandHandler:
    """
    Handles MQTT commands for a multi-line factory environment.
    It subscribes to a wildcard topic and parses the line_id from the topic.
    """
    
    def __init__(self, factory, mqtt_client: MQTTClient, topic_manager: TopicManager):
        """
        Args:
            factory: The multi-line Factory instance.
            mqtt_client: The MQTT client to subscribe to commands.
            topic_manager: The TopicManager to generate and parse topics.
        """
        self.factory = factory
        self.mqtt_client = mqtt_client
        self.topic_manager = topic_manager
        
        # Subscribe to a wildcard topic for all lines
        command_topic = self.topic_manager.get_agent_command_topic_wildcard()
        self.mqtt_client.subscribe(command_topic, self._handle_command_message)
        logger.info(f"MultiLineCommandHandler initialized and subscribed to {command_topic}")

    def _handle_command_message(self, topic: str, payload: bytes):
        """
        Callback for incoming MQTT command messages.
        Parses the topic to get line_id and device_id, then validates the payload.
        """
        try:
            # Parse the topic to extract line_id and device_id
            parsed_topic = self.topic_manager.parse_agent_command_topic(topic)
            if not parsed_topic:
                logger.error(f"Could not parse command topic: {topic}")
                return

            line_id = parsed_topic['line_id']
            # device_id is now expected in the command payload's target field
            
            # Parse JSON payload
            command_data = json.loads(payload.decode('utf-8'))
            
            try:
                # Validate using Pydantic schema
                command = AgentCommand.model_validate(command_data)
            except Exception as e:
                msg = f"Failed to validate command: {e}"    
                logger.error(msg)
                self._publish_response(line_id, command_data.get("command_id"), msg)
                return
            
            # No need to check command.target against topic-derived device_id anymore

            logger.debug(f"Received valid command for line '{line_id}': {command.action} for {command.target}")
            
            # Route the command to the appropriate handler
            self._execute_command(line_id, command)
            
        except Exception as e:
            msg = f"Failed to process command: {e}"
            logger.error(msg)
            # We might not have line_id if topic parsing fails, so publish to a general error topic
            self._publish_response(None, command_data.get("command_id"), msg)

    def _execute_command(self, line_id: str, command: AgentCommand):
        """
        Executes a validated command by calling the appropriate method on the correct line.
        """
        action = command.action
        params = command.params
        target_device_id = command.target
        command_id = command.command_id

        # Get the correct production line from the factory
        line = self.factory.lines.get(line_id)
        if not line:
            msg = f"Production line '{line_id}' not found."
            logger.error(msg)
            self._publish_response(line_id, command_id, msg)
            return

        try:
            if action == "move":
                self._handle_move_agv(line, target_device_id, params, command_id)
            elif action == "load":
                self._handle_load_agv(line, target_device_id, params, command_id)
            elif action == "unload":
                self._handle_unload_agv(line, target_device_id, params, command_id)
            elif action == "charge":
                self._handle_charge_agv(line, target_device_id, params, command_id)
            elif action == "get_result":
                self._handle_get_result(line_id, params, command_id)
            else:
                msg = f"Unknown action: {action}"
                logger.warning(msg)
                self._publish_response(line_id, command_id, msg)
                
        except Exception as e:
            msg = f"Failed to execute command {action}: {e}"
            logger.error(msg)
            self._publish_response(line_id, command_id, msg)

    def _handle_move_agv(self, line, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        target_point = params.get("target_point")
        if not target_point:
            self._publish_response(line.name, command_id, "'target_point' missing in move command.")
            return
            
        agv = line.agvs.get(agv_id)
        if not agv:
            self._publish_response(line.name, command_id, f"AGV '{agv_id}' not found in line '{line.name}'.")
            return
            
        def move_process():
            success, message = yield from agv.move_to(target_point)
            self._publish_response(line.name, command_id, message)
        
        self.factory.env.process(move_process())

    def _handle_load_agv(self, line, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        
        if agv_id not in line.agvs:
            msg = f"AGV {agv_id} not found in this line"
            logger.error(msg)
            self._publish_response(line.name, command_id, f"AGV {agv_id} not found in line {line.name}")
            return
        agv = line.agvs.get(agv_id)

        # Get device and buffer from AGV's position mapping
        point_ops = agv.get_point_operations(agv.current_point)
        if not point_ops or not point_ops.get('device'):
            msg = f"No device can be operated for {agv_id} at position {agv.current_point}"
            logger.error(msg)
            self._publish_response(line.name, command_id, msg)
            return
        
        device_id = point_ops['device']
        buffer_type = point_ops.get('buffer')  # May be None for some devices

        device = self._find_device(line, device_id)
        if not device:
            self._publish_response(line.name, command_id, f"Device '{device_id}' not found in line '{line.name}' or factory.")
            return

        def load_process():
            product_id = params.get("product_id", None) if device_id == "RawMaterial" else None
            success, message, _ = yield from agv.load_from(device, buffer_type, product_id)
            self._publish_response(line.name, command_id, message)
            return success, message
        
        self.factory.env.process(load_process())

    def _handle_unload_agv(self, line, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        
        if agv_id not in line.agvs:
            msg = f"AGV {agv_id} not found in this line"
            logger.error(msg)
            self._publish_response(line.name, command_id, f"AGV {agv_id} not found in line {line.name}")
            return
        agv = line.agvs.get(agv_id)

        # Get device and buffer from AGV's position mapping
        point_ops = agv.get_point_operations(agv.current_point)
        if not point_ops or not point_ops.get('device'):
            msg = f"No device mapping found for AGV {agv_id} at position {agv.current_point}"
            logger.error(msg)
            self._publish_response(line.name, command_id, msg)
            return
        
        device_id = point_ops['device']
        buffer_type = point_ops.get('buffer')  # May be None for some devices

        device = self._find_device(line, device_id)
        if not device:
            self._publish_response(line.name, command_id, f"Device {device_id} not found in line {line.name} or factory.")
            return

        def unload_process():
            success, message, _ = yield from agv.unload_to(device, buffer_type)
            self._publish_response(line.name, command_id, message)
        
        self.factory.env.process(unload_process())

    def _handle_charge_agv(self, line, agv_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        agv = line.agvs.get(agv_id)
        if not agv:
            self._publish_response(line.name, command_id, f"AGV '{agv_id}' not found in line '{line.name}'.")
            return
        
        target_level = params.get("target_level")
        if not target_level:
            self._publish_response(line.name, command_id, "'target_level' missing in charge command, will charge to 80 by default")
            target_level = 80.0

        def charge_process():
            success, message = yield from agv.voluntary_charge(target_level)
            self._publish_response(line.name, command_id, message)
        
        self.factory.env.process(charge_process())

    def _find_device(self, line, device_id: str):
        """
        Find a device first in the line, then in factory global devices.
        Returns the device if found, None otherwise.
        """
        # First try to find in the current line
        device = line.all_devices.get(device_id)
        if device:
            return device
        
        # If not found in line, search in factory global devices (warehouse, raw_material)
        device = self.factory.all_devices.get(device_id)
        return device

    def _handle_get_result(self, line_id: str, params: Dict[str, Any], command_id: Optional[str] = None):
        """Handle get result command to retrieve and publish KPI scores."""
        if self.factory.kpi_calculator:
            final_scores = self.factory.kpi_calculator.get_final_score()
            
            # ÊâìÂç∞Âà∞ÁªàÁ´ØÔºà‰∏éfactory.print_final_scores()Áõ∏ÂêåÊ†ºÂºèÔºâ
            print(f"\n{'='*60}")
            print("üèÜ ÊúÄÁªàÁ´ûËµõÂæóÂàÜ")
            print(f"{'='*60}")
            print(f"Áîü‰∫ßÊïàÁéáÂæóÂàÜ (40%): {final_scores['efficiency_score']:.2f}")
            print(f"  - ËÆ¢ÂçïÂÆåÊàêÁéá: {final_scores['efficiency_components']['order_completion']:.1f}%")
            print(f"  - Áîü‰∫ßÂë®ÊúüÊïàÁéá: {final_scores['efficiency_components']['production_cycle']:.1f}%")
            print(f"  - ËÆæÂ§áÂà©Áî®Áéá: {final_scores['efficiency_components']['device_utilization']:.1f}%")
            print(f"\nË¥®Èáè‰∏éÊàêÊú¨ÂæóÂàÜ (30%): {final_scores['quality_cost_score']:.2f}")
            print(f"  - ‰∏ÄÊ¨°ÈÄöËøáÁéá: {final_scores['quality_cost_components']['first_pass_rate']:.1f}%")
            print(f"  - ÊàêÊú¨ÊïàÁéá: {final_scores['quality_cost_components']['cost_efficiency']:.1f}%")
            print(f"\nAGVÊïàÁéáÂæóÂàÜ (30%): {final_scores['agv_score']:.2f}")
            print(f"  - ÂÖÖÁîµÁ≠ñÁï•ÊïàÁéá: {final_scores['agv_components']['charge_strategy']:.1f}%")
            print(f"  - ËÉΩÊïàÊØî: {final_scores['agv_components']['energy_efficiency']:.1f}%")
            print(f"  - AGVÂà©Áî®Áéá: {final_scores['agv_components']['utilization']:.1f}%")
            print(f"\nÊÄªÂæóÂàÜ: {final_scores['total_score']:.2f}")
            print(f"{'='*60}\n")
            
            # ÂèëÂ∏ÉÂæóÂàÜÂà∞MQTTÔºà‰∏çÂåÖÂê´ÂéüÂßãÊåáÊ†áÔºâ
            result_topic = self.topic_manager.get_result_topic()
            
            scores_only = {
                "total_score": round(final_scores['total_score'], 2),
                "efficiency_score": round(final_scores['efficiency_score'], 2),
                "efficiency_components": {k: round(v, 2) for k, v in final_scores['efficiency_components'].items()},
                "quality_cost_score": round(final_scores['quality_cost_score'], 2),
                "quality_cost_components": {k: round(v, 2) for k, v in final_scores['quality_cost_components'].items()},
                "agv_score": round(final_scores['agv_score'], 2),
                "agv_components": {k: round(v, 2) for k, v in final_scores['agv_components'].items()}
            }
            result_json = json.dumps(scores_only)
            
            self.mqtt_client.publish(result_topic, result_json)
            print(f"‚úÖ ÁªìÊûúÂ∑≤ÂèëÂ∏ÉÂà∞ {result_topic}")
            
            # Also send a response to confirm the action was completed
            self._publish_response(line_id, command_id, f"Results published to {result_topic}")
        else:
            print("‚ùå KPIËÆ°ÁÆóÂô®Êú™ÂàùÂßãÂåñ")
            self._publish_response(line_id, command_id, "KPI calculator not initialized")

    def _publish_response(self, line_id: Optional[str], command_id: Optional[str], response_message: str):
        """Publishes a response to the appropriate MQTT topic."""
        response_topic = self.topic_manager.get_agent_response_topic(line_id)
        response_payload = SystemResponse(
            timestamp=self.factory.env.now,
            command_id=command_id,
            response=response_message
        ).model_dump_json()
        self.mqtt_client.publish(response_topic, response_payload)




================================================
File: src/game_logic/fault_system.py
================================================
# src/game_logic/fault_system.py
import random
import simpy
from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum
from src.utils.mqtt_client import MQTTClient
from config.schemas import DeviceStatus, FaultAlert
import json 
from src.utils.topic_manager import TopicManager

@dataclass
class FaultDefinition:
    """ÁÆÄÂåñÁöÑÊïÖÈöúÂÆö‰πâ"""
    symptom: str
    min_duration: float  # ÊúÄÂ∞èÊïÖÈöúÊåÅÁª≠Êó∂Èó¥ÔºàÁßíÔºâ
    max_duration: float  # ÊúÄÂ§ßÊïÖÈöúÊåÅÁª≠Êó∂Èó¥ÔºàÁßíÔºâ

class FaultType(Enum):
    STATION_FAULT = "station_fault"
    AGV_FAULT = "agv_fault"
    CONVEYOR_FAULT = "conveyor_fault"

class FaultSystem:
    """
    ÁÆÄÂåñÁöÑÊïÖÈöúÁ≥ªÁªüÔºöÂÜªÁªìËÆæÂ§áÔºåËøá‰∏ÄÊÆµÊó∂Èó¥Ëß£ÂÜª
    """
    
    def __init__(self, env: simpy.Environment, devices: Dict, mqtt_client: Optional[MQTTClient] = None, topic_manager: Optional[TopicManager] = None, line_id: Optional[str] = None, kpi_calculator=None, **kwargs):
        self.env = env
        self.factory_devices = devices
        self.mqtt_client = mqtt_client
        self.topic_manager = topic_manager
        self.line_id = line_id
        self.kpi_calculator = kpi_calculator
        self.active_faults: Dict[str, 'SimpleFault'] = {}
        self.fault_processes: Dict[str, simpy.Process] = {}
        self.pending_agv_faults: Dict[str, FaultType] = {} # Êñ∞Â¢ûÔºöÁî®‰∫éÊåÇËµ∑ÂØπÁπÅÂøôAGVÁöÑÊïÖÈöú
        
        self.fault_definitions = {
            FaultType.STATION_FAULT: FaultDefinition(
                symptom="Station Vibration",
                min_duration=20.0,
                max_duration=60.0
            ),
            FaultType.AGV_FAULT: FaultDefinition(
                symptom="AGV Stuck",
                min_duration=20.0,
                max_duration=60.0
            ),
            FaultType.CONVEYOR_FAULT: FaultDefinition(
                symptom="Conveyor Stuck",
                min_duration=20.0,
                max_duration=60.0
            )
        }
        
        # ÊïÖÈöúÊ≥®ÂÖ•ÂèÇÊï∞
        self.fault_injection_interval = kwargs.get('fault_injection_interval', (120, 300))
        
        # ÂºÄÂßãÊïÖÈöúÊ≥®ÂÖ•ËøáÁ®ã
        self.env.process(self.run_fault_injection())

    def run_fault_injection(self):
        """ÊïÖÈöúÊ≥®ÂÖ•‰∏ªÂæ™ÁéØ"""
        while True:
            # Á≠âÂæÖ‰∏ãÊ¨°ÊïÖÈöúÊ≥®ÂÖ•
            wait_time = random.uniform(*self.fault_injection_interval)
            yield self.env.timeout(wait_time)
            
            # Ê≥®ÂÖ•ÈöèÊú∫ÊïÖÈöú
            self.inject_random_fault()

    def inject_random_fault(self, target_device: Optional[str] = None, fault_type: Optional[FaultType] = None):
        """Ê≥®ÂÖ•ÈöèÊú∫ÊïÖÈöú"""
        if fault_type is None:
            fault_type = random.choice(list(FaultType))
        
        if target_device is None:
            target_device = self._select_target_device(fault_type)
        
        # Check if the device has already been injected with a fault
        if target_device in self.active_faults:
            print(f"[{self.env.now:.2f}] ‚ö†Ô∏è  ËÆæÂ§á {target_device} Â∑≤ÊúâÊïÖÈöúÔºåË∑≥ËøáÊ≥®ÂÖ•")
            return
        
        device = self.factory_devices[target_device]

        # For AGVs, if they are not idle, pend the fault instead of skipping
        if fault_type == FaultType.AGV_FAULT and device.status != DeviceStatus.IDLE:
            if target_device not in self.pending_agv_faults:
                self.pending_agv_faults[target_device] = fault_type
                print(f"[{self.env.now:.2f}] ‚ö†Ô∏è  AGV {target_device} is currently {device.status.value}, fault injection is pending.")
            else:
                print(f"[{self.env.now:.2f}] ‚ö†Ô∏è  AGV {target_device} already has a pending fault, skipping new injection.")
            return

        # Inject the fault now for non-AGVs or idle AGVs
        self._inject_fault_now(target_device, fault_type)

    def _select_target_device(self, fault_type: FaultType) -> str:
        """Ê†πÊçÆÊïÖÈöúÁ±ªÂûãÈÄâÊã©ÁõÆÊ†áËÆæÂ§á"""
        if fault_type == FaultType.AGV_FAULT:
            # AGVÊïÖÈöú
            agv_devices = [dev_id for dev_id in self.factory_devices.keys() if "AGV" in dev_id]
            return random.choice(agv_devices) if agv_devices else "AGV_1"
        elif fault_type == FaultType.CONVEYOR_FAULT:
            # ‰º†ÈÄÅÂ∏¶ÊïÖÈöú except Conveyor_CQ
            conveyor_devices = [dev_id for dev_id in self.factory_devices.keys() if "Conveyor" in dev_id and "CQ" not in dev_id]
            return random.choice(conveyor_devices) if conveyor_devices else "Conveyor_AB"
        else:
            # Â∑•Á´ôÊïÖÈöú
            station_devices = [dev_id for dev_id in self.factory_devices.keys() 
                             if "Station" in dev_id or "Quality" in dev_id]
            return random.choice(station_devices) if station_devices else "StationA"

    def _inject_fault_now(self, device_id: str, fault_type: FaultType, duration: Optional[float] = None):
        """Á´ãÂç≥Ê≥®ÂÖ•ÊïÖÈöúÁöÑÊ†∏ÂøÉÈÄªËæë"""
        if device_id in self.active_faults:
            # This check is important for when called externally
            print(f"[{self.env.now:.2f}] ‚ö†Ô∏è  ËÆæÂ§á {device_id} Â∑≤ÊúâÊïÖÈöúÔºåÊó†Ê≥ïÊ≥®ÂÖ•Êñ∞ÊïÖÈöú")
            return

        if duration is None:
            fault = self._create_fault(device_id, fault_type)
        else: # For manual injection with specified duration
             fault = SimpleFault(
                device_id=device_id,
                fault_type=fault_type,
                symptom=self.fault_definitions[fault_type].symptom,
                duration=duration,
                start_time=self.env.now
            )

        self.active_faults[device_id] = fault
        
        device = self.factory_devices[device_id]
        
        # Special handling for conveyors - interrupt processing instead of main action
        if hasattr(device, 'interrupt_all_processing'):
            interrupted_count = device.interrupt_all_processing()
            print(f"[{self.env.now:.2f}] üö´ {device_id}: Interrupted {interrupted_count} processing operations")
        # For other devices, interrupt the main action
        elif hasattr(device, 'action') and device.action and device.action.is_alive and device.action != self.env.active_process:
            device.action.interrupt("Fault injected")
        
        device.set_status(DeviceStatus.FAULT)
        device.publish_status(f"[{self.env.now:.2f}] {device_id}: Fault injected: {fault.symptom}")
        
        # If the device has a fault symptom attribute, set it
        if hasattr(device, 'fault_symptom'):
            device.fault_symptom = fault.symptom
        
        print(f"[{self.env.now:.2f}] üí• ÊïÖÈöúÊ≥®ÂÖ•: {device_id}")
        print(f"   - ÁóáÁä∂: {fault.symptom}")
        print(f"   - ÊåÅÁª≠Êó∂Èó¥: {fault.duration:.1f}s")
        print(f"   - üö´ ËÆæÂ§áÂ∑≤ÂÜªÁªì")
        
        self._send_fault_alert(device_id, fault)
        
        # Report maintenance cost to KPI calculator (fault detection)
        if self.kpi_calculator:
            # Assume correct diagnosis for auto-generated faults
            self.kpi_calculator.add_maintenance_cost(device_id, fault.symptom, was_correct_diagnosis=True)
        
        # Start fault process
        fault_process = self.env.process(self._run_fault_process(fault))
        self.fault_processes[device_id] = fault_process

    def _create_fault(self, device_id: str, fault_type: FaultType) -> 'SimpleFault':
        """ÂàõÂª∫ÁÆÄÂçïÊïÖÈöúÂÆû‰æã"""
        definition = self.fault_definitions[fault_type]
        duration = random.uniform(definition.min_duration, definition.max_duration)
        
        return SimpleFault(
            device_id=device_id,
            fault_type=fault_type,
            symptom=definition.symptom,
            duration=duration,
            start_time=self.env.now
        )

    def _run_fault_process(self, fault: 'SimpleFault'):
        """ËøêË°åÊïÖÈöúËøáÁ®ãÔºàÁ≠âÂæÖÊïÖÈöúÊåÅÁª≠Êó∂Èó¥Ôºâ"""
        try:
            # Wait for the fault duration
            yield self.env.timeout(fault.duration)
            
            # Fault duration ended, automatically unfreeze the device
            self._clear_fault(fault.device_id)
            
        except simpy.Interrupt:
            # Fault process interrupted (e.g., manual repair)
            print(f"[{self.env.now:.2f}] üîß ÊïÖÈöúËøáÁ®ãË¢´‰∏≠Êñ≠: {fault.device_id}")

    def _clear_fault(self, device_id: str):
        """Clear the fault and unfreeze the device"""
        if device_id in self.active_faults:
            fault = self.active_faults[device_id]
            fault_symptom = fault.symptom
            # Calculate recovery time before deleting the fault
            recovery_time = self.env.now - fault.start_time
            
            del self.active_faults[device_id]
            
            # Clear the fault process
            if device_id in self.fault_processes:
                del self.fault_processes[device_id]
            
            # Unfreeze the device
            device = self.factory_devices[device_id]
            if hasattr(device, 'recover'):
                device.recover()
            else:
                # Fallback to default if no specific recover method
                device.set_status(DeviceStatus.IDLE)
            
            # Clear the fault symptom
            if hasattr(device, 'fault_symptom'):
                device.fault_symptom = None
            
            print(f"[{self.env.now:.2f}] ‚úÖ ÊïÖÈöúËá™Âä®Ëß£Èô§: {device_id}")
            print(f"   - üîì ËÆæÂ§áÂ∑≤Ëß£ÂÜª")
            
            # Report recovery time to KPI calculator
            if self.kpi_calculator and recovery_time > 0:
                self.kpi_calculator.add_fault_recovery_time(recovery_time)
                
                # Track AGV fault time specifically
                if fault.fault_type == FaultType.AGV_FAULT:
                    self.kpi_calculator.update_agv_fault_time(device_id, self.line_id, recovery_time)
            
            # Send recovery alert
            self._send_recovery_alert(device_id, fault_symptom)

    def _send_fault_alert(self, device_id: str, fault: 'SimpleFault'):
        """ÂèëÈÄÅÊïÖÈöúË≠¶Êä•"""
        alert_data = FaultAlert(
            timestamp=self.env.now,
            device_id=device_id,
            alert_type="fault_injected",
            symptom=fault.symptom,
            fault_type=fault.fault_type.value,
            estimated_duration=fault.duration,
            message=f"Device {device_id} has fault: {fault.symptom}"
        )
        
        if self.mqtt_client and self.topic_manager and self.line_id:
            topic = self.topic_manager.get_fault_alert_topic(self.line_id)
            self.mqtt_client.publish(topic, alert_data.model_dump_json())

    def _send_recovery_alert(self, device_id: str, last_symptom: str):
        """ÂèëÈÄÅÊÅ¢Â§çË≠¶Êä•"""
        alert_data = FaultAlert(
            timestamp=self.env.now,
            device_id = device_id,
            alert_type = "fault_recovered",
            symptom= last_symptom,
            fault_type="unknown", # We don't know the fault type anymore after clearing it
            estimated_duration= 0.0,
            message=f"Device {device_id} fault has been automatically recovered"
        )
        
        if self.mqtt_client and self.topic_manager and self.line_id:
            topic = self.topic_manager.get_fault_alert_topic(self.line_id)
            self.mqtt_client.publish(topic, alert_data.model_dump_json())

    def force_clear_fault(self, device_id: str) -> bool:
        """Âº∫Âà∂Ê∏ÖÈô§ÊïÖÈöúÔºàË∞ÉËØïÁî®Ôºâ"""
        if device_id in self.active_faults:
            # ‰∏≠Êñ≠ÊïÖÈöúËøáÁ®ã
            if device_id in self.fault_processes:
                self.fault_processes[device_id].interrupt()
            
            # Ê∏ÖÈô§ÊïÖÈöú
            self._clear_fault(device_id)
            print(f"[{self.env.now:.2f}] üîß Âº∫Âà∂Ê∏ÖÈô§ÊïÖÈöú: {device_id}")
            return True
        
        print(f"[{self.env.now:.2f}] ‚ùå ËÆæÂ§á {device_id} Êó†ÊïÖÈöúÈúÄË¶ÅÊ∏ÖÈô§")
        return False

    def get_device_symptom(self, device_id: str) -> Optional[str]:
        """Ëé∑ÂèñËÆæÂ§áÁóáÁä∂"""
        if device_id in self.active_faults:
            return self.active_faults[device_id].symptom
        return None

    def is_device_faulty(self, device_id: str) -> bool:
        """Ê£ÄÊü•ËÆæÂ§áÊòØÂê¶ÊúâÊïÖÈöú"""
        return device_id in self.active_faults

    def get_fault_info(self, device_id: str) -> Optional[Dict]:
        """Ëé∑ÂèñËÆæÂ§áÊïÖÈöú‰ø°ÊÅØ"""
        if device_id in self.active_faults:
            fault = self.active_faults[device_id]
            remaining_time = fault.duration - (self.env.now - fault.start_time)
            return {
                "device_id": device_id,
                "fault_type": fault.fault_type.value,
                "symptom": fault.symptom,
                "duration": fault.duration,
                "remaining_time": max(0, remaining_time),
                "start_time": fault.start_time
            }
        return None

    def get_all_fault_info(self) -> List[Dict]:
        """Ëé∑ÂèñÊâÄÊúâÊïÖÈöú‰ø°ÊÅØ"""
        fault_info_list = []
        for device_id in self.active_faults.keys():
            fault_info = self.get_fault_info(device_id)
            if fault_info is not None:
                fault_info_list.append(fault_info)
        return fault_info_list

    def get_available_devices(self) -> List[str]:
        """Ëé∑ÂèñÂèØÁî®ËÆæÂ§áÂàóË°®ÔºàÊó†ÊïÖÈöúÁöÑËÆæÂ§áÔºâ"""
        available = []
        for device_id, device in self.factory_devices.items():
            if device_id not in self.active_faults and device.status != DeviceStatus.FAULT:
                available.append(device_id)
        return available

    def get_fault_stats(self) -> Dict:
        """Ëé∑ÂèñÊïÖÈöúÁªüËÆ°‰ø°ÊÅØ"""
        return {
            "active_faults": len(self.active_faults),
            "fault_devices": list(self.active_faults.keys()),
            "available_devices": len(self.get_available_devices()),
            "total_devices": len(self.factory_devices)
        }

@dataclass
class SimpleFault:
    """ÁÆÄÂåñÁöÑÊïÖÈöúÂÆû‰æã"""
    device_id: str
    fault_type: FaultType
    symptom: str
    duration: float  # ÊïÖÈöúÊåÅÁª≠Êó∂Èó¥ÔºàÁßíÔºâ
    start_time: float

# ‰∏∫‰∫ÜÂêëÂêéÂÖºÂÆπÔºå‰øùÁïôÂéüÊúâÁöÑÁ±ªÂêç
FaultSystem = FaultSystem
ActiveFault = SimpleFault


================================================
File: src/game_logic/kpi_calculator.py
================================================
# src/game_logic/kpi_calculator.py
import simpy
from typing import Dict, List, Optional, Any, TYPE_CHECKING
from dataclasses import dataclass, field

from config.schemas import KPIUpdate, NewOrder
from config.topics import KPI_UPDATE_TOPIC
from src.utils.mqtt_client import MQTTClient
from src.utils.topic_manager import TopicManager

if TYPE_CHECKING:
    from src.simulation.entities.product import Product

@dataclass
class ProductTracking:
    """Track individual product for production cycle calculation."""
    product_id: str
    product_type: str  # P1, P2, P3
    order_id: str
    start_time: float  # When order is created
    theoretical_time: float  # Based on product type
    production_start_time: Optional[float] = None  # When it actually enters production (StationA)
    end_time: Optional[float] = None  # When it exits the production line

@dataclass
class OrderTracking:
    """Track individual order progress for KPI calculation."""
    order_id: str
    created_at: float
    deadline: float
    items_total: int
    items_completed: int = 0
    completed_at: Optional[float] = None
    is_on_time: Optional[bool] = None
    total_cost: float = 0.0
    products: List[ProductTracking] = field(default_factory=list)

@dataclass
class ProductionStats:
    """Production statistics for KPI calculation."""
    total_orders: int = 0
    completed_orders: int = 0
    on_time_orders: int = 0
    total_products: int = 0
    quality_passed_products: int = 0
    scrapped_products: int = 0
    
    # Time tracking
    total_production_time: float = 0.0
    total_simulation_time: float = 0.0
    weighted_production_cycle_sum: float = 0.0  # Sum of (actual/theoretical) ratios
    
    # Cost tracking
    material_costs: float = 0.0
    energy_costs: float = 0.0
    maintenance_costs: float = 0.0
    scrap_costs: float = 0.0
    
    # Fault tracking
    total_faults: int = 0
    correct_diagnoses: int = 0
    total_recovery_time: float = 0.0
    
    # Device utilization (device_id -> working_time)
    device_working_time: Dict[str, float] = field(default_factory=dict)
    device_total_time: Dict[str, float] = field(default_factory=dict)
    
    # AGV metrics
    agv_active_charges: int = 0  # ‰∏ªÂä®ÂÖÖÁîµÊ¨°Êï∞
    agv_passive_charges: int = 0  # Ë¢´Âä®ÂÖÖÁîµÊ¨°Êï∞
    agv_total_charge_time: float = 0.0  # ÊÄªÂÖÖÁîµÊó∂Èó¥
    agv_completed_tasks: int = 0  # AGVÂÆåÊàêÁöÑ‰ªªÂä°Êï∞
    agv_transport_time: Dict[str, float] = field(default_factory=dict)  # AGVËøêËæìÊó∂Èó¥
    agv_fault_time: Dict[str, float] = field(default_factory=dict)  # AGVÊïÖÈöúÊó∂Èó¥
    agv_charge_time: Dict[str, float] = field(default_factory=dict)  # AGVÂÖÖÁîµÊó∂Èó¥

class KPICalculator:
    """
    Calculates KPIs according to PRD 3.4 Section 2.8 specifications.
    
    KPI categories defined in PRD:
    - Production Efficiency: Order completion rate, production cycle, device utilization
    - Quality & Cost: First pass rate, total production cost
    - AGV Efficiency: Charge strategy, energy efficiency, utilization
    
    Note: Competition scoring weights are not specified in PRD, so we use:
    - Production Efficiency: 40%
    - Quality & Cost: 30%
    - AGV Efficiency: 30%
    """
    
    def __init__(self, env: simpy.Environment, mqtt_client: Optional[MQTTClient] = None, topic_manager: Optional[TopicManager] = None, config: Optional[Dict[str, Any]] = None):
        self.env = env
        self.mqtt_client = mqtt_client
        self.topic_manager = topic_manager
        self.stats = ProductionStats()
        self.active_orders: Dict[str, OrderTracking] = {}
        self.completed_orders: List[OrderTracking] = []
        
        # Load configuration from YAML if not provided
        if config is None:
            from src.utils.config_loader import load_factory_config
            config = load_factory_config()
        
        # Load KPI weights from config
        kpi_weights = config.get('kpi_weights', {})
        self.weights = {
            'production_efficiency': kpi_weights.get('production_efficiency', 0.40),
            'quality_cost': kpi_weights.get('quality_cost', 0.30),
            'agv_efficiency': kpi_weights.get('agv_efficiency', 0.30)
        }
        
        # Load sub-weights for each KPI category
        self.efficiency_weights = kpi_weights.get('efficiency_components', {
            'order_completion': 0.40,
            'production_cycle': 0.40,
            'device_utilization': 0.20
        })
        
        self.quality_cost_weights = kpi_weights.get('quality_cost_components', {
            'first_pass_rate': 0.40,
            'cost_efficiency': 0.60
        })
        
        self.agv_weights = kpi_weights.get('agv_components', {
            'charge_strategy': 0.30,
            'energy_efficiency': 0.40,
            'utilization': 0.30
        })
        
        # Load cost parameters from config
        kpi_costs = config.get('kpi_costs', {})
        self.cost_parameters = {
            'material_cost_per_product': kpi_costs.get('material_cost_per_product', {'P1': 10.0, 'P2': 15.0, 'P3': 20.0}),
            'energy_cost_per_second': kpi_costs.get('energy_cost_per_second', 0.1),
            'energy_cost_multiplier_peak': kpi_costs.get('energy_cost_multiplier_peak', 1.5),
            'maintenance_cost_base': kpi_costs.get('maintenance_cost_base', 8.0),
            'scrap_cost_multiplier': kpi_costs.get('scrap_cost_multiplier', 0.8),
        }
        
        # Load theoretical production times from order generator config
        order_gen_config = config.get('order_generator', {})
        self.theoretical_production_times = order_gen_config.get('theoretical_production_times', {
            'P1': 160.0,
            'P2': 200.0,
            'P3': 250.0
        })
        
        # Track active products
        self.active_products: Dict[str, ProductTracking] = {}
        
        # Track last KPI state for change detection
        self.last_kpi_hash = None
        
        # Track active faults count
        self._active_faults_count = 0

    def _check_and_publish_kpi_update(self):
        """Calculate KPIs and publish only if changed."""
        kpi_update = self.calculate_current_kpis()
        
        # Create a hash of key KPI values to detect changes
        kpi_hash = (
            round(kpi_update.order_completion_rate, 2),
            round(kpi_update.average_production_cycle, 2),
            round(kpi_update.total_production_cost, 2),
            kpi_update.total_orders,
            kpi_update.completed_orders,
            kpi_update.total_products,
            kpi_update.active_faults,
            round(kpi_update.charge_strategy_efficiency, 2),
            round(kpi_update.agv_energy_efficiency, 2)
        )
        
        # Only publish if KPIs have changed
        if kpi_hash != self.last_kpi_hash:
            self.last_kpi_hash = kpi_hash
            self._publish_kpi_update(kpi_update)

    def register_new_order(self, order: NewOrder):
        """Register a new order for tracking."""
        total_items = sum(item.quantity for item in order.items)
        
        order_tracking = OrderTracking(
            order_id=order.order_id,
            created_at=order.created_at,
            deadline=order.deadline,
            items_total=total_items
        )
        
        self.active_orders[order.order_id] = order_tracking
        self.stats.total_orders += 1
        
        # Trigger KPI update on new order
        self._check_and_publish_kpi_update()
        
        # Create product tracking for each product (material costs will be added when taken from warehouse)
        for item in order.items:
            # Create product tracking for each product
            for i in range(item.quantity):
                product_id = f"{order.order_id}_P{item.product_type}_{i}"
                product_tracking = ProductTracking(
                    product_id=product_id,
                    product_type=item.product_type,
                    order_id=order.order_id,
                    start_time=self.env.now,  # Order creation time
                    theoretical_time=self.theoretical_production_times[item.product_type]
                )
                order_tracking.products.append(product_tracking)
                self.active_products[product_id] = product_tracking

    def complete_order_item(self, order_id: str, product_type: Optional[str] = None, passed_quality: bool = True):
        """Mark an order item as completed."""
        if order_id not in self.active_orders:
            return
            
        order = self.active_orders[order_id]
        order.items_completed += 1
        self.stats.total_products += 1
        
        # Find the product tracking and update it
        if product_type:
            for product in order.products:
                if product.product_type == product_type and product.end_time is None:
                    product.end_time = self.env.now
                    
                    # Use production_start_time if available, otherwise fall back to start_time
                    actual_start = product.production_start_time if product.production_start_time is not None else product.start_time
                    actual_time = product.end_time - actual_start
                    theoretical_time = product.theoretical_time
                    
                    # Add to weighted production cycle sum only for passed products
                    if theoretical_time > 0 and passed_quality:
                        self.stats.weighted_production_cycle_sum += actual_time / theoretical_time
                    
                    # Remove from active products
                    if product.product_id in self.active_products:
                        del self.active_products[product.product_id]
                    break
        
        if passed_quality:
            self.stats.quality_passed_products += 1
        else:
            self.stats.scrapped_products += 1
            # Add scrap cost
            if product_type:
                scrap_cost = self.cost_parameters['material_cost_per_product'][product_type] * self.cost_parameters['scrap_cost_multiplier']
                order.total_cost += scrap_cost
                self.stats.scrap_costs += scrap_cost
        
        # Check if order is complete
        if order.items_completed >= order.items_total:
            self._complete_order(order)

    def _complete_order(self, order: OrderTracking):
        """Complete an order and update statistics."""
        order.completed_at = self.env.now
        order.is_on_time = order.completed_at <= order.deadline
        
        self.stats.completed_orders += 1
        if order.is_on_time:
            self.stats.on_time_orders += 1
            
        # Add to production time tracking
        production_time = order.completed_at - order.created_at
        self.stats.total_production_time += production_time
        
        # Move to completed orders
        self.completed_orders.append(order)
        del self.active_orders[order.order_id]
        
        # Trigger KPI update on order completion
        self._check_and_publish_kpi_update()

    def add_energy_cost(self, device_id: str, line_id: Optional[str], duration: float, is_peak_hour: bool = False):
        """Add energy costs for device operation."""
        # Validate parameters to help debug
        try:
            if not isinstance(duration, (int, float)):
                raise TypeError(f"Duration must be a number, got {type(duration).__name__}: {duration}")
        except Exception as e:
            print(f"[DEBUG] add_energy_cost called with: device_id={device_id}, line_id={line_id}, duration={duration}, is_peak_hour={is_peak_hour}")
            raise
        
        base_cost = duration * self.cost_parameters['energy_cost_per_second']
        if is_peak_hour:
            base_cost *= self.cost_parameters['energy_cost_multiplier_peak']
        
        self.stats.energy_costs += base_cost
        
        # Update device working time with line_id to avoid conflicts
        # Note: Some devices (Station) only use this method to track working time
        internal_device_key = f"{line_id}_{device_id}" if line_id else device_id
        if internal_device_key not in self.stats.device_working_time:
            self.stats.device_working_time[internal_device_key] = 0.0
        self.stats.device_working_time[internal_device_key] += duration
        
        # Trigger KPI update on energy cost change
        self._check_and_publish_kpi_update()

    def add_maintenance_cost(self, _device_id: str, _maintenance_type: str, was_correct_diagnosis: bool):
        """Add maintenance costs and track diagnosis accuracy."""
        base_cost = self.cost_parameters['maintenance_cost_base']
        
        # Penalty for incorrect diagnosis
        if not was_correct_diagnosis:
            base_cost *= 2.0  # Double cost for wrong diagnosis
            
        self.stats.maintenance_costs += base_cost
        self.stats.total_faults += 1
        
        if was_correct_diagnosis:
            self.stats.correct_diagnoses += 1
        
        # Trigger KPI update on maintenance event
        self._check_and_publish_kpi_update()
    
    def update_active_faults_count(self, count: int):
        """Update the active faults count (called by FaultSystem)"""
        self._active_faults_count = count
        self._check_and_publish_kpi_update()
    
    def mark_production_start(self, product: 'Product'):
        """Mark when a product actually starts production (enters first station)."""
        # Find the product tracking by order_id and product_type
        order_id = product.order_id
        product_type = product.product_type
        
        # Look for the first unstarted product of this type in this order
        for tracking_id, tracking in self.active_products.items():
            if (tracking.order_id == order_id and 
                tracking.product_type == product_type and 
                tracking.production_start_time is None):
                tracking.production_start_time = self.env.now
                print(f"[KPI] Product {product.id} (tracking: {tracking_id}) started production at {self.env.now:.2f}")
                break
    
    def register_agv_charge(self, agv_id: str, line_id: Optional[str], is_active: bool, charge_duration: float):
        """Register AGV charging event."""
        if is_active:
            self.stats.agv_active_charges += 1
        else:
            self.stats.agv_passive_charges += 1
        
        self.stats.agv_total_charge_time += charge_duration
        
        # Update AGV charge time tracking with line_id to avoid conflicts
        internal_agv_key = f"{line_id}_{agv_id}" if line_id else agv_id
        if internal_agv_key not in self.stats.agv_charge_time:
            self.stats.agv_charge_time[internal_agv_key] = 0.0
        self.stats.agv_charge_time[internal_agv_key] += charge_duration
        
        # Trigger KPI update on charging event
        self._check_and_publish_kpi_update()
    
    def register_agv_task_complete(self, _agv_id: str, _line_id: Optional[str] = None):
        """Register AGV task completion."""
        self.stats.agv_completed_tasks += 1
        
        # Trigger KPI update on AGV task completion
        self._check_and_publish_kpi_update()
    
    def update_agv_transport_time(self, agv_id: str, line_id: Optional[str], transport_time: float):
        """Update AGV transport time."""
        internal_agv_key = f"{line_id}_{agv_id}" if line_id else agv_id
        if internal_agv_key not in self.stats.agv_transport_time:
            self.stats.agv_transport_time[internal_agv_key] = 0.0
        self.stats.agv_transport_time[internal_agv_key] += transport_time
        
        # Trigger KPI update on AGV transport time change
        self._check_and_publish_kpi_update()
    
    def update_agv_fault_time(self, agv_id: str, line_id: Optional[str], fault_time: float):
        """Update AGV fault time."""
        internal_agv_key = f"{line_id}_{agv_id}" if line_id else agv_id
        if internal_agv_key not in self.stats.agv_fault_time:
            self.stats.agv_fault_time[internal_agv_key] = 0.0
        self.stats.agv_fault_time[internal_agv_key] += fault_time
        
        # Trigger KPI update on AGV fault time change
        self._check_and_publish_kpi_update()

    def add_fault_recovery_time(self, recovery_time: float):
        """Track fault recovery time for robustness metrics."""
        self.stats.total_recovery_time += recovery_time
        
        # Trigger KPI update on fault recovery
        self._check_and_publish_kpi_update()

    def update_device_utilization(self, device_id: str, line_id: Optional[str], total_time: float):
        """Update device total time for utilization calculation."""
        internal_device_key = f"{line_id}_{device_id}" if line_id else device_id
        self.stats.device_total_time[internal_device_key] = total_time
        # Ensure device has a working_time entry to prevent KeyError
        if internal_device_key not in self.stats.device_working_time:
            self.stats.device_working_time[internal_device_key] = 0.0
        
        # Trigger KPI update on device utilization change
        self._check_and_publish_kpi_update()
    
    def track_device_working_time(self, device_id: str, line_id: Optional[str], duration: float):
        """Track actual working time for a device"""
        internal_device_key = f"{line_id}_{device_id}" if line_id else device_id
        if internal_device_key not in self.stats.device_working_time:
            self.stats.device_working_time[internal_device_key] = 0.0
        self.stats.device_working_time[internal_device_key] += duration
        
        # Trigger KPI update on device working time change
        self._check_and_publish_kpi_update()

    def calculate_current_kpis(self) -> KPIUpdate:
        """Calculate current KPI values according to PRD 3.4 Section 2.8 formulas."""
        current_time = self.env.now
        self.stats.total_simulation_time = current_time
        
        # Production Efficiency Metrics (40%)
        # 1. ËÆ¢ÂçïÂÆåÊàêÁéá (ÊåâÊó∂ÂÆåÊàêËÆ¢ÂçïÊï∞ / ÊÄªËÆ¢ÂçïÊï∞)
        order_completion_rate = (
            (self.stats.on_time_orders / self.stats.total_orders * 100) 
            if self.stats.total_orders > 0 else 0.0
        )
        
        # 2. Âä†ÊùÉÂπ≥ÂùáÁîü‰∫ßÂë®Êúü (ÂÆûÈôÖÊó∂Èó¥‰∏éÁêÜËÆ∫Êó∂Èó¥ÁöÑÊØîÁéá)
        # ÊîπËøõÔºöËÄÉËôë‰∫ßÂìÅÂÆåÊàêÁéáÔºåÈÅøÂÖçÈÄâÊã©ÊÄßÂÆåÊàêÂø´ÈÄü‰∫ßÂìÅÁöÑÁ≠ñÁï•
        base_cycle_ratio = (
            (self.stats.weighted_production_cycle_sum / self.stats.quality_passed_products)
            if self.stats.quality_passed_products > 0 else 0.0
        )
        
        # ËÆ°ÁÆó‰∫ßÂìÅÂÆåÊàêÁéáÔºàÂ∑≤ÂÆåÊàêÁöÑ‰∫ßÂìÅÊï∞ / Â∑≤ÂºÄÂßãÁîü‰∫ßÁöÑ‰∫ßÂìÅÊÄªÊï∞Ôºâ
        total_started_products = len(self.active_products) + self.stats.total_products
        product_completion_rate = (
            self.stats.quality_passed_products / total_started_products
            if total_started_products > 0 else 0.0
        )
        
        # Â∫îÁî®ÂÆåÊàêÁéáÊùÉÈáçÔºöÂÆåÊàêÁéá‰Ωé‰ºöÂ¢ûÂä†Áîü‰∫ßÂë®ÊúüÂÄºÔºàÊÉ©ÁΩöÔºâ
        # Â¶ÇÊûúÂÆåÊàêÁéáÊòØ100%ÔºåÂàô‰∏çÂΩ±ÂìçÔºõÂ¶ÇÊûúÂÆåÊàêÁéáÊòØ50%ÔºåÂàôÂë®ÊúüÂÄºÁøªÂÄç
        if product_completion_rate > 0:
            average_production_cycle = base_cycle_ratio / product_completion_rate
        else:
            average_production_cycle = 0.0  # No production = 0 efficiency
        
        # 3. ÊåâÊó∂‰∫§‰ªòÁéá (Ëøô‰∏™ÊåáÊ†á‰∏éËÆ¢ÂçïÂÆåÊàêÁéáÈáçÂ§çÔºåÂèØÁî®‰∫éÈ¢ùÂ§ñÂàÜÊûê)
        on_time_delivery_rate = (
            (self.stats.on_time_orders / self.stats.completed_orders * 100)
            if self.stats.completed_orders > 0 else 0.0
        )
        
        # Quality Metrics
        first_pass_rate = (
            (self.stats.quality_passed_products / self.stats.total_products * 100)
            if self.stats.total_products > 0 else 0.0
        )
        
        # Device Utilization
        device_utilization = {}
        for device_id in self.stats.device_working_time:
            working_time = self.stats.device_working_time[device_id]
            total_time = self.stats.device_total_time.get(device_id, current_time)
            utilization = (working_time / total_time * 100) if total_time > 0 else 0.0
            device_utilization[device_id] = utilization
        
        average_device_utilization = (
            sum(device_utilization.values()) / len(device_utilization)
            if device_utilization else 0.0
        )
        
        # Cost Control Metrics (30%)
        total_production_cost = (
            self.stats.material_costs + self.stats.energy_costs + 
            self.stats.maintenance_costs + self.stats.scrap_costs
        )
        
        # AGV Metrics
        # ÂÖÖÁîµÁ≠ñÁï•ÊïàÁéá
        total_charges = self.stats.agv_active_charges + self.stats.agv_passive_charges
        charge_strategy_efficiency = (
            (self.stats.agv_active_charges / total_charges * 100)
            if total_charges > 0 else 0.0  # No charging activity = 0 efficiency
        )
        
        # AGVËÉΩÊïàÊØî (ÂÆåÊàê‰ªªÂä°Êï∞ / ÊÄªÂÖÖÁîµÊó∂Èó¥)
        # Êó∂Èó¥Âçï‰ΩçÔºöÁßí
        agv_energy_efficiency = (
            (self.stats.agv_completed_tasks / self.stats.agv_total_charge_time)  # tasks per second of charging
            if self.stats.agv_total_charge_time > 0 else 0.0
        )
        
        # AGVÂà©Áî®Áéá
        agv_utilization = {}
        for agv_id in self.stats.agv_transport_time:
            transport_time = self.stats.agv_transport_time.get(agv_id, 0.0)
            fault_time = self.stats.agv_fault_time.get(agv_id, 0.0)
            charge_time = self.stats.agv_charge_time.get(agv_id, 0.0)
            total_time = current_time - fault_time - charge_time
            
            if total_time > 0:
                # Cap utilization at 100% to handle edge cases
                agv_utilization[agv_id] = min(100.0, transport_time / total_time * 100)
            else:
                agv_utilization[agv_id] = 0.0
        
        average_agv_utilization = (
            sum(agv_utilization.values()) / len(agv_utilization)
            if agv_utilization else 0.0
        )
        
        return KPIUpdate(
            timestamp=round(current_time, 2),
            
            # Production Efficiency (40%)
            order_completion_rate=round(order_completion_rate, 2),
            average_production_cycle=round(average_production_cycle, 2),
            on_time_delivery_rate=round(on_time_delivery_rate, 2),
            device_utilization=round(average_device_utilization, 2),
            
            # Quality Metrics
            first_pass_rate=round(first_pass_rate, 2),
            
            # Cost Control (30%)
            total_production_cost=round(total_production_cost, 2),
            material_costs=round(self.stats.material_costs, 2),
            energy_costs=round(self.stats.energy_costs, 2),
            maintenance_costs=round(self.stats.maintenance_costs, 2),
            scrap_costs=round(self.stats.scrap_costs, 2),
            
            # AGV Efficiency Metrics
            charge_strategy_efficiency=round(charge_strategy_efficiency, 2),
            agv_energy_efficiency=round(agv_energy_efficiency, 2),
            agv_utilization=round(average_agv_utilization, 2),
            
            # Raw Counts
            total_orders=self.stats.total_orders,
            completed_orders=self.stats.completed_orders,
            active_orders=len(self.active_orders),
            total_products=self.stats.total_products,
            active_faults=self._active_faults_count
        )

    def _publish_kpi_update(self, kpi_update: KPIUpdate):
        """Publish KPI update to MQTT."""
        try:
            if self.mqtt_client:
                if self.topic_manager:
                    topic = self.topic_manager.get_kpi_topic()
                else:
                    from config.topics import KPI_UPDATE_TOPIC
                    topic = KPI_UPDATE_TOPIC
                self.mqtt_client.publish(topic, kpi_update.model_dump_json())
                # print(f"[{self.env.now:.2f}] üìä KPI Update published")
        except Exception as e:
            print(f"[{self.env.now:.2f}] ‚ùå Failed to publish KPI update: {e}")
    
    def force_kpi_update(self):
        """Force an immediate KPI update (bypasses change detection)."""
        kpi_update = self.calculate_current_kpis()
        self._publish_kpi_update(kpi_update)
        
        # Update the hash to reflect current state
        self.last_kpi_hash = (
            round(kpi_update.order_completion_rate, 2),
            round(kpi_update.average_production_cycle, 2),
            round(kpi_update.total_production_cost, 2),
            kpi_update.total_orders,
            kpi_update.completed_orders,
            kpi_update.total_products,
            kpi_update.active_faults,
            round(kpi_update.charge_strategy_efficiency, 2),
            round(kpi_update.agv_energy_efficiency, 2)
        )

    def get_final_score(self) -> Dict[str, Any]:
        """Calculate final competition score based on PRD 3.4 Section 2.8 KPIs.
        
        Since PRD 3.4 doesn't specify competition scoring weights, we use:
        - Production Efficiency: 40% (order completion, production cycle, device utilization)
        - Quality & Cost: 30% (first pass rate, total cost)
        - AGV Efficiency: 30% (charge strategy, energy efficiency, utilization)
        """
        kpis = self.calculate_current_kpis()
        
        # Áîü‰∫ßÊïàÁéáËØÑÂàÜ (40%)
        # ÂåÖÂê´ÔºöËÆ¢ÂçïÂÆåÊàêÁéá„ÄÅÂä†ÊùÉÂπ≥ÂùáÁîü‰∫ßÂë®Êúü„ÄÅËÆæÂ§áÂà©Áî®Áéá
        
        # Áîü‰∫ßÂë®ÊúüËØÑÂàÜÔºöÂè™ÊúâÂú®Êúâ‰∫ßÂìÅÁîü‰∫ßÊó∂ÊâçËÆ°ÁÆó
        if self.stats.quality_passed_products > 0 and kpis.average_production_cycle > 0:
            # ÊØîÁéáË∂äÊé•Ëøë1Ë∂äÂ•ΩÔºàÂÆûÈôÖÊó∂Èó¥Êé•ËøëÁêÜËÆ∫Êó∂Èó¥Ôºâ
            production_cycle_score = min(100, 100 / max(1, kpis.average_production_cycle))
        else:
            # Ê≤°ÊúâÁîü‰∫ß‰ªª‰Ωï‰∫ßÂìÅÔºåÂë®ÊúüÊïàÁéá‰∏∫0
            production_cycle_score = 0
        
        efficiency_components = {
            'order_completion': min(100, kpis.order_completion_rate),  # Â∑≤ÁªèÊòØÁôæÂàÜÊØî
            'production_cycle': production_cycle_score,
            'device_utilization': min(100, kpis.device_utilization)  # Â∑≤ÁªèÊòØÁôæÂàÜÊØî
        }
        
        # Â≠êÊùÉÈáçÂàÜÈÖç
        efficiency_score = (
            efficiency_components['order_completion'] * self.efficiency_weights.get('order_completion', 0.4) +
            efficiency_components['production_cycle'] * self.efficiency_weights.get('production_cycle', 0.4) +
            efficiency_components['device_utilization'] * self.efficiency_weights.get('device_utilization', 0.2)
        ) * self.weights['production_efficiency']  # ‰ΩøÁî®ÈÖçÁΩÆÁöÑÊùÉÈáç
        
        # ÊàêÊú¨ÊéßÂà∂ËØÑÂàÜ (30%)
        # Âü∫‰∫éÊÄªÁîü‰∫ßÊàêÊú¨ÔºåÈúÄË¶Å‰∏éÂü∫ÂáÜÊàêÊú¨ÊØîËæÉ
        if self.stats.total_products > 0:
            # Â¶ÇÊûúÊúâÁîü‰∫ß‰∫ßÂìÅÔºåËÆ°ÁÆóÊàêÊú¨ÊïàÁéá
            # Âü∫ÂáÜÊàêÊú¨Ôºö‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑÂπ≥ÂùáÊùêÊñôÊàêÊú¨
            avg_material_cost = sum(self.cost_parameters['material_cost_per_product'].values()) / len(self.cost_parameters['material_cost_per_product'])
            baseline_cost = self.stats.total_products * avg_material_cost
            actual_cost = kpis.total_production_cost
            # ÊàêÊú¨Ë∂ä‰ΩéË∂äÂ•ΩÔºåÊâÄ‰ª•Áî®Âü∫ÂáÜÊàêÊú¨Èô§‰ª•ÂÆûÈôÖÊàêÊú¨
            cost_efficiency = min(100, baseline_cost / max(1, actual_cost) * 100)
        else:
            # Â¶ÇÊûúÊ≤°ÊúâÁîü‰∫ß‰ªª‰Ωï‰∫ßÂìÅ
            if kpis.total_production_cost > 0:
                # ÊúâÊàêÊú¨‰ΩÜÊ≤°Êúâ‰∫ßÂá∫ÔºåÊïàÁéá‰∏∫0
                cost_efficiency = 0
            else:
                # Ê≤°ÊúâÊàêÊú¨‰πüÊ≤°Êúâ‰∫ßÂá∫ÔºåÁªô‰∫à0ÂàÜ
                cost_efficiency = 0
        
        # Ë¥®Èáè‰∏éÊàêÊú¨ËØÑÂàÜ (30%)
        # ÂåÖÂê´Ôºö‰∏ÄÊ¨°ÈÄöËøáÁéáÂíåÊÄªÁîü‰∫ßÊàêÊú¨
        quality_cost_components = {
            'first_pass_rate': min(100, kpis.first_pass_rate),  # Â∑≤ÁªèÊòØÁôæÂàÜÊØî
            'cost_efficiency': cost_efficiency
        }
        
        quality_cost_score = (
            quality_cost_components['first_pass_rate'] * self.quality_cost_weights.get('first_pass_rate', 0.4) +
            quality_cost_components['cost_efficiency'] * self.quality_cost_weights.get('cost_efficiency', 0.6)
        ) * self.weights['quality_cost']  # ‰ΩøÁî®ÈÖçÁΩÆÁöÑÊùÉÈáç
        
        # AGVÊïàÁéáËØÑÂàÜ (30%)
        # ÂåÖÂê´ÔºöÂÖÖÁîµÁ≠ñÁï•ÊïàÁéá„ÄÅAGVËÉΩÊïàÊØî„ÄÅAGVÂà©Áî®Áéá
        agv_components = {
            'charge_strategy': min(100, kpis.charge_strategy_efficiency),  # Â∑≤ÁªèÊòØÁôæÂàÜÊØî
            'energy_efficiency': min(100, kpis.agv_energy_efficiency * 100),  # 0.1 tasks/s = 100ÂàÜ (ÊØèÁßíÂÆåÊàê0.1‰∏™‰ªªÂä°‰∏∫Êª°ÂàÜ)
            'utilization': min(100, kpis.agv_utilization)  # Â∑≤ÁªèÊòØÁôæÂàÜÊØî
        }
        
        # AGVÊïàÁéáÊùÉÈáç
        agv_score = (
            agv_components['charge_strategy'] * self.agv_weights.get('charge_strategy', 0.3) +
            agv_components['energy_efficiency'] * self.agv_weights.get('energy_efficiency', 0.4) +
            agv_components['utilization'] * self.agv_weights.get('utilization', 0.3)
        ) * self.weights['agv_efficiency']
        
        total_score = efficiency_score + quality_cost_score + agv_score
        
        return {
            "efficiency_score": efficiency_score,
            "efficiency_components": efficiency_components,
            "quality_cost_score": quality_cost_score,
            "quality_cost_components": quality_cost_components,
            "agv_score": agv_score,
            "agv_components": agv_components,
            "total_score": total_score,
            "raw_kpis": {
                "order_completion_rate": kpis.order_completion_rate,
                "average_production_cycle": kpis.average_production_cycle,
                "device_utilization": kpis.device_utilization,
                "first_pass_rate": kpis.first_pass_rate,
                "total_production_cost": kpis.total_production_cost,
                "charge_strategy_efficiency": kpis.charge_strategy_efficiency,
                "agv_energy_efficiency": kpis.agv_energy_efficiency,
                "agv_utilization": kpis.agv_utilization
            }
        } 


================================================
File: src/game_logic/order_generator.py
================================================
# src/game_logic/order_generator.py
import random
import uuid
import simpy
from typing import Dict, List, Optional

from config.schemas import NewOrder, OrderItem, OrderPriority
from config.topics import NEW_ORDER_TOPIC
from src.utils.mqtt_client import MQTTClient
from src.simulation.entities.warehouse import RawMaterial
from src.simulation.entities.product import Product
from src.game_logic.kpi_calculator import KPICalculator
from src.utils.topic_manager import TopicManager

class OrderGenerator:
    """
    Generates orders according to PRD 2.4 specifications:
    - Generation interval: 30-60 seconds (uniform random)
    - Order quantity: 1-5 items (weighted: 40%, 30%, 20%, 7%, 3%)
    - Product distribution: P1(60%), P2(30%), P3(10%)
    - Priority distribution: Low(70%), Medium(25%), High(5%)
    """
    
    def __init__(self, env: simpy.Environment, raw_material: RawMaterial, mqtt_client: Optional[MQTTClient] = None, topic_manager: Optional[TopicManager] = None, kpi_calculator: Optional[KPICalculator] = None, **kwargs):
        self.env = env
        self.mqtt_client = mqtt_client
        self.topic_manager = topic_manager
        self.raw = raw_material
        self.kpi_calculator = kpi_calculator
        # Order generation parameters from kwargs
        self.generation_interval_range = kwargs.get('generation_interval_range', (10, 50))
        self.quantity_weights = kwargs.get('quantity_weights', {1: 40, 2: 30, 3: 20, 4: 7, 5: 3})
        self.product_distribution = kwargs.get('product_distribution', {'P1': 60, 'P2': 30, 'P3': 10})
        self.priority_distribution = kwargs.get('priority_distribution', {
            OrderPriority.LOW: 70,
            OrderPriority.MEDIUM: 25, 
            OrderPriority.HIGH: 5
        })
        
        # Theoretical production times for deadline calculation (in seconds)
        self.theoretical_production_times = kwargs.get('theoretical_production_times', {
            'P1': 160,
            'P2': 200,
            'P3': 250
        })
        
        # Priority multipliers for deadline calculation
        self.priority_multipliers = kwargs.get('priority_multipliers', {
            OrderPriority.LOW: 3.0,
            OrderPriority.MEDIUM: 2.0,
            OrderPriority.HIGH: 1.5
        })
        
        # Start the order generation process
        self.env.process(self.run())

    def run(self):
        """Main order generation loop."""
        while True:
            # Wait for next order generation
            wait_time = random.uniform(*self.generation_interval_range)
            yield self.env.timeout(wait_time)
            
            # Generate and publish new order
            order = self._generate_order()
            if order:
                self._publish_order(order)

    def _generate_order(self) -> Optional[NewOrder]:
        """Generate a single order according to PRD specifications."""
        if self.raw.is_full():
            print(f"[{self.env.now:.2f}] ‚ùå Raw material warehouse is full, cannot accept new order")
            return None
        
        order_id = f"order_{uuid.uuid4().hex[:8]}"
        created_at = self.env.now
        
        # Generate order items
        items = self._generate_order_items()
        
        # Determine priority
        priority = self._select_priority()
        
        # Calculate deadline based on priority and theoretical production time
        deadline = self._calculate_deadline(created_at, items, priority)
        
        for item in items:
            self.raw.create_raw_material(item.product_type, order_id)
        
        return NewOrder(
            order_id=order_id,
            created_at=created_at,
            items=items,
            priority=priority,
            deadline=deadline
        )

    def _generate_order_items(self) -> List[OrderItem]:
        """Generate order items with proper quantity and product distribution."""
        # Select order quantity based on weights
        quantity = self._weighted_choice(self.quantity_weights)
        
        items = []
        for _ in range(quantity):
            # Select product type based on distribution
            product_type = self._weighted_choice(self.product_distribution)
            
            # For simplicity, each item has quantity 1
            # In a more complex system, this could vary
            items.append(OrderItem(
                product_type=product_type,
                quantity=1
            ))
        
        return items

    def _select_priority(self) -> OrderPriority:
        """Select order priority based on distribution."""
        return self._weighted_choice(self.priority_distribution)

    def _calculate_deadline(self, created_at: float, items: List[OrderItem], priority: OrderPriority) -> float:
        """Calculate order deadline based on theoretical production time and priority."""
        # Calculate total theoretical production time
        total_time = 0
        for item in items:
            base_time = self.theoretical_production_times[item.product_type]
            total_time += base_time * item.quantity
        
        # Apply priority multiplier
        multiplier = self.priority_multipliers[priority]
        deadline = created_at + (total_time * multiplier)
        
        return deadline

    def _weighted_choice(self, weights_dict: Dict):
        """Select an item based on weighted probabilities."""
        items = list(weights_dict.keys())
        weights = list(weights_dict.values())
        return random.choices(items, weights=weights)[0]

    def _publish_order(self, order: NewOrder):
        """Publish the order to MQTT."""
        try:
            if self.mqtt_client and self.topic_manager:
                topic = self.topic_manager.get_order_topic()
                self.mqtt_client.publish(topic, order.model_dump_json())
            
            # Register order with KPI calculator
            if self.kpi_calculator:
                self.kpi_calculator.register_new_order(order)
            
            # print(f"[{self.env.now:.2f}] üìã New order generated: {order.order_id}")
            # print(f"   - Items: {[(item.product_type, item.quantity) for item in order.items]}")
            # print(f"   - Priority: {order.priority.value}")
            # print(f"   - Deadline: {order.deadline:.1f}s (in {order.deadline - self.env.now:.1f}s)")
        except Exception as e:
            print(f"[{self.env.now:.2f}] ‚ùå Failed to publish order: {e}") 



================================================
File: src/simulation/factory.py
================================================
# src/simulation/factory.py
import simpy
import random
from typing import Dict, List, Tuple, Optional

from src.simulation.entities.conveyor import Conveyor, TripleBufferConveyor
from src.simulation.entities.base import BaseConveyor
from src.simulation.entities.warehouse import Warehouse, RawMaterial
from src.simulation.entities.station import Station
from src.simulation.entities.agv import AGV
from src.simulation.entities.quality_checker import QualityChecker
from src.game_logic.order_generator import OrderGenerator
from src.game_logic.fault_system import FaultSystem
from src.game_logic.kpi_calculator import KPICalculator
from src.utils.mqtt_client import MQTTClient

# Import configuration loader
from src.utils.config_loader import load_factory_config

class Factory:
    """
    The main class that orchestrates the entire factory simulation.
    """
    def __init__(self, layout_config: Dict, mqtt_client: Optional[MQTTClient] = None, no_faults: bool = False):
        self.env = simpy.Environment()
        self.layout = layout_config
        self.mqtt_client = mqtt_client
        self.no_faults_mode = no_faults # Store the flag
        
        self.stations: Dict[str, Station] = {}
        self.agvs: Dict[str, AGV] = {}
        self.conveyors: Dict[str, BaseConveyor] = {}
        
        # Warehouse attributes - will be set during device creation
        self.warehouse: Optional[Warehouse] = None
        self.raw_material: Optional[RawMaterial] = None
        
        # AGV task queue for product transportation
        self.agv_task_queue = simpy.Store(self.env)
        
        # Statistics for scrapped products
        self.scrap_stats = {
            "total_scrapped": 0,
            "scrap_by_station": {},
            "scrap_reasons": {}
        }
        
        # Initialize all_devices dictionary first
        self.all_devices = {}

        # Game logic components will be initialized dynamically
        self.order_generator: Optional[OrderGenerator] = None
        self.fault_system: Optional[FaultSystem] = None
        
        # Initialize KPI calculator early so it can be passed to devices
        self.kpi_calculator = KPICalculator(self.env, self.mqtt_client, None, self.layout)
        
        # Create devices first
        self._create_devices()
        
        # Update all_devices with created devices
        self.all_devices.update(self.stations)
        self.all_devices.update(self.agvs)
        self.all_devices.update(self.conveyors)

        if self.warehouse is not None:
            self.all_devices[self.warehouse.id] = self.warehouse

        if self.raw_material is not None:
            self.all_devices[self.raw_material.id] = self.raw_material
        
        # Create game logic systems from config
        self._create_game_logic_systems()

        # If order generator is not created, some features might not work.
        if not self.order_generator:
            print("‚ö†Ô∏è Order Generator not configured in layout. Order-related features will be disabled.")

        # If fault system is not created, fault features will be disabled.
        if not self.fault_system:
            print("‚ö†Ô∏è Fault System not configured in layout or is disabled. No faults will be generated.")
        
        # Recreate order generator with KPI calculator
        if self.order_generator:
            self._update_order_generator_with_kpi()
        
        # Update all devices with KPI calculator
        self._update_agvs_with_kpi()
        self._update_stations_with_kpi()
        
        # Setup event handlers
        self._setup_event_handlers()
        
        # Start process to update active faults count
        self.env.process(self._update_active_faults_count())
        
        # Start device status publishing
        self._start_status_publishing()
           
        self._bind_conveyors_to_stations()
        self._setup_conveyor_downstreams()

    def _create_devices(self):
        """Instantiates all devices based on the layout configuration."""
        
        for station_cfg in self.layout['stations']:
            # Quality checker station
            if station_cfg['id'] == 'QualityCheck':
                station = QualityChecker(
                    env=self.env,
                    mqtt_client=self.mqtt_client,
                    **station_cfg
                )
                print(f"[{self.env.now:.2f}] üîç Created QualityChecker: {station_cfg['id']}")
            else:
                # create normal station
                station = Station(
                    env=self.env,
                    mqtt_client=self.mqtt_client,
                    **station_cfg
                )
                print(f"[{self.env.now:.2f}] üè≠ Created Station: {station_cfg['id']}")
            
            self.stations[station.id] = station
        
        # create AGV
        for agv_cfg in self.layout['agvs']:
            agv = AGV(
                env=self.env,
                mqtt_client=self.mqtt_client,
                fault_system=self.fault_system,
                kpi_calculator=self.kpi_calculator,
                **agv_cfg
            )
            self.agvs[agv.id] = agv
            print(f"[{self.env.now:.2f}] üöõ Created AGV: {agv_cfg['id']}")
        
        # create conveyor
        for conveyor_cfg in self.layout['conveyors']:
            conveyor_id = conveyor_cfg['id']
            # Common arguments for all conveyors
            common_args = {
                "env": self.env,
                "id": conveyor_id,
                "position": conveyor_cfg['position'],
                "interacting_points": conveyor_cfg['interacting_points'],
                "transfer_time": conveyor_cfg['transfer_time'],
                "mqtt_client": self.mqtt_client,
                "kpi_calculator": self.kpi_calculator
            }
            if conveyor_id == 'Conveyor_CQ':
                conveyor = TripleBufferConveyor(
                    main_capacity=conveyor_cfg['main_capacity'],
                    upper_capacity=conveyor_cfg['upper_capacity'],
                    lower_capacity=conveyor_cfg['lower_capacity'],
                    **common_args
                )
            elif conveyor_id in ['Conveyor_AB', 'Conveyor_BC']:
                conveyor = Conveyor(
                    capacity=conveyor_cfg['capacity'],
                    **common_args
                )
            else:
                raise ValueError(f"Unknown conveyor type: {conveyor_id}")
            
            self.conveyors[conveyor.id] = conveyor
            print(f"[{self.env.now:.2f}] üöõ Created Conveyor: {conveyor_id}")
        
        # create warehouse
        for warehouse_cfg in self.layout['warehouses']:
            # Common arguments for all warehouses
            common_args = {
                "env": self.env,
                "mqtt_client": self.mqtt_client,
                **warehouse_cfg
            }
            if warehouse_cfg['id'] == 'RawMaterial':
                warehouse = RawMaterial(**common_args, kpi_calculator=self.kpi_calculator)
                self.raw_material = warehouse  # Store dedicated reference
            elif warehouse_cfg['id'] == 'Warehouse':
                warehouse = Warehouse(**common_args)
                self.warehouse = warehouse  # Store dedicated reference
            else:
                raise ValueError(f"Unknown warehouse type: {warehouse_cfg['id']}")
            
            print(f"[{self.env.now:.2f}] üè™ Created Warehouse: {warehouse_cfg['id']}")

    def _create_game_logic_systems(self):
        """Dynamically create game logic systems like OrderGenerator and FaultSystem from config."""
        if 'order_generator' in self.layout:
            if self.raw_material:
                og_config = self.layout['order_generator']
                self.order_generator = OrderGenerator(
                    env=self.env,
                    raw_material=self.raw_material,
                    mqtt_client=self.mqtt_client,
                    kpi_calculator=None,  # Will be set later
                    **og_config
                )
                print(f"[{self.env.now:.2f}] üìù Created OrderGenerator with config: {og_config}")
            else:
                print("‚ö†Ô∏è Cannot create OrderGenerator: RawMaterial device not found.")

        if 'fault_system' in self.layout and not self.no_faults_mode:
            fs_config = self.layout['fault_system']
            self.fault_system = FaultSystem(
                env=self.env,
                devices=self.all_devices,
                mqtt_client=self.mqtt_client,
                kpi_calculator=self.kpi_calculator,
                **fs_config
            )
            print(f"[{self.env.now:.2f}] üîß Created FaultSystem with config: {fs_config}")
        elif self.no_faults_mode:
            print("üö´ Fault System Disabled (no-faults mode).")

    def _update_order_generator_with_kpi(self):
        """Update order generator with KPI calculator reference."""
        if self.order_generator and self.kpi_calculator:
            self.order_generator.kpi_calculator = self.kpi_calculator
    
    def _update_agvs_with_kpi(self):
        """Update AGVs with KPI calculator reference."""
        if self.kpi_calculator:
            for agv in self.agvs.values():
                agv.kpi_calculator = self.kpi_calculator
    
    def _update_stations_with_kpi(self):
        """Update stations with KPI calculator reference."""
        if self.kpi_calculator:
            for station in self.stations.values():
                station.kpi_calculator = self.kpi_calculator
    
    def _setup_event_handlers(self):
        """Setup event handlers for order processing and fault handling."""
        # Force initial KPI update
        if self.kpi_calculator:
            self.kpi_calculator.force_kpi_update()

    def get_available_devices(self) -> List[str]:
        """
        Get list of devices that can currently be operated (not frozen).
        """
        if self.fault_system is None:
            print(f"[{self.env.now:.2f}] üö´ Fault System is disabled. No available devices from fault system.")
            return []
        return self.fault_system.get_available_devices()

    def get_device_status(self, device_id: str) -> Dict:
        """Get comprehensive device status including faults."""
        if device_id in self.all_devices:
            device = self.all_devices[device_id]
            detailed_status = device.get_detailed_status()
            
            # Convert to simplified status format for compatibility
            status_dict = {
                'device_id': device_id,
                'device_type': detailed_status.device_type,
                'status': detailed_status.current_status.value,
                'symptom': detailed_status.fault_symptom,
                'temperature': detailed_status.temperature,
                'efficiency_rate': detailed_status.efficiency_rate,
                'can_operate': device.can_operate(),
                'frozen_until': detailed_status.frozen_until
            }
            
            # Add device-specific information
            if device_id in self.stations:
                status_dict.update({
                    'buffer_level': self.stations[device_id].get_buffer_level(),
                    'precision_level': detailed_status.precision_level,
                    'tool_wear_level': detailed_status.tool_wear_level
                })
            elif device_id in self.agvs:
                agv = self.agvs[device_id]
                status_dict.update({
                    'position': {'x': agv.position[0], 'y': agv.position[1]},
                    'battery_level': detailed_status.battery_level,
                    'position_accuracy': detailed_status.position_accuracy,
                    'payload': [p.id for p in agv.payload.items] if hasattr(agv, 'payload') else []
                })
            
            return status_dict
        return {}

    def _start_status_publishing(self):
        """Start processes to publish device status to MQTT."""        
        # Start factory overall status publishing
        self.env.process(self._publish_factory_status())
    
    
    def _publish_factory_status(self):
        """Publish factory overall status every 30 seconds."""
        while True:
            yield self.env.timeout(30.0)  # Publish every 30 seconds
            
            # Create factory status summary
            from config.topics import FACTORY_STATUS_TOPIC
            from config.schemas import FactoryStatus
            
            factory_status = FactoryStatus(
                timestamp=self.env.now,
                total_stations=len(self.stations),
                total_agvs=len(self.agvs),
                active_orders=len(self.kpi_calculator.active_orders),
                total_orders=self.kpi_calculator.stats.total_orders,
                completed_orders=self.kpi_calculator.stats.completed_orders,
                active_faults=len(self.fault_system.active_faults) if self.fault_system else 0,
                simulation_time=self.env.now
            )
            
            try:
                if self.mqtt_client:
                    self.mqtt_client.publish(FACTORY_STATUS_TOPIC, factory_status)
                print(f"[{self.env.now:.2f}] üìä Published factory status: {factory_status.active_orders} active orders, {factory_status.active_faults} faults")
            except Exception as e:
                print(f"[{self.env.now:.2f}] ‚ùå Failed to publish factory status: {e}")

    def _publish_fault_events(self):
        """Publish enhanced fault events to make them more visible."""
        while True:
            yield self.env.timeout(1.0)  # Check for faults every 1 seconds
            
            # If there are active faults, publish them more frequently
            if self.fault_system and self.fault_system.active_faults:
                for device_id, fault in self.fault_system.active_faults.items():
                    # Create a detailed fault alert message
                    device_status = self.get_device_status(device_id)
                    
                    fault_alert = {
                        "device_id": device_id,
                        "fault_type": fault.fault_type.value,
                        "symptom": fault.symptom,
                        "duration_seconds": self.env.now - fault.start_time,
                        "device_status": device_status.get('status'),
                        "can_operate": device_status.get('can_operate', False),
                        "frozen_until": device_status.get('frozen_until'),
                        "timestamp": self.env.now
                    }
                    
                    try:
                        import json
                        if self.mqtt_client:
                            self.mqtt_client.publish(f"factory/alerts/{device_id}", json.dumps(fault_alert))
                        print(f"[{self.env.now:.2f}] üö® Enhanced fault alert published for {device_id}: {fault.symptom}")
                    except Exception as e:
                        print(f"[{self.env.now:.2f}] ‚ùå Failed to publish fault alert: {e}")


    def run(self, until: int):
        """Runs the simulation for a given duration."""
        # print(f"--- Factory simulation starting for {until} seconds ---")
        # print(f"--- Available devices: {', '.join(self.all_devices.keys())} ---")
        # print(f"--- Use 'inspect_device', 'skip_repair_time', 'request_maintenance' commands ---")
        """
        # Core simulation processes are already started in __init__:
        # - Order generation: self.order_generator.run() (auto-started)
        # - Fault injection: self.fault_system.run_fault_injection() (auto-started) 
        # - KPI updates: self.kpi_calculator.run_kpi_updates() (auto-started)
        # - MQTT publishing: self._start_status_publishing() (started in __init__)
        """
        # print(f"--- Active processes: Order Gen, Fault Injection, KPI Updates, MQTT Publishing ---")
        self.env.run(until=until)
        # print("--- Factory simulation finished ---")

    def print_final_scores(self):
        """Print final competition scores. Should be called only when simulation truly ends."""
        if self.kpi_calculator:
            final_scores = self.kpi_calculator.get_final_score()
            print(f"\n{'='*60}")
            print("üèÜ ÊúÄÁªàÁ´ûËµõÂæóÂàÜ")
            print(f"{'='*60}")
            print(f"Áîü‰∫ßÊïàÁéáÂæóÂàÜ (40%): {final_scores['efficiency_score']:.2f}")
            print(f"  - ËÆ¢ÂçïÂÆåÊàêÁéá: {final_scores['efficiency_components']['order_completion']:.1f}%")
            print(f"  - Áîü‰∫ßÂë®ÊúüÊïàÁéá: {final_scores['efficiency_components']['production_cycle']:.1f}%")
            print(f"  - ËÆæÂ§áÂà©Áî®Áéá: {final_scores['efficiency_components']['device_utilization']:.1f}%")
            print(f"\nË¥®Èáè‰∏éÊàêÊú¨ÂæóÂàÜ (30%): {final_scores['quality_cost_score']:.2f}")
            print(f"  - ‰∏ÄÊ¨°ÈÄöËøáÁéá: {final_scores['quality_cost_components']['first_pass_rate']:.1f}%")
            print(f"  - ÊàêÊú¨ÊïàÁéá: {final_scores['quality_cost_components']['cost_efficiency']:.1f}%")
            print(f"\nAGVÊïàÁéáÂæóÂàÜ (30%): {final_scores['agv_score']:.2f}")
            print(f"  - ÂÖÖÁîµÁ≠ñÁï•ÊïàÁéá: {final_scores['agv_components']['charge_strategy']:.1f}%")
            print(f"  - ËÉΩÊïàÊØî: {final_scores['agv_components']['energy_efficiency']:.1f}%")
            print(f"  - AGVÂà©Áî®Áéá: {final_scores['agv_components']['utilization']:.1f}%")
            print(f"\nÊÄªÂæóÂàÜ: {final_scores['total_score']:.2f}")
            print(f"{'='*60}\n")
            
            # Force a final KPI update with final scores
            self.kpi_calculator.force_kpi_update()
    
    def get_final_scores(self) -> Optional[Dict]:
        """Get final competition scores from KPI calculator."""
        if self.kpi_calculator:
            return self.kpi_calculator.get_final_score()
        return None
    
    def get_factory_stats(self) -> Dict:
        """Get comprehensive factory statistics"""
        station_stats = {}
        for station_id, station in self.stations.items():
            if hasattr(station, 'get_processing_stats'):
                station_stats[station_id] = station.get_processing_stats()
        
        agv_stats = {}
        for agv_id, agv in self.agvs.items():
            agv_stats[agv_id] = {
                "status": agv.status.value,
                "position": agv.position,
                "battery_level": getattr(agv, 'battery_level', 100.0),
                "payload_count": len(agv.payload.items)  # Use .items for SimPy Store
            }
        
        return {
            "timestamp": self.env.now,
            "stations": station_stats,
            "agvs": agv_stats,
            "scrap_stats": self.scrap_stats,
            "total_devices": len(self.all_devices),
            "active_transport_tasks": len(self.agv_task_queue.items)
        }

    def _bind_conveyors_to_stations(self):
        """Bind conveyors to stations according to the process flow."""
        # StationA ‚Üí conveyor_ab
        if 'StationA' in self.stations and 'Conveyor_AB' in self.conveyors:
            self.stations['StationA'].downstream_conveyor = self.conveyors['Conveyor_AB']
        # StationB ‚Üí conveyor_bc
        if 'StationB' in self.stations and 'Conveyor_BC' in self.conveyors:
            self.stations['StationB'].downstream_conveyor = self.conveyors['Conveyor_BC']
        # StationC ‚Üí conveyor_cq (TripleBufferConveyor)
        if 'StationC' in self.stations and 'Conveyor_CQ' in self.conveyors:
            self.stations['StationC'].downstream_conveyor = self.conveyors['Conveyor_CQ']

    def _setup_conveyor_downstreams(self):
        """Set downstream stations for conveyors to enable auto-transfer."""
        # conveyor_ab ‚Üí StationB
        if 'StationB' in self.stations and 'Conveyor_AB' in self.conveyors:
            self.conveyors['Conveyor_AB'].set_downstream_station(self.stations['StationB'])
        # conveyor_bc ‚Üí StationC
        if 'StationC' in self.stations and 'Conveyor_BC' in self.conveyors:
            self.conveyors['Conveyor_BC'].set_downstream_station(self.stations['StationC'])
        # conveyor_cq ‚Üí QualityCheck
        if 'QualityCheck' in self.stations and 'Conveyor_CQ' in self.conveyors:
            self.conveyors['Conveyor_CQ'].set_downstream_station(self.stations['QualityCheck'])
    
    def _update_active_faults_count(self):
        """Periodically update the active faults count in KPI calculator."""
        while True:
            # For single-line factory, just count faults from the single FaultSystem
            active_faults_count = 0
            if self.fault_system:
                active_faults_count = len(self.fault_system.active_faults)
            
            # Update KPI calculator with the count
            if self.kpi_calculator:
                self.kpi_calculator.update_active_faults_count(active_faults_count)
            
            # Wait for 1 second before next update
            yield self.env.timeout(1.0)


# Example of how to run the factory simulation
if __name__ == '__main__':
    from config.settings import MQTT_BROKER_HOST, MQTT_BROKER_PORT
    mqtt_client = MQTTClient(
        host=MQTT_BROKER_HOST,
        port=MQTT_BROKER_PORT,
        client_id="factory_test"
    )
    # ËøûÊé•MQTT broker
    mqtt_client.connect()
    print(f"‚úÖ Connected to MQTT broker at {MQTT_BROKER_HOST}:{MQTT_BROKER_PORT}")
    
    # Âä†ËΩΩÈÖçÁΩÆ
    try:
        from src.utils.config_loader import load_factory_config
        layout_config = load_factory_config()
    except Exception as e:
        print(f"‚ùå Failed to load factory configuration: {e}")
        raise e
    
    factory = Factory(layout_config, mqtt_client)
    
    # Simple test - just create the factory and run briefly
    print(f"[{factory.env.now:.2f}] üéâ Factory created successfully!")
    print(f"[{factory.env.now:.2f}] üìä Stations: {list(factory.stations.keys())}")
    print(f"[{factory.env.now:.2f}] üöõ AGVs: {list(factory.agvs.keys())}")
    agv1 = factory.agvs['AGV_1']
    factory.env.process(agv1.move_to('LP1'))

    print(f"[{factory.env.now:.2f}] üõ§Ô∏è  Conveyors: {list(factory.conveyors.keys())}")
    print(f"[{factory.env.now:.2f}] üè™ Warehouses: RawMaterial={factory.raw_material.id if factory.raw_material else None}, Warehouse={factory.warehouse.id if factory.warehouse else None}")
    
    # Test simple simulation for 30 seconds
    factory.run(until=20)


================================================
File: src/simulation/factory_multi.py
================================================
# src/simulation/factory_multi.py
import os
import simpy
from typing import Dict, List, Optional

from src.simulation.line import Line
from src.game_logic.kpi_calculator import KPICalculator
from src.utils.mqtt_client import MQTTClient
from src.simulation.entities.warehouse import Warehouse, RawMaterial
from src.game_logic.order_generator import OrderGenerator
from src.utils.topic_manager import TopicManager

class Factory:
    """
    The main class that orchestrates the entire factory simulation with multiple production lines.
    """
    def __init__(self, layout_config: Dict, mqtt_client: MQTTClient, no_faults: bool = False):
        self.env = simpy.Environment()
        self.layout = layout_config
        self.mqtt_client = mqtt_client
        self.no_faults_mode = no_faults
        
        # Read player name from environment variable
        topic_root =(
            os.getenv("TOPIC_ROOT")
            or os.getenv("USERNAME")
            or os.getenv("USER")
            or "NLDF_TEST"
        )
        self.topic_manager = TopicManager(topic_root)

        self.lines: Dict[str, Line] = {}
        self.raw_material: RawMaterial
        self.warehouse: Warehouse
        self.order_generator: OrderGenerator
        self.kpi_calculator = KPICalculator(self.env, self.mqtt_client, self.topic_manager)

        self.all_devices = {}
        self._create_warehouse_order_generator()
        self._create_production_lines()
        
        # Start process to update active faults count
        self.env.process(self._update_active_faults_count())


    def _create_production_lines(self):
        """Creates all production lines based on the layout configuration."""
        for line_config in self.layout.get('production_lines', []):
            line_name = line_config['name']
            line = Line(
                env=self.env,
                line_name=line_name,
                line_config=line_config,
                mqtt_client=self.mqtt_client,
                topic_manager=self.topic_manager,
                warehouse=self.warehouse,
                raw_material=self.raw_material,
                order_generator=self.order_generator,
                no_faults=self.no_faults_mode,
                kpi_calculator=self.kpi_calculator
            )
            self.lines[line_name] = line
            print(f"[{self.env.now:.2f}] È¶ÉÂΩÆ Created Production Line: {line_name}")

    def _create_warehouse_order_generator(self):
        """Creates the warehouse for the factory."""
        for warehouse_cfg in self.layout.get('warehouses', []):
            common_args = {"env": self.env, "mqtt_client": self.mqtt_client, "topic_manager": self.topic_manager, **warehouse_cfg}
            if warehouse_cfg['id'] == 'RawMaterial':
                self.raw_material = RawMaterial(**common_args, kpi_calculator=self.kpi_calculator)
            elif warehouse_cfg['id'] == 'Warehouse':
                self.warehouse = Warehouse(**common_args)

            if self.raw_material:
                og_config = self.layout.get('order_generator', {})
                self.order_generator = OrderGenerator(
                    env=self.env,
                    raw_material=self.raw_material,
                    mqtt_client=self.mqtt_client,
                    topic_manager=self.topic_manager,
                    kpi_calculator=self.kpi_calculator,
                    **og_config
                )

        # Add global devices to all_devices
        if hasattr(self, 'warehouse') and self.warehouse is not None:
            self.all_devices[self.warehouse.id] = self.warehouse
        if hasattr(self, 'raw_material') and self.raw_material is not None:
            self.all_devices[self.raw_material.id] = self.raw_material

    def get_device_status(self, device_id: str) -> Dict:
        """Get comprehensive device status including faults."""
        for line in self.lines.values():
            if device_id in line.all_devices:
                # This part can be enhanced to call a method on the line object
                # which in turn calls the device. For now, direct access for simplicity.
                device = line.all_devices[device_id]
                return device.get_detailed_status() # Simplified for now
        return {}


    def _update_active_faults_count(self):
        """Periodically update the active faults count in KPI calculator."""
        while True:
            # Count total active faults across all lines
            total_active_faults = 0
            for line in self.lines.values():
                if line.fault_system:
                    total_active_faults += len(line.fault_system.active_faults)
            
            # Update KPI calculator with the total count
            if self.kpi_calculator:
                self.kpi_calculator.update_active_faults_count(total_active_faults)
            
            # Wait for 1 second before next update
            yield self.env.timeout(1.0)
    
    def run(self, until: int):
        """Runs the simulation for a given duration."""
        self.env.run(until=until)


================================================
File: src/simulation/line.py
================================================
# src/simulation/line.py
import simpy
from typing import Dict, List, Optional

from src.simulation.entities.conveyor import Conveyor, TripleBufferConveyor, BaseConveyor
from src.simulation.entities.warehouse import Warehouse, RawMaterial
from src.simulation.entities.station import Station
from src.simulation.entities.agv import AGV
from src.simulation.entities.quality_checker import QualityChecker
from src.game_logic.order_generator import OrderGenerator
from src.game_logic.fault_system import FaultSystem
from src.game_logic.kpi_calculator import KPICalculator
from src.utils.mqtt_client import MQTTClient
from src.utils.topic_manager import TopicManager

class Line:
    """
    Represents a single production line within the factory.
    """
    def __init__(self, env: simpy.Environment, line_name: str, line_config: Dict, 
                 mqtt_client: MQTTClient, topic_manager: TopicManager,
                 warehouse: Warehouse, raw_material: RawMaterial, order_generator: OrderGenerator,
                 kpi_calculator: KPICalculator,
                 no_faults: bool = False):
        self.env = env
        self.name = line_name
        self.config = line_config
        self.mqtt_client = mqtt_client
        self.topic_manager = topic_manager
        self.no_faults_mode = no_faults
        self.fault_system: Optional[FaultSystem] = None

        # Shared resources injected from Factory
        self.warehouse = warehouse
        self.raw_material = raw_material
        self.order_generator = order_generator
        self.kpi_calculator = kpi_calculator
        self.stations: Dict[str, Station] = {}
        self.agvs: Dict[str, AGV] = {}
        self.conveyors: Dict[str, BaseConveyor] = {}
        
        self.agv_task_queue = simpy.Store(self.env)
        self.all_devices = {}

        self._create_devices()
        
        self.all_devices.update(self.stations)
        self.all_devices.update(self.agvs)
        self.all_devices.update(self.conveyors)

        # Update all devices with KPI calculator
        self._update_agvs_with_kpi()
        self._update_stations_with_kpi()
        self._setup_event_handlers()

        self._create_game_logic_systems()
        self._bind_conveyors_to_stations()
        self._setup_conveyor_downstreams()

    def _create_devices(self):
        """Instantiates all devices for this line based on its configuration."""
        for station_cfg in self.config.get('stations', []):
            if station_cfg['id'] == 'QualityCheck':
                station = QualityChecker(env=self.env, mqtt_client=self.mqtt_client, topic_manager=self.topic_manager, line_id=self.name, **station_cfg)
            else:
                station = Station(env=self.env, mqtt_client=self.mqtt_client, topic_manager=self.topic_manager, line_id=self.name, **station_cfg)
            self.stations[station.id] = station

        for agv_cfg in self.config.get('agvs', []):
            # Get agv_operations for this specific AGV
            agv_operations = self.config.get('agv_operations', {}).get(agv_cfg['id'], {})
            agv = AGV(env=self.env, mqtt_client=self.mqtt_client, topic_manager=self.topic_manager, 
                     fault_system=self.fault_system, kpi_calculator=self.kpi_calculator,
                     line_id=self.name, agv_operations=agv_operations, **agv_cfg)
            self.agvs[agv.id] = agv

        for conveyor_cfg in self.config.get('conveyors', []):
            conveyor_id = conveyor_cfg['id']
            common_args = {
                "env": self.env, "id": conveyor_id, "position": conveyor_cfg['position'],
                "interacting_points": conveyor_cfg['interacting_points'],
                "transfer_time": conveyor_cfg['transfer_time'], "mqtt_client": self.mqtt_client,
                "topic_manager": self.topic_manager, "line_id": self.name, "kpi_calculator": self.kpi_calculator
            }
            if conveyor_cfg['id'] == 'Conveyor_CQ':
                conveyor = TripleBufferConveyor(**common_args, main_capacity=conveyor_cfg['main_capacity'], upper_capacity=conveyor_cfg['upper_capacity'], lower_capacity=conveyor_cfg['lower_capacity'])
            else: # Assuming 'Conveyor_AB', 'Conveyor_BC' or similar
                conveyor = Conveyor(**common_args, capacity=conveyor_cfg['capacity'])
            self.conveyors[conveyor_id] = conveyor

    def _create_game_logic_systems(self):
        """Creates game logic systems like FaultSystem for this line."""
        if 'fault_system' in self.config and not self.no_faults_mode:
            fs_config = self.config['fault_system']
            self.fault_system = FaultSystem(self.env, self.all_devices, self.mqtt_client, self.topic_manager, self.name, kpi_calculator=self.kpi_calculator, **fs_config)
    
    def _update_agvs_with_kpi(self):
        """Update AGVs with KPI calculator reference."""
        if self.kpi_calculator:
            for agv in self.agvs.values():
                agv.kpi_calculator = self.kpi_calculator
    
    def _update_stations_with_kpi(self):
        """Update stations with KPI calculator reference."""
        if self.kpi_calculator:
            for station in self.stations.values():
                station.kpi_calculator = self.kpi_calculator
    
    def _setup_event_handlers(self):
        """Setup event handlers for order processing and fault handling."""
        # Force initial KPI update
        if self.kpi_calculator:
            self.kpi_calculator.force_kpi_update()

    def _bind_conveyors_to_stations(self):
        """Bind conveyors to stations according to the process flow."""
        if 'StationA' in self.stations and 'Conveyor_AB' in self.conveyors:
            self.stations['StationA'].downstream_conveyor = self.conveyors['Conveyor_AB']
        if 'StationB' in self.stations and 'Conveyor_BC' in self.conveyors:
            self.stations['StationB'].downstream_conveyor = self.conveyors['Conveyor_BC']
        if 'StationC' in self.stations and 'Conveyor_CQ' in self.conveyors:
            self.stations['StationC'].downstream_conveyor = self.conveyors['Conveyor_CQ']

    def _setup_conveyor_downstreams(self):
        """Set downstream stations for conveyors to enable auto-transfer."""
        if 'StationB' in self.stations and 'Conveyor_AB' in self.conveyors:
            self.conveyors['Conveyor_AB'].set_downstream_station(self.stations['StationB'])
        if 'StationC' in self.stations and 'Conveyor_BC' in self.conveyors:
            self.conveyors['Conveyor_BC'].set_downstream_station(self.stations['StationC'])
        if 'QualityCheck' in self.stations and 'Conveyor_CQ' in self.conveyors:
            self.conveyors['Conveyor_CQ'].set_downstream_station(self.stations['QualityCheck'])




================================================
File: src/simulation/entities/agv.py
================================================
# simulation/entities/agv.py
import simpy
import math
from typing import Tuple, Dict, Optional, List
from src.simulation.entities.base import Vehicle, Device
from src.simulation.entities.product import Product
from src.simulation.entities.quality_checker import QualityChecker
from src.simulation.entities.station import Station
from src.simulation.entities.conveyor import Conveyor, TripleBufferConveyor
from src.simulation.entities.warehouse import RawMaterial, Warehouse
from config.schemas import DeviceStatus, AGVStatus
from src.utils.topic_manager import TopicManager
from config.path_timing import get_travel_time, is_path_available
import logging

logger = logging.getLogger(__name__)

class AGV(Vehicle):
    """
    Represents an Automated Guided Vehicle (AGV). Must be initialized with a position in path_points!

    AGVs are responsible for transporting products between stations.
    
    Attributes:
        battery_level (float): The current battery percentage (0-100).
        payload (List[any]): The list of products currently being carried.
        low_battery_threshold (float): when battery level is below this value, AGV will return to charging point automatically
        charging_point (str): Charging point name, must be in path_points
        charging_speed (float): charging speed (%/second)
        battery_consumption_per_meter (float): every meter move consumes this much battery
        battery_consumption_per_action (float): every action consumes this much battery
    """
    
    def __init__(
        self,
        env: simpy.Environment,
        id: str,
        position: Tuple[int, int],
        path_points: Dict[str, Tuple[int, int]],
        speed_mps: float,
        payload_capacity: int = 1,
        operation_time: float = 1.0,
        battery_level: float = 50.0,
        low_battery_threshold: float = 10.0,  # ‰ΩéÁîµÈáèÈòàÂÄº
        charging_point: str = "P10",  # ÂÖÖÁîµÁÇπÂùêÊ†á(ÂèØ‰∏∫Ë∑ØÂæÑÁÇπÂêçÊàñÂùêÊ†á)
        charging_speed: float = 3.33,  # ÂÖÖÁîµÈÄüÂ∫¶(30ÁßíÂÖÖÊª°)
        battery_consumption_per_meter: float = 0.1,  # ÊØèÁ±≥Ê∂àËÄó0.1%ÁîµÈáè
        battery_consumption_per_action: float = 0.5,  # ÊØèÊ¨°Êìç‰ΩúÊ∂àËÄó0.5%ÁîµÈáè
        fault_system=None, # Injected dependency
        mqtt_client=None,
        kpi_calculator=None,
        topic_manager: Optional[TopicManager] = None,
        line_id: Optional[str] = None,
        agv_operations: Optional[Dict[str, Dict]] = None
    ):
        if position not in path_points.values():
            raise ValueError(f"AGV position {position} not in path_points {path_points}")

        super().__init__(env, id, position, speed_mps, mqtt_client)
        self.topic_manager = topic_manager
        self.line_id = line_id
        self.battery_level = battery_level
        self.payload_capacity = payload_capacity
        self.payload = simpy.Store(env, capacity=payload_capacity)
        self.operation_time = operation_time
        self.fault_system = fault_system
        self.kpi_calculator = kpi_calculator
        self.current_point = list(path_points.keys())[list(path_points.values()).index(position)]
        self.path_points = path_points
        self.agv_operations = agv_operations or {}  # Store AGV-specific operations mapping
        self.target_point = None # current target point if moving
        self.estimated_time = 0.0 # estimated time to complete the task or moving to the target point
        # ÂÖÖÁîµÁõ∏ÂÖ≥Â±ûÊÄß
        self.low_battery_threshold = low_battery_threshold
        self.charging_point = charging_point
        self.charging_speed = charging_speed
        self.battery_consumption_per_meter = battery_consumption_per_meter
        self.battery_consumption_per_action = battery_consumption_per_action
        
        self.stats = {
            "total_distance": 0.0,
            "total_charge_time": 0.0,
            "forced_charge_count": 0,  # Ë¢´Ëø´ÂÖÖÁîµÊ¨°Êï∞ÔºàKPIÊÉ©ÁΩöÔºâ
            "voluntary_charge_count": 0,  # ‰∏ªÂä®ÂÖÖÁîµÊ¨°Êï∞
            "low_battery_interruptions": 0,  # ‰ΩéÁîµÈáè‰∏≠Êñ≠‰ªªÂä°Ê¨°Êï∞
            "tasks_completed": 0,
            "tasks_interrupted": 0
        }

        # Publish initial status upon creation
        self.publish_status("initialized")

    def consume_battery(self, amount: float, reason: str = "operation"):
        """Ê∂àËÄóÁîµÈáè"""
        if amount <= 0:
            return
            
        old_level = self.battery_level
        self.battery_level = max(0.0, self.battery_level - amount)
        
        if old_level > self.low_battery_threshold and self.battery_level <= self.low_battery_threshold:
            msg = f"[{self.env.now:.2f}] üîã {self.id}: Battery low! Current battery: {self.battery_level:.1f}% (Reason: {reason})"
            # ÁîµÈáèÈ¶ñÊ¨°ÈôçÂà∞ÈòàÂÄº‰ª•‰∏ãÊó∂ÂëäË≠¶
            self.publish_status(msg)
            print(msg)

    def is_battery_low(self) -> bool:
        """Ê£ÄÊü•ÁîµÈáèÊòØÂê¶Ëøá‰Ωé"""
        return self.battery_level <= self.low_battery_threshold

    def can_complete_task(self, estimated_travel_time: float = 0.0, estimated_actions: int = 0, target_point: Optional[str] = None) -> bool:
        """È¢Ñ‰º∞ÊòØÂê¶ÊúâË∂≥Â§üÁîµÈáèÂÆåÊàê‰ªªÂä°"""
        # Convert travel time to estimated distance for battery calculation
        estimated_distance = estimated_travel_time * self.speed_mps #max is 20s * 2m/s = 40m
        estimated_consumption = (
            estimated_distance * self.battery_consumption_per_meter + # max is 40m * 0.1 = 4
            estimated_actions * self.battery_consumption_per_action
        )
        # Â¶ÇÊûúÁõÆÊ†áÁÇπÂ∞±ÊòØÂÖÖÁîµÁÇπÔºå‰∏çÈúÄË¶ÅÈ¢ÑÁïôËøîÂõûÂÖÖÁîµÁÇπÁöÑÁîµÈáè
        if target_point == self.charging_point:
            total_needed = estimated_consumption + 1.0  # Âè™ÈúÄË¶Å1%ÂÆâÂÖ®‰ΩôÈáè
            return self.battery_level >= total_needed
            
        if target_point:
        # È¢ÑÁïôÂõûÂà∞ÂÖÖÁîµÁÇπÁöÑÁîµÈáè (‰ΩøÁî®Ë∑ØÂæÑÊó∂Èó¥Ë°®)
            return_time = get_travel_time(target_point, self.charging_point) # roughly 13s
        else:
            return_time = get_travel_time(self.current_point, self.charging_point) 
        if return_time < 0:
            # If no direct path to charging point, use fallback calculation
            return_distance = math.dist(self.position, self.path_points[self.charging_point])
            return_consumption = return_distance * self.battery_consumption_per_meter
        else:
            return_distance = return_time * self.speed_mps # roughly 26m
            return_consumption = return_distance * self.battery_consumption_per_meter # roughly 2.6
        
        total_needed = estimated_consumption + return_consumption + 3.0  # 3%ÂÆâÂÖ®‰ΩôÈáè
        return self.battery_level >= total_needed

    def move_to(self, target_point: str):
        """
        Move to a specific path point using AGV's independent path system.
        
        Args:
            target_point: Path point name (e.g., "P1", "P2")
            
        Returns:
            (success, feedback_message)
        """
        # Wrap the core logic in a process to make it interruptible
        self.action = self.env.process(self._move_to_process(target_point))
        try:
            result = yield self.action
            return result if result else (True, f"ÊàêÂäüÁßªÂä®Âà∞{target_point}")
        except simpy.Interrupt as e:
            msg = f"Movement to {target_point} interrupted: {e.cause}"
            logger.error(f"[{self.env.now:.2f}] ‚ö†Ô∏è  {self.id}: {msg}")
            return False, msg
            
    def _move_to_process(self, target_point: str):
        """The actual process logic for move_to, to be wrapped by self.action."""
        try:
            if not self.can_operate():
                msg = f"Can not move. AGV {self.id} is not available."
                logger.error(f"[{self.env.now:.2f}] ‚ö†Ô∏è  {self.id}: {msg}")
                return False, msg
                
            if target_point not in self.path_points:
                msg = f"Unknown path point {target_point}"
                logger.error(f"[{self.env.now:.2f}] ‚ùå {self.id}: {msg}")
                return False, msg
                
            self.target_point = target_point
    
            # use path timing to get travel time
            travel_time = get_travel_time(self.current_point, target_point)
            if travel_time < 0:
                msg = f"Can not find path from {self.current_point} to {target_point}"
                print(f"[{self.env.now:.2f}] ‚ùå {self.id}: {msg}")
                return False, msg
                
            # check if battery is enough
            # Special case: if target is charging point, only check if we can reach it
            if target_point == self.charging_point:
                distance_to_charging = travel_time * self.speed_mps
                required_battery = distance_to_charging * self.battery_consumption_per_meter + 1.0  # 1% safety margin
                if self.battery_level < required_battery:
                    msg = f"Battery critically low ({self.battery_level:.1f}%), cannot even reach charging point"
                    print(f"[{self.env.now:.2f}] üö® {self.id}: {msg}")
                    return False, msg
            elif not self.can_complete_task(travel_time, 1, target_point):
                msg = f"Battery level is too low to move to {target_point}"
                print(f"[{self.env.now:.2f}] üîã {self.id}: {msg}")
                self.stats["tasks_interrupted"] += 1
                yield self.env.process(self.emergency_charge())
                return False, f"{msg}, emergency charging"
                
            self.set_status(DeviceStatus.MOVING, f"moving to {target_point} from {self.current_point}, estimated time: {travel_time:.1f}s")
            print(f"[{self.env.now:.2f}] üöõ {self.id}: move to path point {target_point} {self.path_points[target_point]} (estimated time: {travel_time:.1f}s)")
            
            # wait for move to complete
            self.estimated_time = travel_time
            yield self.env.timeout(travel_time)
            
            # update position and consume battery
            self.position = self.path_points[target_point]
            self.current_point = target_point
            self.target_point = None
            self.estimated_time = 0.0
            
            # calculate battery consumption based on travel time
            distance = travel_time * self.speed_mps
            self.consume_battery(distance * self.battery_consumption_per_meter, f"ÁßªÂä®Âà∞{target_point}")
            self.consume_battery(self.battery_consumption_per_action, "Ë∑ØÂæÑÁÇπÊìç‰Ωú")
            
            # update statistics
            self.stats["total_distance"] += distance
            self.stats["tasks_completed"] += 1
            
            # Report task completion, transport time, and energy cost to KPI calculator
            if self.kpi_calculator:
                self.kpi_calculator.register_agv_task_complete(self.id, self.line_id)
                self.kpi_calculator.update_agv_transport_time(self.id, self.line_id, travel_time)
                # Add energy cost for AGV movement
                self.kpi_calculator.add_energy_cost(f"AGV_{self.id}", self.line_id, travel_time, is_peak_hour=False)
            
            print(f"[{self.env.now:.2f}] ‚úÖ {self.id}: Âà∞Ëææ {target_point}, ÁîµÈáè: {self.battery_level:.1f}%")
            
            # Before setting to IDLE, check for pending faults
            if self._check_and_trigger_pending_fault():
                return True, f"Arrived at {target_point}, but triggered fault"

            self.set_status(DeviceStatus.IDLE, f"arrived at {target_point}")
            return True, f"Successfully arrived at path point {target_point}, remaining battery: {self.battery_level:.1f}%"
        
        finally:
            self.action = None
    
    def get_point_operations(self, point: str) -> Optional[Dict]:
        """Get the allowed operations and device info for a specific path point."""
        ops = self.agv_operations.get(point)
        if not self.agv_operations:
            print(f"DEBUG: {self.id} has no agv_operations configured")
        elif point not in self.agv_operations:
            print(f"DEBUG: {self.id} has no operations defined for point {point}")
            print(f"DEBUG: Available points: {list(self.agv_operations.keys())}")
        return ops
    
    def load_from(self, device:Device, buffer_type=None, product_id: Optional[str] = None):
        """AGV‰ªéÊåáÂÆöËÆæÂ§á/ÁºìÂÜ≤Âå∫ÂèñË¥ßÔºåÊîØÊåÅÂ§öÁßçËÆæÂ§áÁ±ªÂûãÂíåbuffer_type„ÄÇËøîÂõû(ÊàêÂäü,ÂèçÈ¶à‰ø°ÊÅØ,‰∫ßÂìÅÂØπË±°)
        
        Ê≥®ÊÑèÔºöproduct_id ÂèÇÊï∞Âú®warehouse‰ª•Â§ñËÆæÂ§áÂ∑≤Â∫üÂºÉÔºåÂè™ËÉΩÂèñÁ¨¨‰∏Ä‰∏™‰∫ßÂìÅÔºàFIFOÔºâ
        """
        if not self.can_operate() or self.is_payload_full():
            msg = f"Can not load. AGV {self.id} is not available or payload is full."
            logger.error(f"[{self.env.now:.2f}] ‚ö†Ô∏è  {self.id}: {msg}")
            return False, msg, None
        
        # check battery level
        if self.is_battery_low():
            return False, f"{self.id} battery level is too low ({self.battery_level:.1f}%), can not load", None
            
        product = None
        feedback = ""
        success = False
        
        try:
            # QualityChecker (ÂÖàÊ£ÄÊü•Â≠êÁ±ª)
            if isinstance(device, QualityChecker):
                # Ê†πÊçÆbuffer_typeÈÄâÊã©ÂêàÈÄÇÁöÑbuffer
                if buffer_type == "buffer":
                    target_buffer = device.buffer
                    buffer_name = "buffer"
                elif buffer_type == "output_buffer" or buffer_type is None:
                    # QualityCheckerÈªòËÆ§‰ªéoutput_bufferÂèñË¥ß
                    target_buffer = device.output_buffer
                    buffer_name = "output_buffer"
                else:
                    feedback = f"QualityChecker‰∏çÊîØÊåÅÁöÑbufferÁ±ªÂûã: {buffer_type}"
                    return False, feedback, None
                
                if len(target_buffer.items) == 0:
                    feedback = f"{device.id} {buffer_name}‰∏∫Á©∫ÔºåÊó†Ê≥ïÂèñË¥ß"
                    return False, feedback, None
                    
                # Áªü‰∏Ä‰ΩøÁî® pop() ÊñπÊ≥ïÔºåÂè™ËÉΩÂèñÁ¨¨‰∏Ä‰∏™‰∫ßÂìÅ
                product = yield self.env.process(device.pop(buffer_type))
                success = True
                
            elif isinstance(device, RawMaterial):
                if len(device.buffer.items) == 0:
                    feedback = f"{device.id} buffer‰∏∫Á©∫ÔºåÊó†Ê≥ïÂèñË¥ß"
                    return False, feedback, None
                try:
                    print(f"TEST: agv load from raw material with product_id {product_id}")
                    product = yield self.env.process(device.pop(product_id))
                    success = True
                except ValueError as e:
                    # Â§ÑÁêÜÊ≠£Âú®Âä†Â∑•‰∏≠ÁöÑ‰∫ßÂìÅ‰∏çËÉΩÂèñÁöÑÊÉÖÂÜµ
                    feedback = str(e)
                    return False, feedback, None
            # Station (Áà∂Á±ª)
            elif isinstance(device, Station):
                if len(device.buffer.items) == 0:
                    feedback = f"{device.id} buffer‰∏∫Á©∫ÔºåÊó†Ê≥ïÂèñË¥ß"
                    return False, feedback, None

                # Áªü‰∏Ä‰ΩøÁî® pop() ÊñπÊ≥ïÔºåÂè™ËÉΩÂèñÁ¨¨‰∏Ä‰∏™‰∫ßÂìÅ
                try:
                    product = yield self.env.process(device.pop())
                    success = True
                except ValueError as e:
                    # Â§ÑÁêÜÊ≠£Âú®Âä†Â∑•‰∏≠ÁöÑ‰∫ßÂìÅ‰∏çËÉΩÂèñÁöÑÊÉÖÂÜµ
                    feedback = str(e)
                    return False, feedback, None
                
            # TripleBufferConveyor
            elif isinstance(device, TripleBufferConveyor):
                buffer_name = buffer_type if buffer_type else "main"
                if device.is_empty(buffer_name):
                    feedback = f"{device.id} {buffer_name}ÁºìÂÜ≤Âå∫‰∏∫Á©∫ÔºåÊó†Ê≥ïÂèñË¥ß"
                    return False, feedback, None
                # Áªü‰∏Ä‰ΩøÁî® pop() ÊñπÊ≥ïÔºåÂè™ËÉΩÂèñÁ¨¨‰∏Ä‰∏™‰∫ßÂìÅ
                product = yield self.env.process(device.pop(buffer_name))
                success = True
                
            # Conveyor
            elif isinstance(device, Conveyor):
                if device.is_empty():
                    feedback = f"{device.id}ÁºìÂÜ≤Âå∫‰∏∫Á©∫ÔºåÊó†Ê≥ïÂèñË¥ß"
                    return False, feedback, None

                # Áªü‰∏Ä‰ΩøÁî® pop() ÊñπÊ≥ïÔºåÂè™ËÉΩÂèñÁ¨¨‰∏Ä‰∏™‰∫ßÂìÅ
                product = yield self.env.process(device.pop())
                success = True
                
            else:
                feedback = f"‰∏çÊîØÊåÅÁöÑËÆæÂ§áÁ±ªÂûã: {type(device).__name__}"
                logger.error(feedback)
                return False, feedback, None
                
            # ÊàêÂäüÂèñË¥ßÂêéÁöÑÊìç‰Ωú
            if success and product:
                buffer_desc = f" {buffer_type}" if buffer_type else ""
                product.add_history(self.env.now, f"Loaded onto {self.id} from {device.id}")
                
                self.set_status(DeviceStatus.INTERACTING, f"loading from {device.id}{buffer_desc}")
                yield self.env.timeout(self.operation_time)
                yield self.payload.put(product)
                self.consume_battery(self.battery_consumption_per_action, "ÂèñË¥ßÊìç‰Ωú")
                feedback = f"Â∑≤‰ªé{device.id}{buffer_desc}ÂèñÂá∫‰∫ßÂìÅ{product.id}Âπ∂Ë£ÖËΩΩÂà∞AGVÔºåÂâ©‰ΩôÁîµÈáè: {self.battery_level:.1f}%"
                
        except Exception as e:
            feedback = f"ÂèñË¥ßÂºÇÂ∏∏: {str(e)}"
            success = False
        
        finally:
            self.set_status(DeviceStatus.IDLE)

        return success, feedback, product

    def unload_to(self, device, buffer_type=None):
        """AGVÂ∞Ü‰∫ßÂìÅÂç∏ËΩΩÂà∞ÊåáÂÆöËÆæÂ§á/ÁºìÂÜ≤Âå∫ÔºåÊîØÊåÅÂ§öÁßçËÆæÂ§áÁ±ªÂûãÂíåbuffer_type„ÄÇËøîÂõû(ÊàêÂäü,ÂèçÈ¶à‰ø°ÊÅØ,‰∫ßÂìÅÂØπË±°)"""
        # check if agv can operate
        if not self.can_operate():
                msg = f"Can not unload. AGV {self.id} is not available."
                logger.error(f"[{self.env.now:.2f}] ‚ö†Ô∏è  {self.id}: {msg}")
                return False, msg, None
        
        if device.is_full():
            msg = f"Can not unload. {device.id} is full."
            logger.error(f"[{self.env.now:.2f}] ‚ö†Ô∏è  {self.id}: {msg}")
            return False, msg, None

        
        # Validate operation against AGV operations mapping
        point_ops = self.get_point_operations(self.current_point)
        if point_ops:
            # Check if device matches
            if point_ops.get('device') != device.id:
                msg = f"[{self.env.now:.2f}] ‚ùå {self.id}: Cannot unload to {device.id} at {self.current_point}. Expected device: {point_ops.get('device')}"
                logger.error(msg)
                return False, msg, None
            # Check if unload operation is allowed
            if 'unload' not in point_ops.get('operations', []):
                msg = f"[{self.env.now:.2f}] ‚ùå {self.id}: Unload operation not allowed at {self.current_point}"
                logger.error(msg)
                return False, msg, None
            # Use buffer from mapping if not specified
            if buffer_type is None and 'buffer' in point_ops:
                buffer_type = point_ops['buffer']

        # Ê£ÄÊü•ÁîµÈáè
        if self.is_battery_low():
            return False, f"{self.id}ÁîµÈáèËøá‰Ωé({self.battery_level:.1f}%)ÔºåÊó†Ê≥ïÊâßË°åÂç∏ËΩΩÊìç‰Ωú", None
            
        product = None
        feedback = ""
        success = False
        
        try:
            # Check if AGV has products
            if len(self.payload.items) == 0:
                return False, "AGVË¥ßÁâ©‰∏∫Á©∫ÔºåÊó†Ê≥ïÂç∏ËΩΩ", None
            
            self.set_status(DeviceStatus.INTERACTING, f"unloading to {device.id}")
            
            # Get product from AGV
            product = yield self.payload.get()
            
            # Ê£ÄÊü•‰∫ßÂìÅÁßªÂä®ÊòØÂê¶Á¨¶ÂêàÂ∑•Ëâ∫Ë∑ØÁ∫ø
            if hasattr(product, 'next_move_checker') and hasattr(product, 'update_location'):
                # Ê£ÄÊü•ÁßªÂä®ÊòØÂê¶ÂêàÊ≥ï
                can_move, move_reason = product.next_move_checker(self.env.now, device.id)
                if not can_move:
                    feedback = f"‰∫ßÂìÅÁßªÂä®ËøùÂèçÂ∑•Ëâ∫Ë∑ØÁ∫ø: {move_reason}"
                    yield self.payload.put(product)  # ÊîæÂõû‰∫ßÂìÅ
                    return False, feedback, product
            
            # Try to unload to device
            # QualityChecker (Check subclass first)
            if isinstance(device, QualityChecker):
                if buffer_type == "output_buffer":
                    # Default use output_buffer
                    success = yield self.env.process(device.add_product_to_outputbuffer(product))
                else:
                    success = yield self.env.process(device.add_product_to_buffer(product))
                        
            # Station (Áà∂Á±ª)
            elif isinstance(device, Station) or isinstance(device, Warehouse):
                success = yield self.env.process(device.add_product_to_buffer(product))
                    
            # TripleBufferConveyor (ÂÖàÊ£ÄÊü•Â≠êÁ±ª)
            elif isinstance(device, TripleBufferConveyor):
                buffer_type = buffer_type if buffer_type else "main"
                # SimPy push()‰ºöËá™Âä®ÈòªÂ°ûÁõ¥Âà∞ÊúâÁ©∫Èó¥ÔºåÊó†ÈúÄÊâãÂä®Ê£ÄÊü•is_full
                yield device.push(product, buffer_type)
                success = True
                
            # Conveyor (Áà∂Á±ª)
            elif isinstance(device, Conveyor):
                # SimPy push()‰ºöËá™Âä®ÈòªÂ°ûÁõ¥Âà∞ÊúâÁ©∫Èó¥ÔºåÊó†ÈúÄÊâãÂä®Ê£ÄÊü•is_full
                yield device.push(product)
                success = True
                
            else:
                feedback = f"‰∏çÊîØÊåÅÁöÑËÆæÂ§áÁ±ªÂûã: {type(device).__name__}"
            
            # Áªü‰∏ÄÂ§ÑÁêÜÁªìÊûú
            if success:
                # Êõ¥Êñ∞‰∫ßÂìÅ‰ΩçÁΩÆ
                if hasattr(product, 'update_location'):
                    location_updated = product.update_location(device.id, self.env.now)
                    if not location_updated:
                        print(f"[{self.env.now:.2f}] ‚ö†Ô∏è  {self.id}: ‰∫ßÂìÅ‰ΩçÁΩÆÊõ¥Êñ∞Â§±Ë¥•Ôºå‰ΩÜÂç∏ËΩΩÊàêÂäü")
                
                yield self.env.timeout(self.operation_time)
                self.consume_battery(self.battery_consumption_per_action, "Âç∏ËΩΩÊìç‰Ωú")
                buffer_desc = f" {buffer_type}" if buffer_type else ""
                feedback = f"Â∑≤Â∞Ü‰∫ßÂìÅ{product.id}Âç∏ËΩΩÂà∞{device.id}{buffer_desc}ÔºåÂâ©‰ΩôÁîµÈáè: {self.battery_level:.1f}%"
            else:
                # Â§±Ë¥•Êó∂ÊîæÂõû‰∫ßÂìÅ
                yield self.payload.put(product)
                
        except Exception as e:
            feedback = f"Âç∏ËΩΩÂºÇÂ∏∏: {str(e)}"
            # ÂºÇÂ∏∏Êó∂Â∞ùËØïÊîæÂõû‰∫ßÂìÅ
            if product and len(self.payload.items) < self.payload_capacity:
                yield self.payload.put(product)
            success = False
            
        finally:
            self.set_status(DeviceStatus.IDLE)
            
        return success, feedback, product

    def charge_battery(self, target_level: float = 100.0, message: Optional[str] = None, is_emergency: bool = False):
        """Charge battery to target level. Returns (success, feedback_message)"""
        if self.status == DeviceStatus.CHARGING:
            msg = f"already charging"
            print(f"[{self.env.now:.2f}] üîã {self.id}: {msg}")
            return True, msg
            
        if self.battery_level >= target_level:
            msg = f"battery level is enough ({self.battery_level:.1f}%)"
            print(f"[{self.env.now:.2f}] üîã {self.id}: {msg}")
            return True, msg
            
        # move to charging point
        if self.current_point != self.charging_point:
            # Note: move_to already records transport time to KPI
            yield self.env.process(self.move_to(self.charging_point))
            
        # start charging
        self.set_status(DeviceStatus.CHARGING, message)
        
        charge_needed = target_level - self.battery_level
        charge_time = charge_needed / self.charging_speed
        
        print(f"[{self.env.now:.2f}] üîã {self.id}: start charging ({self.battery_level:.1f}% ‚Üí {target_level:.1f}%, estimated {charge_time:.1f}s)")
        
        yield self.env.timeout(charge_time)
        
        # charging completed
        self.battery_level = target_level
        
        # update statistics
        self.stats["total_charge_time"] += charge_time
        
        # Report charge event with duration to KPI calculator
        if self.kpi_calculator and hasattr(self, '_charge_start_time'):
            actual_charge_duration = self.env.now - self._charge_start_time
            is_active = getattr(self, '_is_active_charge', False)
            self.kpi_calculator.register_agv_charge(self.id, self.line_id, is_active, actual_charge_duration)
            # Add energy cost for charging (charging typically uses more power)
            self.kpi_calculator.add_energy_cost(f"AGV_{self.id}_charging", self.line_id, charge_time, is_peak_hour=False)
            # Clean up temporary attributes
            if hasattr(self, '_charge_start_time'):
                del self._charge_start_time
            if hasattr(self, '_is_active_charge'):
                del self._is_active_charge
        
        print(f"[{self.env.now:.2f}] ‚úÖ {self.id}: ÂÖÖÁîµÂÆåÊàêÔºåÂΩìÂâçÁîµÈáè: {self.battery_level:.1f}%")

        # Before setting to IDLE, check for pending faults
        if self._check_and_trigger_pending_fault():
            return True, f"ÂÖÖÁîµÂÆåÊàêÂà∞ {target_level:.1f}%Ôºå‰ΩÜËß¶Âèë‰∫ÜÊïÖÈöú"

        self.set_status(DeviceStatus.IDLE, f"charged to {target_level:.1f}%")
        return True, f"ÂÖÖÁîµÂÆåÊàêÔºåÂΩìÂâçÁîµÈáè: {self.battery_level:.1f}%"

    def emergency_charge(self):
        """Emergency charging when battery is critically low."""
        print(f"[{self.env.now:.2f}] üö® {self.id}: emergency charging started")
        self.stats["forced_charge_count"] += 1
        self.stats["low_battery_interruptions"] += 1
        
        # Report to KPI calculator
        if self.kpi_calculator:
            # Note: charge_duration will be calculated and reported after charging completes
            self._charge_start_time = self.env.now
        
        # charge to safe level
        yield self.env.process(self.charge_battery(50.0, "emergency charging to 50%", is_emergency=True))

    def voluntary_charge(self, target_level: float = 80.0):
        """Voluntary charging to maintain good battery level. Returns (success, feedback_message)"""
        target_level = float(target_level)
        print(f"[{self.env.now:.2f}] üîã {self.id}: voluntary charging")
        self.stats["voluntary_charge_count"] += 1
        
        # Report to KPI calculator
        if self.kpi_calculator:
            # Note: charge_duration will be calculated and reported after charging completes
            self._charge_start_time = self.env.now
            self._is_active_charge = True
        
        self.action = self.env.process(self.charge_battery(target_level, f"voluntary charging to {target_level:.1f}%"))
        try:
            result = yield self.action
            return result if result else (True, f"ÂÖÖÁîµÂÆåÊàêÂà∞ {target_level:.1f}%")
        except simpy.Interrupt as e:
            msg = f"Charging interrupted: {e.cause}"
            print(f"[{self.env.now:.2f}] ‚ö†Ô∏è  {self.id}: {msg}")
            return False, msg
        finally:
            self.action = None

    def auto_charge_if_needed(self):
        """auto check and charge if needed (background process)"""
        while True:
            # check every 5 seconds
            yield self.env.timeout(5.0)
            
            # if battery is low and not charging, start emergency charging
            if self.is_battery_low() and self.status != DeviceStatus.CHARGING:
                print(f"[{self.env.now:.2f}] üîã {self.id}: battery is low, start emergency charging")
                yield self.env.process(self.emergency_charge())

    def get_battery_status(self) -> dict:
        """Ëé∑ÂèñÁîµÊ±†Áä∂ÊÄÅ‰ø°ÊÅØ"""
        return {
            "battery_level": self.battery_level,
            "is_charging": self.status == DeviceStatus.CHARGING,
            "is_low_battery": self.is_battery_low(),
            "charging_point": self.charging_point,
            "can_operate": not self.is_battery_low(),
            "stats": self.stats.copy()
        }

    def get_charging_stats(self) -> dict:
        """Ëé∑ÂèñÂÖÖÁîµÁõ∏ÂÖ≥ÁªüËÆ°Êï∞ÊçÆÔºàÁî®‰∫éKPIËÆ°ÁÆóÔºâ"""
        return {
            "total_charge_time": self.stats["total_charge_time"],
            "forced_charge_count": self.stats["forced_charge_count"],
            "voluntary_charge_count": self.stats["voluntary_charge_count"],
            "low_battery_interruptions": self.stats["low_battery_interruptions"],
            "tasks_completed": self.stats["tasks_completed"],
            "tasks_interrupted": self.stats["tasks_interrupted"],
            "charge_efficiency": (
                self.stats["voluntary_charge_count"] / 
                max(1, self.stats["forced_charge_count"] + self.stats["voluntary_charge_count"])
            ) * 100  # ‰∏ªÂä®ÂÖÖÁîµÊØî‰æã
        }

    def get_current_payload(self) -> List[Product]:
        """Ëé∑ÂèñÂΩìÂâçËΩΩË¥ßÂàóË°®"""
        return list(self.payload.items)

    def is_payload_full(self) -> bool:
        """Ê£ÄÊü•ËΩΩË¥ßÊòØÂê¶Â∑≤Êª°"""
        return len(self.payload.items) >= self.payload_capacity

    def is_payload_empty(self) -> bool:
        """Ê£ÄÊü•ËΩΩË¥ßÊòØÂê¶‰∏∫Á©∫"""
        return len(self.payload.items) == 0

    def get_available_path_points(self) -> List[str]:
        """Ëé∑ÂèñÂèØÁî®ÁöÑË∑ØÂæÑÁÇπÂàóË°®"""
        return list(self.path_points.keys())

    def get_path_point_position(self, point_name: str) -> Optional[Tuple[int, int]]:
        """Ëé∑ÂèñË∑ØÂæÑÁÇπÁöÑÂùêÊ†á"""
        return self.path_points.get(point_name)

    def _check_and_trigger_pending_fault(self) -> bool:
        """
        Checks if a fault is pending for this AGV and triggers it.
        This is called internally just before the AGV becomes IDLE.
        Returns True if a fault was triggered, False otherwise.
        """
        if self.fault_system and self.id in self.fault_system.pending_agv_faults:
            fault_type = self.fault_system.pending_agv_faults.pop(self.id)
            print(f"[{self.env.now:.2f}] üí• AGV {self.id} is idle, triggering pending fault: {fault_type.value}")
            self.fault_system._inject_fault_now(self.id, fault_type)
            return True
        return False

    def __repr__(self) -> str:
        return f"AGV(id='{self.id}', battery={self.battery_level:.1f}%, payload={len(self.payload.items)}/{self.payload_capacity})"

    def set_status(self, new_status: DeviceStatus, message: Optional[str] = None):
        """Overrides the base method to publish status on change."""
        if self.status == new_status:
            return  # Avoid redundant publications
        
        # Track fault time for KPI
        if self.kpi_calculator:
            # If transitioning to FAULT status, record the start time
            if new_status == DeviceStatus.FAULT and self.status != DeviceStatus.FAULT:
                self._fault_start_time = self.env.now
            # If transitioning from FAULT to any other status, record the fault duration
            elif self.status == DeviceStatus.FAULT and new_status != DeviceStatus.FAULT:
                if hasattr(self, '_fault_start_time'):
                    fault_duration = self.env.now - self._fault_start_time
                    self.kpi_calculator.update_agv_fault_time(self.id, self.line_id, fault_duration)
                    del self._fault_start_time
        
        super().set_status(new_status)
        self.publish_status(message)


    def publish_status(self, message: Optional[str] = None):
        """Publishes the current AGV status to the MQTT broker."""
        if not self.mqtt_client:
            return

        status_payload = AGVStatus(
            timestamp=self.env.now,
            source_id=self.id,
            status=self.status,
            speed_mps=self.speed_mps,
            current_point=self.current_point,
            target_point=self.target_point,
            estimated_time=self.estimated_time,
            position={'x': self.position[0], 'y': self.position[1]},
            payload=[p.id for p in self.payload.items] if self.payload else [],
            battery_level=self.battery_level,
            message=message
        )
        if self.topic_manager and self.line_id:
            topic = self.topic_manager.get_agv_status_topic(self.line_id, self.id)
        else:
            from config.topics import get_agv_status_topic
            topic = get_agv_status_topic(self.id)
        self.mqtt_client.publish(topic, status_payload.model_dump_json(), retain=False)


================================================
File: src/simulation/entities/base.py
================================================
# simulation/entities/base.py
import simpy
import random
from abc import ABC, abstractmethod
from enum import Enum
from typing import Tuple, Optional
from dataclasses import dataclass

from config.schemas import DeviceStatus, DeviceDetailedStatus
from src.utils.topic_manager import TopicManager
from config.topics import DEVICE_ALERT_TOPIC

class Device:
    """
    Base class for all simulated devices in the factory.
    Simplified for a basic fault model.
    """
    def __init__(self, env: simpy.Environment, id: str, position: Tuple[int, int], device_type: str = "generic", mqtt_client=None, interacting_points: list = [], topic_manager: Optional[TopicManager] = None, line_id: Optional[str] = None):
        if not isinstance(env, simpy.Environment):
            raise ValueError("env must be a valid simpy.Environment object.")
        
        self.env = env
        self.id = id
        self.device_type = device_type
        self.position = position
        self.mqtt_client = mqtt_client
        self.interacting_points = interacting_points if interacting_points is not None else []
        self.topic_manager = topic_manager
        self.line_id = line_id
        
        # ËÆæÂ§áÁä∂ÊÄÅÂíåÊïÖÈöúÁõ∏ÂÖ≥Â±ûÊÄß
        self.status = DeviceStatus.IDLE
        self.fault_symptom = None
        self.action: Optional[simpy.Process] = None # Stores the current action process
        
        # ÊÄßËÉΩÊåáÊ†á
        self.performance_metrics = type('PerformanceMetrics', (), {
            'efficiency_rate': 100.0,
            'error_rate': 0.0,
            'uptime': 100.0
        })()
        
        # ËÆæÂ§áÁâπÂÆöÂ±ûÊÄßÔºàÂèØË¢´Â≠êÁ±ªÊâ©Â±ïÔºâ
        self._specific_attributes = {
            'temperature': random.uniform(20.0, 25.0),
            'vibration_level': random.uniform(0.0, 5.0),
            'power_consumption': random.uniform(80.0, 120.0)
        }

    def set_status(self, new_status: DeviceStatus, message: Optional[str] = None):
        """ËÆæÁΩÆËÆæÂ§áÁä∂ÊÄÅ"""
        if self.status != new_status:
            old_status = self.status
            self.status = new_status
            log_message = f"[{self.env.now:.2f}] üîÑ {self.id}: Áä∂ÊÄÅÂèòÊõ¥ {old_status.value} ‚Üí {new_status.value}"
            if message:
                log_message += f" ({message})"
            print(log_message)

    def can_operate(self) -> bool:
        """Ê£ÄÊü•ËÆæÂ§áÊòØÂê¶ÂèØ‰ª•Êìç‰Ωú"""
        # Ê£ÄÊü•ÂÜªÁªìÁä∂ÊÄÅ
        return self.status not in [DeviceStatus.FAULT, DeviceStatus.MAINTENANCE, DeviceStatus.BLOCKED]

    def get_detailed_status(self) -> DeviceDetailedStatus:
        """Ëé∑ÂèñËÆæÂ§áËØ¶ÁªÜÁä∂ÊÄÅ"""
        return DeviceDetailedStatus(
            device_id=self.id,
            device_type=self.device_type,
            current_status=self.status,
            temperature=self._specific_attributes.get('temperature', 25.0),
            vibration_level=self._specific_attributes.get('vibration_level', 0.0),
            power_consumption=self._specific_attributes.get('power_consumption', 100.0),
            efficiency_rate=getattr(self.performance_metrics, 'efficiency_rate', 100.0),
            cycle_count=0,  # ÁÆÄÂåñÂÆûÁé∞
            last_maintenance_time=0.0,  # ÁÆÄÂåñÂÆûÁé∞
            operating_hours=self.env.now / 3600.0,  # ËΩ¨Êç¢‰∏∫Â∞èÊó∂
            fault_symptom=self.fault_symptom,
            frozen_until=None,  # ÁÆÄÂåñÊïÖÈöúÁ≥ªÁªü‰∏ç‰ΩøÁî®ÂÜªÁªìÊú∫Âà∂
            precision_level=self._specific_attributes.get('precision_level', 100.0),
            tool_wear_level=self._specific_attributes.get('tool_wear_level', 0.0),
            lubricant_level=self._specific_attributes.get('lubricant_level', 100.0),
            battery_level=self._specific_attributes.get('battery_level', 100.0),
            position_accuracy=self._specific_attributes.get('position_accuracy', 100.0),
            load_weight=self._specific_attributes.get('load_weight', 0.0)
        )
    
    def _get_fault_topic(self) -> str:
        """Generates the correct fault topic based on context."""
        if self.topic_manager and self.line_id:
            return self.topic_manager.get_fault_alert_topic(self.line_id)
        else:
            return DEVICE_ALERT_TOPIC

    def report_buffer_full(self, buffer_name: str):
        """Êä•ÂëäÁºìÂÜ≤Âå∫Êª°"""
        topic = self._get_fault_topic()
        payload = {
            "event_type": "buffer_full",
            "data": {
                "device_id": self.id,
                "buffer_name": buffer_name,
                "timestamp": self.env.now,
                "severity": "warning"
            }
        }
        self._publish_fault_event(topic, payload)
        print(f"[{self.env.now:.2f}] üì¶ {self.id}: ÁºìÂÜ≤Âå∫Êª°ÂëäË≠¶ ({buffer_name})")

    def _publish_fault_event(self, topic: str, payload: dict):
        """ÂèëÂ∏ÉÊïÖÈöú‰∫ã‰ª∂Âà∞MQTT"""
        if self.mqtt_client:
            self.mqtt_client.publish(topic, payload)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(id='{self.id}', status='{self.status.value}')"

    def recover(self):
        """Default recovery logic."""
        # Âè™ÊúâÂΩìËÆæÂ§áÂ§Ñ‰∫éFAULTÁä∂ÊÄÅÊó∂ÊâçÊÅ¢Â§ç
        # ÈÅøÂÖçË¶ÜÁõñÂÖ∂‰ªñÂêàÊ≥ïÁä∂ÊÄÅÔºàÂ¶ÇBLOCKEDÔºâ
        if self.status == DeviceStatus.FAULT:
            self.set_status(DeviceStatus.IDLE)

class Vehicle(Device):
    """
    Base class for mobile entities like AGVs.
    """
    def __init__(self, env: simpy.Environment, id: str, position: Tuple[int, int], speed_mps: float, mqtt_client=None):
        super().__init__(env, id, position, "vehicle", mqtt_client)
        self.speed_mps = speed_mps

class BaseConveyor(Device, ABC):
    """
    Abstract base class for different types of conveyors.
    """
    def __init__(self, env: simpy.Environment, id: str, position: Tuple[int, int], transfer_time: float, line_id: Optional[str] = None, interacting_points: list = [], topic_manager: Optional[TopicManager] = None, mqtt_client=None):
        super().__init__(env, id, position, "conveyor", mqtt_client, interacting_points)

    @abstractmethod
    def push(self, product):
        """Add a product to the conveyor."""
        pass

    @abstractmethod
    def pop(self):
        """Remove a product from the conveyor."""
        pass

    @abstractmethod
    def is_full(self):
        """Check if the conveyor is full."""
        pass

    @abstractmethod
    def is_empty(self):
        """Check if the conveyor is empty."""
        pass

    @abstractmethod
    def get_buffer(self):
        """Get the internal buffer of the conveyor."""
        pass

    @abstractmethod
    def set_downstream_station(self, station):
        """Set the station that receives products from this conveyor."""
        pass


================================================
File: src/simulation/entities/conveyor.py
================================================
# simulation/entities/conveyor.py
import simpy
from typing import Optional
from src.simulation.entities.base import BaseConveyor
from src.simulation.entities.product import Product
from typing import Tuple
from src.utils.topic_manager import TopicManager
from config.schemas import DeviceStatus, ConveyorStatus
from config.topics import get_conveyor_status_topic

class Conveyor(BaseConveyor):
    """
    Conveyor with limited capacity, simulating a production line conveyor belt.
    Now uses simpy.Store for event-driven simulation and supports auto-transfer.
    """
    def __init__(self, env, id, capacity, position: Tuple[int, int], interacting_points: list, transfer_time: float =5.0, mqtt_client=None, kpi_calculator=None, topic_manager: Optional[TopicManager] = None, line_id: Optional[str] = None):
        super().__init__(env, id, position, transfer_time, line_id, interacting_points, topic_manager, mqtt_client)
        self.capacity = capacity
        self.buffer = simpy.Store(env, capacity=capacity)
        self.downstream_station = None  # ‰∏ãÊ∏∏Â∑•Á´ôÂºïÁî®
        self.action = None  # ‰øùÁïô‰ΩÜ‰∏ç‰ΩøÁî®ÔºåÂÖºÂÆπ fault system Êé•Âè£
        self.transfer_time = transfer_time # Ê®°ÊãüÊê¨ËøêÊó∂Èó¥
        self.topic_manager = topic_manager
        self.line_id = line_id
        self.main_process = None  # ‰∏ªËøêË°åËøõÁ®ã
        self.active_processes = {}  # Track active transfer processes per product
        self.product_start_times = {}  # Track when each product started transfer
        self.product_elapsed_times = {}  # Track elapsed time before interruption
        
        # ÈòªÂ°ûÁÆ°ÁêÜ
        self.blocked_leader_process = None  # Ê≠£Âú®Á≠âÂæÖ‰∏ãÊ∏∏ÁöÑÈ¢ÜÂ§¥‰∫ßÂìÅËøõÁ®ã
        self.kpi_calculator = kpi_calculator  # KPI calculator dependency
        
        # ‰º†ÈÄÅÂ∏¶ÈªòËÆ§Áä∂ÊÄÅ‰∏∫Â∑•‰Ωú‰∏≠
        self.status = DeviceStatus.WORKING
        self.publish_status("Conveyor initialized")
               # Initialize device utilization tracking
        if self.kpi_calculator:
            self.kpi_calculator.update_device_utilization(self.id, self.line_id, 0.0)
        
        # Start background process to update total time for utilization calculation
        self.env.process(self._update_total_time())

    def publish_status(self, message: Optional[str] = None):
        """Áõ¥Êé•ÂèëÂ∏É‰º†ÈÄÅÂ∏¶Áä∂ÊÄÅÔºå‰∏çÈÄöËøáset_status"""
        if not self.mqtt_client or not self.mqtt_client.is_connected():
            return

        status_data = ConveyorStatus(
            timestamp=self.env.now,
            source_id=self.id,
            status=self.status,
            buffer=[p.id for p in self.buffer.items],
            message=message,
            upper_buffer=None,
            lower_buffer=None
        )
        if self.topic_manager and self.line_id:
            topic = self.topic_manager.get_conveyor_status_topic(self.line_id, self.id)
        else:
            topic = get_conveyor_status_topic(self.id)
        self.mqtt_client.publish(topic, status_data.model_dump_json(), retain=False)

    def set_downstream_station(self, station):
        """Set the downstream station for auto-transfer."""
        self.downstream_station = station
        if self.main_process is None:
            self.main_process = self.env.process(self.run())

    def push(self, product):
        """Put a product on the conveyor (may block if full)."""
        result = self.buffer.put(product)
        print(f"[{self.env.now:.2f}] [DEBUG] Conveyor {self.id}: push {product.id}, buffer={len(self.buffer.items)}/{self.capacity}")
        # ‰∫ßÂìÅÊ∑ªÂä†ÂêéÂèëÂ∏ÉÁä∂ÊÄÅ
        self.publish_status()
        return result

    def pop(self):
        """Remove and return a product from the conveyor (may block if empty)."""
        product = yield self.buffer.get()
        print(f"[{self.env.now:.2f}] [DEBUG] Conveyor {self.id}: pop {product.id}, buffer={len(self.buffer.items)}/{self.capacity}")
        
        # Â¶ÇÊûúËØ•‰∫ßÂìÅÊúâÂØπÂ∫îÁöÑÂ§ÑÁêÜËøõÁ®ãÔºå‰∏≠Êñ≠Âπ∂Âà†Èô§ÂÆÉ
        if product.id in self.active_processes:
            process = self.active_processes[product.id]
            if process.is_alive:
                process.interrupt("Product removed by AGV")
                print(f"[{self.env.now:.2f}] üö´ Conveyor {self.id}: Interrupted process for product {product.id} (taken by AGV)")
            del self.active_processes[product.id]
            
            # Ê∏ÖÁêÜËØ•‰∫ßÂìÅÁöÑÊó∂Èó¥ËÆ∞ÂΩï
            if product.id in self.product_start_times:
                del self.product_start_times[product.id]
            if product.id in self.product_elapsed_times:
                del self.product_elapsed_times[product.id]
        
        # ‰∫ßÂìÅÁßªÈô§ÂêéÂèëÂ∏ÉÁä∂ÊÄÅ
        self.publish_status()
        return product

    def get_buffer(self):
        return self.buffer

    def is_full(self):
        return len(self.buffer.items) >= self.capacity

    def is_empty(self):
        return len(self.buffer.items) == 0

    def peek(self):
        if self.buffer.items:
            return self.buffer.items[0]
        return None
    
    def _update_total_time(self):
        """Background process to update total time for KPI utilization calculation"""
        while True:
            yield self.env.timeout(10.0)  # Update every 10 seconds
            if self.kpi_calculator:
                self.kpi_calculator.update_device_utilization(self.id, self.line_id, self.env.now)

    def run(self):
        """Main operational loop for the conveyor. This should NOT be interrupted by faults."""
        while True:
            # Á≠âÂæÖËÆæÂ§áÂèØÊìç‰Ωú‰∏îbufferÊúâ‰∫ßÂìÅ
            yield self.env.process(self._wait_for_ready_state())
            
            # Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•Ëß£Èô§ÈòªÂ°ûÁä∂ÊÄÅ
            if self.status == DeviceStatus.BLOCKED:
                # Â¶ÇÊûú‰∏ãÊ∏∏Â∑•Á´ôÊÅ¢Â§çÊ≠£Â∏∏ÊàñËÄÖÊ≤°ÊúâÊ≠£Âú®Á≠âÂæÖÁöÑÈ¢ÜÂ§¥ËøõÁ®ãÔºåËß£Èô§ÈòªÂ°û
                if self.downstream_station and self.downstream_station.can_operate():
                    if self.blocked_leader_process is None or not self.blocked_leader_process.is_alive:
                        print(f"[{self.env.now:.2f}] üîì Conveyor {self.id}: Downstream recovered or no leader waiting, unblocking")
                        self._unblock_all_products()
            
            # Ê£ÄÊü•buffer‰∏≠ÁöÑÊØè‰∏™‰∫ßÂìÅÔºåÂ¶ÇÊûúËøòÊ≤°ÊúâÂ§ÑÁêÜËøõÁ®ãÂ∞±ÂêØÂä®‰∏Ä‰∏™
            for item in list(self.buffer.items):  # ‰ΩøÁî®listÈÅøÂÖçËø≠‰ª£Êó∂‰øÆÊîπ
                if item.id not in self.active_processes:
                    # Âè™ÊúâÂú®ÈùûÈòªÂ°ûÁä∂ÊÄÅ‰∏ãÊâç‰∏∫Êñ∞‰∫ßÂìÅÂêØÂä®Â§ÑÁêÜËøõÁ®ã
                    if self.status != DeviceStatus.BLOCKED:
                        # ‰∏∫Ëøô‰∏™‰∫ßÂìÅÂêØÂä®‰∏Ä‰∏™Â§ÑÁêÜËøõÁ®ã
                        process = self.env.process(self.process_single_item(item))
                        self.active_processes[item.id] = process
                    else:
                        # Â¶ÇÊûúÊòØÈòªÂ°ûÁä∂ÊÄÅÔºåÊ£ÄÊü•Ëøô‰∏™‰∫ßÂìÅÊòØÂê¶ÊòØÁ¨¨‰∏Ä‰∏™ÔºàÈ¢ÜÂ§¥‰∫ßÂìÅÔºâ
                        if len(self.buffer.items) > 0 and self.buffer.items[0].id == item.id:
                            # ËøôÊòØÈ¢ÜÂ§¥‰∫ßÂìÅÔºåÂÖÅËÆ∏ÂêØÂä®ËøõÁ®ã
                            process = self.env.process(self.process_single_item(item))
                            self.active_processes[item.id] = process
                            print(f"[{self.env.now:.2f}] üëë Conveyor {self.id}: Starting process for leader product {item.id} despite blocked status")
            
            # Ê∏ÖÁêÜÂ∑≤ÂÆåÊàêÁöÑËøõÁ®ã
            completed_ids = []
            for product_id, process in self.active_processes.items():
                if not process.is_alive:
                    completed_ids.append(product_id)
            for product_id in completed_ids:
                del self.active_processes[product_id]
            
            yield self.env.timeout(0.1)

    def _wait_for_ready_state(self):
        """Á≠âÂæÖËÆæÂ§áÂ§Ñ‰∫éÂèØÊìç‰ΩúÁä∂ÊÄÅ‰∏îbufferÊúâ‰∫ßÂìÅ"""
        while True:
            # Â¶ÇÊûúÊ≤°Êúâ‰∏ãÊ∏∏Á´ôÁÇπÔºåÁ≠âÂæÖ
            if self.downstream_station is None:
                yield self.env.timeout(1)
                continue
            
            # Â¶ÇÊûúbuffer‰∏∫Á©∫ÔºåÁ≠âÂæÖ
            if len(self.buffer.items) == 0 or not self.can_operate():
                yield self.env.timeout(0.1)
                continue

            # ËÆæÂ§áÂèØÊìç‰Ωú‰∏îÊúâ‰∫ßÂìÅÔºåËøîÂõû
            return
        
    def process_single_item(self, product):
        """Process a single item with timeout-get-put pattern. This CAN be interrupted by faults."""
        actual_product = None
        try:
            # Ê£ÄÊü•‰∏ãÊ∏∏Á´ôÁÇπÊòØÂê¶Â≠òÂú®
            if self.downstream_station is None:
                return
            
            # Â¶ÇÊûúÂΩìÂâçÊòØblockedÁä∂ÊÄÅ‰∏î‰∏çÊòØÈ¢ÜÂ§¥‰∫ßÂìÅÔºå‰∏çÂ∫îËØ•ÁªßÁª≠
            if self.status == DeviceStatus.BLOCKED:
                is_leader = len(self.buffer.items) > 0 and self.buffer.items[0].id == product.id
                if not is_leader:
                    print(f"[{self.env.now:.2f}] üö´ Conveyor {self.id}: Product {product.id} blocked at start, not leader")
                    return
            
            self.set_status(DeviceStatus.WORKING)
            self.publish_status()
            
            print(f"[{self.env.now:.2f}] üìã Conveyor {self.id}: Added {product.id} to processing order, current order: {[p.id for p in self.buffer.items]}")
            
            # ËÆ°ÁÆóÂâ©‰Ωô‰º†ËæìÊó∂Èó¥ÔºàÂ§ÑÁêÜ‰∏≠Êñ≠ÂêéÊÅ¢Â§çÁöÑÊÉÖÂÜµÔºâ
            if product.id in self.product_elapsed_times:
                # ÊÅ¢Â§ç‰º†ËæìÔºö‰ΩøÁî®‰πãÂâçËÆ∞ÂΩïÁöÑÂ∑≤‰º†ËæìÊó∂Èó¥
                elapsed_time = self.product_elapsed_times[product.id]
                remaining_time = max(0, self.transfer_time - elapsed_time)
                msg = f"[{self.env.now:.2f}] Conveyor {self.id}: {product.id} resume transferring, elapsed {elapsed_time:.1f}s, remaining {remaining_time:.1f}s"
            else:
                # Á¨¨‰∏ÄÊ¨°ÂºÄÂßã‰º†Ëæì
                remaining_time = self.transfer_time
                msg = f"[{self.env.now:.2f}] Conveyor {self.id}: {product.id} start transferring, need {remaining_time:.1f}s"
            
            self.product_start_times[product.id] = self.env.now
            print(msg)
            self.publish_status(msg)     

            # Track start of working time for KPI
            working_start_time = self.env.now
            yield self.env.timeout(remaining_time)
            is_first_product = self.buffer.items[0].id == product.id
            # Report energy cost and working time for this transfer
            if self.kpi_calculator:
                self.kpi_calculator.add_energy_cost(self.id, self.line_id, remaining_time, is_peak_hour=False)
                # Working time is already tracked in add_energy_cost
            
            # ‰º†ËæìÂÆåÊàêÔºå‰ªébufferËé∑Âèñ‰∫ßÂìÅÔºàgetÔºâ
            actual_product = yield self.buffer.get()

            # Á°Æ‰øùËé∑ÂèñÁöÑÊòØÊ≠£Á°ÆÁöÑ‰∫ßÂìÅ
            if actual_product.id != product.id:
                # Â¶ÇÊûú‰∏çÊòØÈ¢ÑÊúüÁöÑ‰∫ßÂìÅÔºåÊîæÂõûÂéª
                yield self.buffer.put(actual_product)
                msg = f"[{self.env.now:.2f}] Conveyor {self.id}: unexpected product order, retrying"
                print(msg)
                self.publish_status(msg)
                return
            
            self.publish_status()
            
            # ‰ΩøÁî®Â§ÑÁêÜÈ°∫Â∫è‰ø°ÊÅØ
            if is_first_product:
                # ËøôÊòØÊúÄÂâçÈù¢ÁöÑ‰∫ßÂìÅÔºåËÆæ‰∏∫È¢ÜÂ§¥ËøõÁ®ã
                self.blocked_leader_process = self.env.active_process
                print(f"[{self.env.now:.2f}] üéØ Conveyor {self.id}: {actual_product.id} is the leader product (first in order)")
                
                downstream_full = self.downstream_station.is_full()
                print(f"[{self.env.now:.2f}] üîç Conveyor {self.id}: Downstream buffer {len(self.downstream_station.buffer.items)}/{self.downstream_station.buffer.capacity}, full={downstream_full}, can opeatate:{self.downstream_station.can_operate()}")
                    
                if (downstream_full or not self.downstream_station.can_operate()) and self.status != DeviceStatus.BLOCKED:
                    # ‰∏ãÊ∏∏Â∑≤Êª°Êàñ‰∏ãÊ∏∏Â∑•Á´ô‰∏çÂèØÊìç‰ΩúÔºåÈòªÂ°ûÂÖ∂‰ªñ‰∫ßÂìÅ
                    self._block_all_products()
                    
                while not self.downstream_station.can_operate():
                    yield self.env.timeout(0.1)
                # Â∞ùËØïÊîæÂÖ•‰∏ãÊ∏∏ÔºàÂèØËÉΩ‰ºöÈòªÂ°ûÔºâ
                print(f"[{self.env.now:.2f}] ‚è≥ Conveyor {self.id}: Leader {actual_product.id} trying to put to downstream...")
                yield self.downstream_station.buffer.put(actual_product)
                
                # ÊàêÂäüÊîæÂÖ•ÔºåÂ¶ÇÊûú‰πãÂâçÊòØÈòªÂ°ûÁä∂ÊÄÅÔºåÁé∞Âú®Ëß£Èô§
                if self.status == DeviceStatus.BLOCKED and self.downstream_station.can_operate():
                    self._unblock_all_products()
                    
            else:
                # ‰∏çÊòØÁ¨¨‰∏Ä‰∏™‰∫ßÂìÅ
                print(f"[{self.env.now:.2f}] üì¶ Conveyor {self.id}: {actual_product.id} is NOT the leader product (order: {[p.id for p in self.buffer.items]})")
                
                # ÈùûÈ¢ÜÂ§¥‰∫ßÂìÅÈúÄË¶ÅÁ≠âÂæÖÔºåÁõ¥Âà∞ËΩÆÂà∞ÂÆÉÊàñËÄÖ‰º†ÈÄÅÂ∏¶Ëß£Èô§ÈòªÂ°û
                while self.status == DeviceStatus.BLOCKED:
                    print(f"[{self.env.now:.2f}] ‚è≥ Conveyor {self.id}: {actual_product.id} waiting for its turn or unblock...")
                    yield self.env.timeout(0.1)
                
                # Áé∞Âú®ÂèØ‰ª•Â∞ùËØïÊîæÂÖ•‰∏ãÊ∏∏
                yield self.downstream_station.buffer.put(actual_product)
            
            actual_product.update_location(self.downstream_station.id, self.env.now)
            msg = f"[{self.env.now:.2f}] Conveyor {self.id}: moved product {actual_product.id} to {self.downstream_station.id}"
            print(msg)
            self.publish_status(msg)
            
            # Ê∏ÖÁêÜ‰º†ËæìÊó∂Èó¥ËÆ∞ÂΩï
            if actual_product.id in self.product_start_times:
                del self.product_start_times[actual_product.id]
            if actual_product.id in self.product_elapsed_times:
                del self.product_elapsed_times[actual_product.id]
                
        except simpy.Interrupt as e:
            print(f"[{self.env.now:.2f}] üö´ Conveyor {self.id}: Interrupted by{e}: {e.cause}")
            interrupt_reason = str(e.cause) if hasattr(e, 'cause') else "Unknown"
            
            # Â¶ÇÊûúÊòØAGVÂèñËµ∞‰∫ßÂìÅÁöÑ‰∏≠Êñ≠ÔºåÁõ¥Êé•ËøîÂõû
            if "Product removed by AGV" in interrupt_reason:
                print(f"[{self.env.now:.2f}] üöö Conveyor {self.id}: Product {product.id} was taken by AGV, stopping process")
                # Êó∂Èó¥ËÆ∞ÂΩïÂ∑≤ÁªèÂú®pop()‰∏≠Ê∏ÖÁêÜ‰∫ÜÔºåËøôÈáå‰∏çÈúÄË¶ÅÂÜçÊ∏ÖÁêÜ
                return
            
            # ËÆ∞ÂΩï‰∏≠Êñ≠Êó∂Â∑≤Áªè‰º†ËæìÁöÑÊó∂Èó¥ÔºàÈòªÂ°ûÂíåÊïÖÈöúÈÉΩÈúÄË¶ÅÔºâ
            if product.id in self.product_start_times:
                start_time = self.product_start_times[product.id]
                elapsed_before_interrupt = self.env.now - start_time
                self.product_elapsed_times[product.id] = self.product_elapsed_times.get(product.id, 0) + elapsed_before_interrupt
                del self.product_start_times[product.id]
                print(f"[{self.env.now:.2f}] üíæ Conveyor {self.id}: ‰∫ßÂìÅ {product.id} ‰∏≠Êñ≠ÂâçÂ∑≤‰º†Ëæì {elapsed_before_interrupt:.1f}sÔºåÂâ©‰Ωô {self.transfer_time - self.product_elapsed_times.get(product.id, 0):.1f}s")
            
            # Ê†πÊçÆ‰∏≠Êñ≠ÂéüÂõ†Â§ÑÁêÜ
            if "Downstream blocked" in interrupt_reason:
                # ËøôÊòØÈòªÂ°û‰∏≠Êñ≠
                print(f"[{self.env.now:.2f}] ‚è∏Ô∏è Conveyor {self.id}: Product {product.id} paused due to downstream blockage")
                # ÈòªÂ°ûÁä∂ÊÄÅÂ∑≤ÁªèÁî±_block_all_productsËÆæÁΩÆÔºåËøôÈáå‰∏çÈúÄË¶ÅÈáçÂ§çËÆæÁΩÆ
                    
            else:
                # ËøôÊòØÊïÖÈöú‰∏≠Êñ≠
                print(f"[{self.env.now:.2f}] ‚ö†Ô∏è Conveyor {self.id}: Processing of product {product.id} was interrupted by fault")
                
                # Â¶ÇÊûú‰∫ßÂìÅÂ∑≤ÁªèÂèñÂá∫ÔºåËØ¥ÊòéÂ∑≤ÂÆåÊàê‰º†ËæìÔºåÂ∫îËØ•ÊîæÂÖ•‰∏ãÊ∏∏
                if actual_product and actual_product not in self.buffer.items and self.downstream_station:
                    # ‰∫ßÂìÅÂ∑≤ÂÆåÊàê‰º†ËæìÔºåÁõ¥Êé•ÊîæÂÖ•‰∏ãÊ∏∏
                    print(f"[{self.env.now:.2f}] üì¶ Conveyor {self.id}: Product {actual_product.id} already transferred, putting to downstream")
                    yield self.downstream_station.buffer.put(actual_product)
                    
                    # Êõ¥Êñ∞‰∫ßÂìÅ‰ΩçÁΩÆ
                    actual_product.update_location(self.downstream_station.id, self.env.now)
                    msg = f"[{self.env.now:.2f}] Conveyor {self.id}: moved product {actual_product.id} to {self.downstream_station.id} (during fault interrupt)"
                    print(msg)
                    
                    # Ê∏ÖÁêÜÊó∂Èó¥ËÆ∞ÂΩï
                    if actual_product.id in self.product_start_times:
                        del self.product_start_times[actual_product.id]
                    if actual_product.id in self.product_elapsed_times:
                        del self.product_elapsed_times[actual_product.id]
                else:
                    # ‰∫ßÂìÅËøòÂú®‰º†Ëæì‰∏≠Ôºå‰∏≠Êñ≠ÊòØÂêàÁêÜÁöÑ
                    print(f"[{self.env.now:.2f}] üîÑ Conveyor {self.id}: Product {product.id} interrupted during transfer")
                
                # ËÆæÁΩÆÊïÖÈöúÁä∂ÊÄÅ
                self.set_status(DeviceStatus.FAULT)
                self.publish_status()
            
        finally:
            self.publish_status()

    def recover(self):
        """Custom recovery logic for the conveyor."""
        # Ê∏ÖÁêÜ‰∏çÂú®buffer‰∏≠ÁöÑ‰∫ßÂìÅÁöÑÊó∂Èó¥ËÆ∞ÂΩï
        products_in_buffer = {p.id for p in self.buffer.items}
        
        # Ê∏ÖÁêÜstart_times
        expired_products = [pid for pid in self.product_start_times if pid not in products_in_buffer]
        for pid in expired_products:
            del self.product_start_times[pid]
            print(f"[{self.env.now:.2f}] üóëÔ∏è Conveyor {self.id}: Ê∏ÖÁêÜËøáÊúü‰∫ßÂìÅ {pid} ÁöÑÂºÄÂßãÊó∂Èó¥ËÆ∞ÂΩï")
        
        # Ê∏ÖÁêÜelapsed_times
        expired_elapsed = [pid for pid in self.product_elapsed_times if pid not in products_in_buffer]
        for pid in expired_elapsed:
            del self.product_elapsed_times[pid]
            print(f"[{self.env.now:.2f}] üóëÔ∏è Conveyor {self.id}: Ê∏ÖÁêÜËøáÊúü‰∫ßÂìÅ {pid} ÁöÑÂ∑≤‰º†ËæìÊó∂Èó¥ËÆ∞ÂΩï")
        
        # ÊÅ¢Â§çÂêéÔºåÂÆÉÂ∫îËØ•ÁªßÁª≠Â∑•‰ΩúÔºåËÄå‰∏çÊòØÁ©∫Èó≤
        self.set_status(DeviceStatus.WORKING)
        msg = f"[{self.env.now:.2f}] ‚úÖ Conveyor {self.id} is recovered."
        print(msg)
        self.publish_status(msg)
        
    def interrupt_all_processing(self):
        """Interrupt all active product processing. Called by fault system."""
        interrupted_count = 0
        for product_id, process in list(self.active_processes.items()):
            if process.is_alive:
                process.interrupt("Fault injected")
                interrupted_count += 1
        print(f"[{self.env.now:.2f}] üö´ Conveyor {self.id}: Interrupted {interrupted_count} product processes")
        return interrupted_count
    
    def _block_all_products(self, reason="Downstream blocked"):
        """ÈòªÂ°ûÊâÄÊúâ‰∫ßÂìÅÂ§ÑÁêÜÔºàÈô§‰∫ÜÊ≠£Âú®Á≠âÂæÖÁöÑÈ¢ÜÂ§¥‰∫ßÂìÅÔºâ"""
        if self.status == DeviceStatus.BLOCKED:
            print(f"[{self.env.now:.2f}] [DEBUG] Conveyor {self.id}: already blocked, skip")
            return  # Â∑≤ÁªèÂ§Ñ‰∫éÈòªÂ°ûÁä∂ÊÄÅ
        
        # ËÆæÁΩÆÈòªÂ°ûÁä∂ÊÄÅ
        self.set_status(DeviceStatus.BLOCKED)
        self.publish_status("Conveyor blocked - downstream full")
        
        # ‰∏≠Êñ≠ÊâÄÊúâÈùûÈ¢ÜÂ§¥ÁöÑÊ¥ªË∑ÉËøõÁ®ãÔºà‰∏éinterrupt_all_processingÁ±ª‰ººÔºâ
        blocked_count = 0
        for product_id, process in list(self.active_processes.items()):
            if process != self.blocked_leader_process and process.is_alive:
                process.interrupt(reason)
                blocked_count += 1
        
        print(f"[{self.env.now:.2f}] üöß Conveyor {self.id}: Blocked {blocked_count} products due to downstream blockage")
    
    def _unblock_all_products(self):
        """Ëß£Èô§ÈòªÂ°ûÔºåÂÖÅËÆ∏‰∫ßÂìÅÁªßÁª≠Â§ÑÁêÜ"""
        if self.status != DeviceStatus.BLOCKED:
            print(f"[{self.env.now:.2f}] [DEBUG] Conveyor {self.id}: not blocked, skip unblock")
            return  # ‰∏çÂú®ÈòªÂ°ûÁä∂ÊÄÅ
        
        self.set_status(DeviceStatus.WORKING)
        self.publish_status("Conveyor unblocked - resuming operation")
        self.blocked_leader_process = None
        
        print(f"[{self.env.now:.2f}] ‚úÖ Conveyor {self.id}: Unblocked, products can resume")

class TripleBufferConveyor(BaseConveyor):
    """
    Conveyor with three buffers:
    - main_buffer: for direct transfer to QualityCheck (auto-transfer)
    - upper_buffer: for P3 products, AGV pickup
    - lower_buffer: for P3 products, AGV pickup
    All buffers use simpy.Store for event-driven simulation.
    """
    def __init__(self, env, id, main_capacity, upper_capacity, lower_capacity, position: Tuple[int, int], transfer_time: float =5.0, mqtt_client=None, interacting_points: list = [], kpi_calculator=None, topic_manager: Optional[TopicManager] = None, line_id: Optional[str] = None):
        super().__init__(env, id, position, transfer_time, line_id, interacting_points, topic_manager, mqtt_client)
        self.topic_manager = topic_manager
        self.line_id = line_id
        self.main_buffer = simpy.Store(env, capacity=main_capacity)
        self.upper_buffer = simpy.Store(env, capacity=upper_capacity)
        self.lower_buffer = simpy.Store(env, capacity=lower_capacity)
        self.kpi_calculator = kpi_calculator  # KPI calculator dependency
        self.downstream_station = None  # QualityCheck
        self.action = None  # ‰øùÁïô‰ΩÜ‰∏ç‰ΩøÁî®ÔºåÂÖºÂÆπ fault system Êé•Âè£
        self.transfer_time = transfer_time # Ê®°ÊãüÊê¨ËøêÊó∂Èó¥
        self.main_process = None  # ‰∏ªËøêË°åËøõÁ®ã
        self.active_processes = {}  # Track active transfer processes per product
        self.product_start_times = {}  # Track when each product started transfer
        self.product_elapsed_times = {}  # Track elapsed time before interruption
        
        # ÈòªÂ°ûÁÆ°ÁêÜ
        self.blocked_leader_process = None  # Ê≠£Âú®Á≠âÂæÖ‰∏ãÊ∏∏ÁöÑÈ¢ÜÂ§¥‰∫ßÂìÅËøõÁ®ã
        
        # ‰º†ÈÄÅÂ∏¶ÈªòËÆ§Áä∂ÊÄÅ‰∏∫Â∑•‰Ωú‰∏≠
        self.status = DeviceStatus.WORKING
        self.publish_status("Conveyor initialized")
        
        # Initialize device utilization tracking
        if self.kpi_calculator:
            self.kpi_calculator.update_device_utilization(self.id, self.line_id, 0.0)
        
        # Start background process to update total time for utilization calculation
        self.env.process(self._update_total_time())

    def _should_be_blocked(self):
        """Ê£ÄÊü•‰∏âÁºìÂÜ≤‰º†ÈÄÅÂ∏¶ÊòØÂê¶Â∫îËØ•Â§Ñ‰∫éÈòªÂ°ûÁä∂ÊÄÅ"""
        # ÊâÄÊúâÁºìÂÜ≤Âå∫ÈÉΩÊª°ÊâçÁÆóÁúüÊ≠£ÈòªÂ°û
        return self.is_full("main") and self.is_full("upper") and self.is_full("lower") and self.downstream_station and not self.downstream_station.can_operate()

    def publish_status(self, message: Optional[str] = None):
        """ÂèëÂ∏ÉÂΩìÂâç‰º†ÈÄÅÂ∏¶Áä∂ÊÄÅÂà∞MQTT"""
        if not self.mqtt_client or not self.mqtt_client.is_connected():
            return

        # Âè™ÂèëÂ∏ÉÔºå‰∏ç‰øÆÊîπÁä∂ÊÄÅ
        status_data = ConveyorStatus(
            timestamp=self.env.now,
            source_id=self.id,
            status=self.status,
            buffer=[p.id for p in self.main_buffer.items],
            upper_buffer=[p.id for p in self.upper_buffer.items],
            lower_buffer=[p.id for p in self.lower_buffer.items],
            message=message,
        )
        if self.topic_manager and self.line_id:
            topic = self.topic_manager.get_conveyor_status_topic(self.line_id, self.id)
        else:
            topic = get_conveyor_status_topic(self.id)
        self.mqtt_client.publish(topic, status_data.model_dump_json(), retain=False)

    def set_downstream_station(self, station):
        """Set the downstream station for auto-transfer from main_buffer."""
        self.downstream_station = station
        if self.main_process is None:
            self.main_process = self.env.process(self.run())

    def push(self, product, buffer_type="main"):
        """Put product into specified buffer. buffer_type: 'main', 'upper', 'lower'."""
        result = self.get_buffer(buffer_type).put(product)
        print(f"[{self.env.now:.2f}] [DEBUG] TripleBufferConveyor {self.id}: push {product.id} to {buffer_type} buffer, buffer={len(self.get_buffer(buffer_type).items)}/{self.get_buffer(buffer_type).capacity}")
        # ‰∫ßÂìÅÊ∑ªÂä†ÂêéÂèëÂ∏ÉÁä∂ÊÄÅ
        self.publish_status()
        return result

    def get_buffer(self, buffer_type="main"):
        if buffer_type == "main":
            return self.main_buffer
        elif buffer_type == "upper":
            return self.upper_buffer
        elif buffer_type == "lower":
            return self.lower_buffer
        else:
            raise ValueError("buffer_type must be 'main', 'upper', or 'lower'")

    def pop(self, buffer_type="main"):
        """Get product from specified buffer."""
        product = yield self.get_buffer(buffer_type).get()
        print(f"[{self.env.now:.2f}] [DEBUG] TripleBufferConveyor {self.id}: pop {product.id} from {buffer_type} buffer, buffer={len(self.get_buffer(buffer_type).items)}/{self.get_buffer(buffer_type).capacity}")
        
        # Â¶ÇÊûúÊòØ‰ªémain_bufferÂèñÂá∫‰∏îËØ•‰∫ßÂìÅÊúâÂØπÂ∫îÁöÑÂ§ÑÁêÜËøõÁ®ãÔºå‰∏≠Êñ≠Âπ∂Âà†Èô§ÂÆÉ
        if buffer_type == "main" and product.id in self.active_processes:
            process = self.active_processes[product.id]
            if process.is_alive:
                process.interrupt("Product removed by AGV")
                print(f"[{self.env.now:.2f}] üö´ TripleBufferConveyor {self.id}: Interrupted process for product {product.id} (taken by AGV from {buffer_type})")
            del self.active_processes[product.id]
            
            # Ê∏ÖÁêÜËØ•‰∫ßÂìÅÁöÑÊó∂Èó¥ËÆ∞ÂΩï
            if product.id in self.product_start_times:
                del self.product_start_times[product.id]
            if product.id in self.product_elapsed_times:
                del self.product_elapsed_times[product.id]
        
        # ‰∫ßÂìÅÁßªÈô§ÂêéÂèëÂ∏ÉÁä∂ÊÄÅ
        self.publish_status()
        return product

    def is_full(self, buffer_type="main"):
        if buffer_type == "main":
            return len(self.main_buffer.items) >= self.main_buffer.capacity
        elif buffer_type == "upper":
            return len(self.upper_buffer.items) >= self.upper_buffer.capacity
        elif buffer_type == "lower":
            return len(self.lower_buffer.items) >= self.lower_buffer.capacity
        else:
            raise ValueError("buffer_type must be 'main', 'upper', or 'lower'")

    def is_empty(self, buffer_type="main"):
        if buffer_type == "main":
            return len(self.main_buffer.items) == 0
        elif buffer_type == "upper":
            return len(self.upper_buffer.items) == 0
        elif buffer_type == "lower":
            return len(self.lower_buffer.items) == 0
        else:
            raise ValueError("buffer_type must be 'main', 'upper', or 'lower'")

    def run(self):
        """Main operational loop for the triple buffer conveyor. This should NOT be interrupted by faults."""
        
        while True:
            # Á≠âÂæÖËÆæÂ§áÂèØÊìç‰Ωú‰∏îbufferÊúâ‰∫ßÂìÅ
            yield self.env.process(self._wait_for_ready_state())
            
            # Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•Ëß£Èô§ÈòªÂ°ûÁä∂ÊÄÅ
            if self.status == DeviceStatus.BLOCKED:
                # Â¶ÇÊûú‰∏ãÊ∏∏Â∑•Á´ôÊÅ¢Â§çÊ≠£Â∏∏ÊàñËÄÖÊ≤°ÊúâÊ≠£Âú®Á≠âÂæÖÁöÑÈ¢ÜÂ§¥ËøõÁ®ãÔºåËß£Èô§ÈòªÂ°û
                if self.downstream_station and self.downstream_station.can_operate() and not self.downstream_station.is_full():
                    if self.blocked_leader_process is None or not self.blocked_leader_process.is_alive:
                        print(f"[{self.env.now:.2f}] üîì TripleBufferConveyor {self.id}: Downstream recovered or no leader waiting, unblocking")
                        self._unblock_all_products()
            
            # Ê£ÄÊü•main_buffer‰∏≠ÁöÑÊØè‰∏™‰∫ßÂìÅÔºåÂ¶ÇÊûúËøòÊ≤°ÊúâÂ§ÑÁêÜËøõÁ®ãÂ∞±ÂêØÂä®‰∏Ä‰∏™
            for item in list(self.main_buffer.items):  # ‰ΩøÁî®listÈÅøÂÖçËø≠‰ª£Êó∂‰øÆÊîπ
                if item.id not in self.active_processes:
                    # Âè™ÊúâÂú®ÈùûÈòªÂ°ûÁä∂ÊÄÅ‰∏ãÊâç‰∏∫Êñ∞‰∫ßÂìÅÂêØÂä®Â§ÑÁêÜËøõÁ®ã
                    if self.status != DeviceStatus.BLOCKED:
                        # ‰∏∫Ëøô‰∏™‰∫ßÂìÅÂêØÂä®‰∏Ä‰∏™Â§ÑÁêÜËøõÁ®ã
                        process = self.env.process(self.process_single_item(item))
                        self.active_processes[item.id] = process
                    else:
                        # Â¶ÇÊûúÊòØÈòªÂ°ûÁä∂ÊÄÅÔºåÊ£ÄÊü•Ëøô‰∏™‰∫ßÂìÅÊòØÂê¶ÊòØÁ¨¨‰∏Ä‰∏™ÔºàÈ¢ÜÂ§¥‰∫ßÂìÅÔºâ
                        if len(self.main_buffer.items) > 0 and self.main_buffer.items[0].id == item.id:
                            # ËøôÊòØÈ¢ÜÂ§¥‰∫ßÂìÅÔºåÂÖÅËÆ∏ÂêØÂä®ËøõÁ®ã
                            process = self.env.process(self.process_single_item(item))
                            self.active_processes[item.id] = process
                            print(f"[{self.env.now:.2f}] üëë TripleBufferConveyor {self.id}: Starting process for leader product {item.id} despite blocked status")
            
            # Ê∏ÖÁêÜÂ∑≤ÂÆåÊàêÁöÑËøõÁ®ã
            completed_ids = []
            for product_id, process in self.active_processes.items():
                if not process.is_alive:
                    completed_ids.append(product_id)
            for product_id in completed_ids:
                del self.active_processes[product_id]
            
            yield self.env.timeout(0.1)  # Áü≠ÊöÇÁ≠âÂæÖÂêéÂÜçÊ£ÄÊü•
    
    def _wait_for_ready_state(self):
        """Á≠âÂæÖËÆæÂ§áÂ§Ñ‰∫éÂèØÊìç‰ΩúÁä∂ÊÄÅ‰∏îbufferÊúâ‰∫ßÂìÅ"""
        while True:
            
            # Â¶ÇÊûúÊ≤°Êúâ‰∏ãÊ∏∏Á´ôÁÇπÔºåÁ≠âÂæÖ
            if self.downstream_station is None:
                yield self.env.timeout(1)
                continue
            # Â¶ÇÊûúmain_buffer‰∏∫Á©∫ÔºåÁ≠âÂæÖ
            if len(self.main_buffer.items) == 0 or not self.can_operate():
                yield self.env.timeout(0.1)
                continue
            return
    
    def process_single_item(self, product):
        """Process a single item from main_buffer with timeout-get-put pattern. This CAN be interrupted by faults."""
        actual_product = None
        try:
            # Ê£ÄÊü•‰∏ãÊ∏∏Á´ôÁÇπÊòØÂê¶Â≠òÂú®
            if self.downstream_station is None:
                return
            
            # Â¶ÇÊûúÂΩìÂâçÊòØblockedÁä∂ÊÄÅ‰∏î‰∏çÊòØÈ¢ÜÂ§¥‰∫ßÂìÅÔºå‰∏çÂ∫îËØ•ÁªßÁª≠
            if self.status == DeviceStatus.BLOCKED:
                is_leader = len(self.main_buffer.items) > 0 and self.main_buffer.items[0].id == product.id
                if not is_leader:
                    print(f"[{self.env.now:.2f}] üö´ TripleBufferConveyor {self.id}: Product {product.id} blocked at start, not leader")
                    return
            
            self.set_status(DeviceStatus.WORKING)
            self.publish_status()
            
             # ËÆ°ÁÆóÂâ©‰Ωô‰º†ËæìÊó∂Èó¥ÔºàÂ§ÑÁêÜ‰∏≠Êñ≠ÂêéÊÅ¢Â§çÁöÑÊÉÖÂÜµÔºâ
            if product.id in self.product_elapsed_times:
                # ÊÅ¢Â§ç‰º†ËæìÔºö‰ΩøÁî®‰πãÂâçËÆ∞ÂΩïÁöÑÂ∑≤‰º†ËæìÊó∂Èó¥
                elapsed_time = self.product_elapsed_times[product.id]
                remaining_time = max(0, self.transfer_time - elapsed_time)
                msg = f"[{self.env.now:.2f}] Conveyor {self.id}: {product.id} resume transferring, elapsed {elapsed_time:.1f}s, remaining {remaining_time:.1f}s"
            else:
                # Á¨¨‰∏ÄÊ¨°ÂºÄÂßã‰º†Ëæì
                remaining_time = self.transfer_time
                msg = f"[{self.env.now:.2f}] Conveyor {self.id}: {product.id} start transferring, need {remaining_time:.1f}s"
            print(msg)
            self.publish_status(msg)
            self.product_start_times[product.id] = self.env.now
            
            # ËøõË°åtimeoutÔºàÊ®°ÊãüÊê¨ËøêÊó∂Èó¥Ôºâ
            # Track start of working time for KPI
            working_start_time = self.env.now
            yield self.env.timeout(remaining_time)
            
            is_first_product = self.main_buffer.items[0].id == product.id

            # Report energy cost and working time for this transfer
            if self.kpi_calculator:
                self.kpi_calculator.add_energy_cost(self.id, self.line_id, self.transfer_time, is_peak_hour=False)
                # Working time is already tracked in add_energy_cost
            
            # Ëé∑Âèñ‰∫ßÂìÅ
            actual_product = yield self.main_buffer.get()

            # Á°Æ‰øùËé∑ÂèñÁöÑÊòØÊ≠£Á°ÆÁöÑ‰∫ßÂìÅ
            if actual_product.id != product.id:
                # Â¶ÇÊûú‰∏çÊòØÈ¢ÑÊúüÁöÑ‰∫ßÂìÅÔºåÊîæÂõûÂéª
                yield self.main_buffer.put(actual_product)
                msg = f"[{self.env.now:.2f}] TripleBufferConveyor {self.id}: unexpected product order, retrying"
                print(msg)
                self.publish_status(msg)
                return
            
            self.publish_status()
            
            target_buffer = self._determine_target_buffer_for_product(product)
            # Ê†πÊçÆÁõÆÊ†ábufferÁ±ªÂûãÂÜ≥ÂÆöÂ§ÑÁêÜ
            if target_buffer in ["upper", "lower"]:
                # P3‰∫ßÂìÅËøîÂ∑•Ë∑ØÂæÑÔºöÈÄâÊã©ÊúÄ‰ºòÁöÑside buffer
                chosen_buffer = self._choose_optimal_side_buffer()
                buffer_name = "upper_buffer" if chosen_buffer == self.upper_buffer else "lower_buffer"
                actual_product.add_history(self.env.now, f"Moved to {buffer_name} of {self.id} for rework")
                msg = f"[{self.env.now:.2f}] TripleBufferConveyor {self.id}: moved product {actual_product.id} to {buffer_name}"
            else:
                chosen_buffer = self.downstream_station.buffer
                buffer_name = self.downstream_station.id+"_buffer"
                msg = f"[{self.env.now:.2f}] TripleBufferConveyor {self.id}: moved product {actual_product.id} to {self.downstream_station.id}"
            print(msg)
            self.publish_status(msg)
            
            if is_first_product:
                # ËøôÊòØÊúÄÂâçÈù¢ÁöÑ‰∫ßÂìÅÔºåËÆæ‰∏∫È¢ÜÂ§¥ËøõÁ®ã
                self.blocked_leader_process = self.env.active_process
                print(f"[{self.env.now:.2f}] üéØ Conveyor {self.id}: {actual_product.id} is the leader product (first in order)")
                
                print(f"[{self.env.now:.2f}] üîç Conveyor {self.id}: {buffer_name} buffer {len(chosen_buffer.items)}/{chosen_buffer.capacity}, can opeatate:{self.downstream_station.can_operate()}")
                
                if buffer_name == "upper_buffer" or buffer_name == "lower_buffer":
                    if len(chosen_buffer.items) >= chosen_buffer.capacity and self.status != DeviceStatus.BLOCKED:
                        # ‰∏ãÊ∏∏Â∑≤Êª°Êàñ‰∏ãÊ∏∏Â∑•Á´ô‰∏çÂèØÊìç‰ΩúÔºåÈòªÂ°ûÂÖ∂‰ªñ‰∫ßÂìÅ
                        self._block_all_products()
                    while len(chosen_buffer.items) >= chosen_buffer.capacity:
                        yield self.env.timeout(0.1)
                else:
                    if (len(chosen_buffer.items) >= chosen_buffer.capacity or not self.downstream_station.can_operate()) and self.status != DeviceStatus.BLOCKED:
                        # ‰∏ãÊ∏∏Â∑≤Êª°ÔºåÈòªÂ°ûÂÖ∂‰ªñ‰∫ßÂìÅ
                        self._block_all_products()
                    while len(chosen_buffer.items) >= chosen_buffer.capacity or not self.downstream_station.can_operate():
                        yield self.env.timeout(1)
                    
                yield chosen_buffer.put(actual_product)

                # ÊàêÂäüÊîæÂÖ•ÔºåÂ¶ÇÊûú‰πãÂâçÊòØÈòªÂ°ûÁä∂ÊÄÅÔºåÁé∞Âú®Ëß£Èô§
                if self.status == DeviceStatus.BLOCKED:
                    self._unblock_all_products()
                    
            else:
                # ‰∏çÊòØÁ¨¨‰∏Ä‰∏™‰∫ßÂìÅ
                print(f"[{self.env.now:.2f}] üì¶ Conveyor {self.id}: {actual_product.id} is NOT the leader product (order: {[p.id for p in self.main_buffer.items]})")
                
                # ÈùûÈ¢ÜÂ§¥‰∫ßÂìÅÈúÄË¶ÅÁ≠âÂæÖÔºåÁõ¥Âà∞ËΩÆÂà∞ÂÆÉÊàñËÄÖ‰º†ÈÄÅÂ∏¶Ëß£Èô§ÈòªÂ°û
                while self.status == DeviceStatus.BLOCKED:
                    print(f"[{self.env.now:.2f}] ‚è≥ Conveyor {self.id}: {actual_product.id} waiting for its turn or unblock...")
                    yield self.env.timeout(0.1)
                
                # Áé∞Âú®ÂèØ‰ª•Â∞ùËØïÊîæÂÖ•‰∏ãÊ∏∏
                yield chosen_buffer.put(actual_product)

            if not target_buffer in ["upper", "lower"]:
                actual_product.update_location(self.downstream_station.id, self.env.now)

            # Ê∏ÖÁêÜÊó∂Èó¥ËÆ∞ÂΩï
            if actual_product and actual_product.id in self.product_start_times:
                del self.product_start_times[actual_product.id]
            if actual_product and actual_product.id in self.product_elapsed_times:
                del self.product_elapsed_times[actual_product.id]

        except simpy.Interrupt as e:
            interrupt_reason = str(e.cause) if hasattr(e, 'cause') else "Unknown"
            
            # Â¶ÇÊûúÊòØAGVÂèñËµ∞‰∫ßÂìÅÁöÑ‰∏≠Êñ≠ÔºåÁõ¥Êé•ËøîÂõû
            if "Product removed by AGV" in interrupt_reason:
                print(f"[{self.env.now:.2f}] üöö TripleBufferConveyor {self.id}: Product {product.id} was taken by AGV, stopping process")
                # Êó∂Èó¥ËÆ∞ÂΩïÂ∑≤ÁªèÂú®pop()‰∏≠Ê∏ÖÁêÜ‰∫ÜÔºåËøôÈáå‰∏çÈúÄË¶ÅÂÜçÊ∏ÖÁêÜ
                return
            
            print(f"[{self.env.now:.2f}] ‚ö†Ô∏è TripleBufferConveyor {self.id}: Processing of product {product.id} was interrupted:{interrupt_reason}")
            
            # ËÆ∞ÂΩï‰∏≠Êñ≠Êó∂Â∑≤Áªè‰º†ËæìÁöÑÊó∂Èó¥ÔºàÈòªÂ°ûÂíåÊïÖÈöúÈÉΩÈúÄË¶ÅÔºâ
            if product.id in self.product_start_times:
                start_time = self.product_start_times[product.id]
                elapsed_before_interrupt = self.env.now - start_time
                self.product_elapsed_times[product.id] = self.product_elapsed_times.get(product.id, 0) + elapsed_before_interrupt
                del self.product_start_times[product.id]
                print(f"[{self.env.now:.2f}] üíæ Conveyor {self.id}: ‰∫ßÂìÅ {product.id} ‰∏≠Êñ≠ÂâçÂ∑≤‰º†Ëæì {elapsed_before_interrupt:.1f}sÔºåÂâ©‰Ωô {self.transfer_time - self.product_elapsed_times.get(product.id, 0):.1f}s")
            
        finally:
            self.publish_status()

    def _determine_target_buffer_for_product(self, product):
        """Ê†πÊçÆ‰∫ßÂìÅÁ±ªÂûãÂíåÂ∑•Ëâ∫Áä∂ÊÄÅÁ°ÆÂÆöÁõÆÊ†ábuffer"""
        if product.product_type != "P3":
            print(f"[{self.env.now:.2f}] üîç TripleBufferConveyor {self.id}: P1/P2‰∫ßÂìÅ {product.id} Áõ¥Êé•ËøõÂÖ•‰∏ãÊ∏∏Â∑•Á´ôbuffer")
            return "main"
        
        # P3‰∫ßÂìÅÁöÑÁâπÊÆäÈÄªËæëÔºöÂü∫‰∫éËÆøÈóÆÊ¨°Êï∞Âà§Êñ≠
        stationc_visits = product.visit_count.get("StationC", 0)
        
        print(f"[{self.env.now:.2f}] üîç TripleBufferConveyor {self.id}: P3‰∫ßÂìÅ {product.id} StationCÂ§ÑÁêÜÊ¨°Êï∞={stationc_visits}")
        
        if stationc_visits == 1:  # Á¨¨‰∏ÄÊ¨°ÂÆåÊàêStationCÂ§ÑÁêÜ
            print(f"[{self.env.now:.2f}] üîÑ TripleBufferConveyor {self.id}: P3‰∫ßÂìÅ {product.id} Á¨¨‰∏ÄÊ¨°Âú®StationCÂ§ÑÁêÜÂÆåÊàêÔºåÈúÄË¶ÅËøîÂ∑•Âà∞StationB")
            return "upper"  # ËøîÂ∑•Âà∞side buffer
        elif stationc_visits >= 2:  # Á¨¨‰∫åÊ¨°Âèä‰ª•ÂêéÂÆåÊàêStationCÂ§ÑÁêÜ
            print(f"[{self.env.now:.2f}] ‚úÖ TripleBufferConveyor {self.id}: P3‰∫ßÂìÅ {product.id} Á¨¨‰∫åÊ¨°Â§ÑÁêÜÂÆåÊàêÔºåÁªßÁª≠‰∏ªÊµÅÁ®ã")
            return "main"   # ËøõÂÖ•‰∏ªÊµÅÁ®ã
        else:
            print(f"[{self.env.now:.2f}] ‚ö†Ô∏è TripleBufferConveyor {self.id}: P3‰∫ßÂìÅ {product.id} Êú™Â§ÑÁêÜËøáÔºåÁªßÁª≠‰∏ªÊµÅÁ®ã")
            return "main"   # ÈªòËÆ§‰∏ªÊµÅÁ®ã
    
    def _choose_optimal_side_buffer(self):
        """ÈÄâÊã©ÊúÄ‰ºòÁöÑside bufferÔºàupperÊàñlowerÔºâ"""
        if self.downstream_station is None:
            return self.upper_buffer  # ÈªòËÆ§ËøîÂõûupper
        
        if self.upper_buffer.capacity - len(self.upper_buffer.items) >= self.lower_buffer.capacity - len(self.lower_buffer.items):
            if self.is_full("upper") and self.is_full("lower"):
                self.report_buffer_full("upper_buffer and lower_buffer are full")
            return self.upper_buffer
        else:
            return self.lower_buffer
        
    def recover(self):
        """Custom recovery logic for the TripleBufferConveyor."""
        print(f"[{self.env.now:.2f}] ‚úÖ TripleBufferConveyor {self.id} is recovering.")
        # ÊÅ¢Â§çÂêéÔºåÂÆÉÂ∫îËØ•ÁªßÁª≠Â∑•‰ΩúÔºåËÄå‰∏çÊòØÁ©∫Èó≤
    
    def _update_total_time(self):
        """Background process to update total time for KPI utilization calculation"""
        while True:
            yield self.env.timeout(10.0)  # Update every 10 seconds
            if self.kpi_calculator:
                self.kpi_calculator.update_device_utilization(self.id, self.line_id, self.env.now)
        self.set_status(DeviceStatus.WORKING)
        self.publish_status()
        
    def interrupt_all_processing(self):
        """Interrupt all active product processing. Called by fault system."""
        interrupted_count = 0
        for product_id, process in list(self.active_processes.items()):
            if process.is_alive:
                process.interrupt("Fault injected")
                interrupted_count += 1
        print(f"[{self.env.now:.2f}] üö´ TripleBufferConveyor {self.id}: Interrupted {interrupted_count} product processes")
        return interrupted_count

    def _block_all_products(self, reason="Downstream or side buffer blocked"):
        """ÈòªÂ°ûÊâÄÊúâ‰∫ßÂìÅÂ§ÑÁêÜÔºàÈô§‰∫ÜÊ≠£Âú®Á≠âÂæÖÁöÑÈ¢ÜÂ§¥‰∫ßÂìÅÔºâ"""
        if self.status == DeviceStatus.BLOCKED:
            print(f"[{self.env.now:.2f}] [DEBUG] TripleBufferConveyor {self.id}: already blocked, skip")
            return  # Â∑≤ÁªèÂ§Ñ‰∫éÈòªÂ°ûÁä∂ÊÄÅ
        
        # ËÆæÁΩÆÈòªÂ°ûÁä∂ÊÄÅ
        self.set_status(DeviceStatus.BLOCKED)
        self.publish_status("Conveyor blocked - downstream or side buffer full")
        
        # ‰∏≠Êñ≠ÊâÄÊúâÈùûÈ¢ÜÂ§¥ÁöÑÊ¥ªË∑ÉËøõÁ®ãÔºà‰∏éinterrupt_all_processingÁ±ª‰ººÔºâ
        blocked_count = 0
        for product_id, process in list(self.active_processes.items()):
            if process != self.blocked_leader_process and process.is_alive:
                process.interrupt(reason)
                blocked_count += 1
        
        print(f"[{self.env.now:.2f}] üöß Conveyor {self.id}: Blocked {blocked_count} products due to downstream blockage")

    def _unblock_all_products(self):
        """Ëß£Èô§ÈòªÂ°ûÔºåÂÖÅËÆ∏‰∫ßÂìÅÁªßÁª≠Â§ÑÁêÜ"""
        if self.status != DeviceStatus.BLOCKED:
            print(f"[{self.env.now:.2f}] [DEBUG] TripleBufferConveyor {self.id}: not blocked, skip unblock")
            return  # ‰∏çÂú®ÈòªÂ°ûÁä∂ÊÄÅ
        
        self.set_status(DeviceStatus.WORKING)
        self.publish_status("Conveyor unblocked - resuming operation")
        self.blocked_leader_process = None
        
        print(f"[{self.env.now:.2f}] ‚úÖ Conveyor {self.id}: Unblocked, products can resume")


================================================
File: src/simulation/entities/product.py
================================================
# src/simulation/entities/product.py
import uuid
import random
from typing import List, Tuple, Dict, Optional
from enum import Enum
from dataclasses import dataclass

class QualityStatus(Enum):
    """‰∫ßÂìÅË¥®ÈáèÁä∂ÊÄÅ"""
    UNKNOWN = "unknown"          # Êú™Ê£ÄÊµã
    MAJOR_DEFECT = "major_defect"  # ‰∏•ÈáçÁº∫Èô∑ÔºåÈúÄËøîÂ∑•
    SCRAP = "scrap"             # Êä•Â∫ü

class Product:
    """
    Represents a single product unit being manufactured in the factory.
    
    Attributes:
        id (str): A unique identifier for the product instance.
        product_type (str): The type of the product (e.g., 'P1', 'P2').
        order_id (str): The ID of the order this product belongs to.
        history (List[Tuple[float, str]]): A log of events for this product.
        quality_status (QualityStatus): Current quality status
        quality_score (float): Quality score
        processing_stations (List[str]): Records of stations processed
        rework_count (int): ËøîÂ∑•Ê¨°Êï∞
        inspection_count (int): Ê£ÄÊµãÊ¨°Êï∞
        current_location (str): ÂΩìÂâçÊâÄÂú®‰ΩçÁΩÆ
        process_step (int): ÂΩìÂâçÂ∑•Ëâ∫Ê≠•È™§Á¥¢Âºï
        visit_count (Dict[str, int]): Ë∑üË∏™ËÆøÈóÆÊØè‰∏™Â∑•Á´ôÁöÑÊ¨°Êï∞
        
    """
    
    # ‰∫ßÂìÅÂ∑•Ëâ∫Ë∑ØÁ∫øÂÆö‰πâ - ÂÆö‰πâÊØèÁßç‰∫ßÂìÅÁ±ªÂûãÁöÑÊ†áÂáÜÂä†Â∑•È°∫Â∫è
    PROCESS_ROUTES = {
        "P1": ["RawMaterial", "StationA", "StationB", "StationC", "QualityCheck", "Warehouse"],
        "P2": ["RawMaterial", "StationA", "StationB", "StationC", "QualityCheck", "Warehouse"],  
        "P3": ["RawMaterial", "StationA", "StationB", "StationC", "StationB", "StationC", "QualityCheck", "Warehouse"]
    }
    
    def __init__(self, product_type: str, order_id: str):
        self.id: str = f"prod_{product_type[1]}_{uuid.uuid4().hex[:8]}"
        self.product_type: str = product_type
        self.order_id: str = order_id
        self.history: List[Tuple[float, str]] = []
        
        # Ë¥®ÈáèÁõ∏ÂÖ≥Â±ûÊÄß
        self.quality_status: QualityStatus = QualityStatus.UNKNOWN
        self.processing_stations: List[str] = []
        self.rework_count: int = 0
        self.inspection_count: int = 0
        
        # ÁßªÂä®ÊéßÂà∂Áõ∏ÂÖ≥Â±ûÊÄß
        self.current_location: str = "RawMaterial"  # ÂàùÂßã‰ΩçÁΩÆÂú®ÂéüÊñô‰ªìÂ∫ì
        self.process_step: int = 0  # ÂΩìÂâçÂú®Â∑•Ëâ∫Ë∑ØÁ∫ø‰∏≠ÁöÑÊ≠•È™§Á¥¢Âºï
        self.visit_count: Dict[str, int] = {}  # Ë∑üË∏™ËÆøÈóÆÊØè‰∏™Â∑•Á´ôÁöÑÊ¨°Êï∞
        
        # Ë¥®ÈáèËØÑÂàÜÁ≥ªÁªü
        self.quality_score: float = random.uniform(0.85, 0.95)  # ÂΩìÂâçË¥®ÈáèÂàÜÊï∞
        self.quality_factors: Dict[str, float] = {  # Ë¥®ÈáèÂΩ±ÂìçÂõ†Á¥†
            "processing_defects": 0.0,  # Âä†Â∑•Áº∫Èô∑Á¥ØÁßØ
            "rework_improvement": 0.0,  # ËøîÂ∑•ÊîπÂñÑ
            "handling_damage": 0.0      # Êê¨ËøêÊçü‰º§
        }
        
    def __repr__(self) -> str:
        return f"Product(id='{self.id}', type='{self.product_type}', location='{self.current_location}', quality='{self.quality_status.value}')"


    def add_history(self, timestamp: float, event: str):
        """Adds a new event to the product's history log."""
        self.history.append((timestamp, event))
        
    def next_move_checker(self, timestamp: float, target_location: str) -> Tuple[bool, str]:
        """
        Ê£ÄÊü•‰∏ã‰∏Ä‰∏™moveÊòØÂê¶Á¨¶ÂêàÂΩìÂâç‰∫ßÂìÅÁöÑstation orderpolicy
        
        Args:
            timestamp: ÂΩìÂâçÊó∂Èó¥Êà≥
            target_location: ÁõÆÊ†á‰ΩçÁΩÆ
            
        Returns:
            Tuple[bool, str]: (ÊòØÂê¶ÂÖÅËÆ∏ÁßªÂä®, ËØ¥Êòé‰ø°ÊÅØ)
        """
        # Ëé∑ÂèñÂΩìÂâç‰∫ßÂìÅÁöÑÂ∑•Ëâ∫Ë∑ØÁ∫ø
        route = self.PROCESS_ROUTES.get(self.product_type)
        if not route:
            return False, f"Êú™Áü•‰∫ßÂìÅÁ±ªÂûã: {self.product_type}"
        
        # Ê£ÄÊü•ÂΩìÂâç‰ΩçÁΩÆÊòØÂê¶Âú®Ë∑ØÁ∫ø‰∏≠
        if self.current_location not in route:
            return False, f"ÂΩìÂâç‰ΩçÁΩÆ {self.current_location} ‰∏çÂú®Â∑•Ëâ∫Ë∑ØÁ∫ø‰∏≠"
        
        current_index = route.index(self.current_location)
        
        # Â§ÑÁêÜÁâπÊÆäÊÉÖÂÜµÔºöP3‰∫ßÂìÅÁöÑËøîÂ∑•ÈÄªËæë
        if self._is_p3_rework_move(target_location, current_index):
            return True, f"P3‰∫ßÂìÅ‰ªé {self.current_location} ËøîÂ∑•Âà∞ {target_location}"
        
        # Ê†áÂáÜÈ°∫Â∫èÊ£ÄÊü•ÔºöÂè™ËÉΩÂâçËøõÂà∞‰∏ã‰∏Ä‰∏™Â∑•Á´ô
        if current_index >= len(route) - 1:
            return False, f"‰∫ßÂìÅÂ∑≤Âà∞ËææÊúÄÁªà‰ΩçÁΩÆ"
        
        expected_next = route[current_index + 1]
        
        if target_location == expected_next:
            return True, f"ÂÖÅËÆ∏‰ªé {self.current_location} ÁßªÂä®Âà∞ {target_location}"
        
        # Ê£ÄÊü•ÊòØÂê¶‰∏∫Ë¥®Ê£ÄËøîÂ∑•ÁßªÂä®
        if self.rework_count > 0:
            # ËøîÂ∑•Êó∂ÂÖÅËÆ∏‰ªéQualityCheckÂõûÂà∞StationC
            if self.current_location == "QualityCheck" and target_location.startswith("StationC"):
                return True, f"Ë¥®Ê£ÄËøîÂ∑•ÁßªÂä®Ôºö‰ªé {self.current_location} ËøîÂõûÂà∞ {target_location}"
            # ËøîÂ∑•ÂÆåÊàêÂêéÂèØ‰ª•ÂÜçÊ¨°ÂéªË¥®Ê£Ä
            elif target_location == "QualityCheck" and self.current_location in route:
                return True, f"ËøîÂ∑•ÂêéÂÜçÊ¨°Ë¥®Ê£ÄÔºö‰ªé {self.current_location} Âà∞ {target_location}"
        
        # ÂÖ∂‰ªñÊÉÖÂÜµÂùá‰∏çÂÖÅËÆ∏
        return False, f"‰∏çÂÖÅËÆ∏ÁöÑÁßªÂä®Ôºö‰ªé {self.current_location} Âà∞ {target_location}ÔºåÊúüÊúõ‰∏ã‰∏ÄÁ´ô: {expected_next}"
    
    def _is_p3_rework_move(self, target_location: str, current_index: int) -> bool:
        """Ê£ÄÊü•ÊòØÂê¶‰∏∫P3‰∫ßÂìÅÁöÑÊ†áÂáÜÂ∑•Ëâ∫ÊµÅÁ®ãÁßªÂä®ÔºàÈùûË¥®Ê£ÄËøîÂ∑•Ôºâ"""
        if self.product_type != "P3" or self.current_location != "StationC":
            return False
            
        stationc_visits = self.visit_count.get("StationC", 0)
        
        # P3Ê†áÂáÜÂ∑•Ëâ∫ÔºöÁ¨¨‰∏ÄÊ¨°Âú®StationCÂêéÈúÄË¶ÅÂéªStationB
        if stationc_visits == 1 and target_location == "StationB" and self.rework_count == 0:
            return True
        
        # P3Ê†áÂáÜÂ∑•Ëâ∫ÔºöÁ¨¨‰∫åÊ¨°Âú®StationCÂêéÂèØ‰ª•ÂéªË¥®Ê£Ä
        if stationc_visits == 2 and target_location == "QualityCheck":
            return True
            
        return False
    
    def update_location(self, new_location: str, timestamp: float) -> bool:
        """
        Êõ¥Êñ∞‰∫ßÂìÅ‰ΩçÁΩÆÔºàÂ∫îÂú®ÁßªÂä®Ê£ÄÊü•ÈÄöËøáÂêéË∞ÉÁî®Ôºâ
        
        Args:
            new_location: Êñ∞‰ΩçÁΩÆ
            timestamp: Êó∂Èó¥Êà≥
            
        Returns:
            bool: Êõ¥Êñ∞ÊòØÂê¶ÊàêÂäü
        """
        # Êõ¥Êñ∞‰ΩçÁΩÆ
        old_location = self.current_location
        self.current_location = new_location
        
        # Ê≥®ÊÑèÔºöËÆøÈóÆÊ¨°Êï∞Â∑≤Âú® process_at_station ‰∏≠Êõ¥Êñ∞ÔºåËøôÈáå‰∏çÂÜçÊõ¥Êñ∞
        # ÈÅøÂÖçÈáçÂ§çËÆ°Êï∞
        
        # Êõ¥Êñ∞Â∑•Ëâ∫Ê≠•È™§Á¥¢Âºï
        route = self.PROCESS_ROUTES[self.product_type]
        if new_location in route:
            self.process_step = route.index(new_location)
        
        # Êê¨ËøêËøáÁ®ãÂèØËÉΩÈÄ†ÊàêÊçü‰º§
        if old_location != "RawMaterial" and new_location != "Warehouse":
            damage_probability = 0.05  # 5%Ê¶ÇÁéá
            if random.random() < damage_probability:
                damage_impact = random.uniform(0.01, 0.03)  # 1-3%ÁöÑË¥®ÈáèÊçüÂ§±
                self.quality_factors["handling_damage"] += damage_impact
                self._update_quality_score()
                self.add_history(timestamp, f"Handling damage during transport: -{damage_impact:.2%}")
        
        # ËÆ∞ÂΩïÂéÜÂè≤
        self.add_history(timestamp, f"Moved from {old_location} to {new_location}")
        
        print(f"[{timestamp:.2f}] üì¶ {self.id}: ÊàêÂäüÁßªÂä® {old_location} ‚Üí {new_location}")
        return True
    
    def get_next_expected_location(self) -> Optional[str]:
        """Ëé∑Âèñ‰∏ã‰∏Ä‰∏™ÊúüÊúõÁöÑ‰ΩçÁΩÆ"""
        route = self.PROCESS_ROUTES.get(self.product_type)
        if not route or self.current_location not in route:
            return None
        
        current_index = route.index(self.current_location)
        
        # Â§ÑÁêÜP3Ê†áÂáÜÂ∑•Ëâ∫ÊµÅÁ®ãÔºàÈùûË¥®Ê£ÄËøîÂ∑•Ôºâ
        if self.product_type == "P3" and self.current_location == "StationC" and self.rework_count == 0:
            stationc_visits = self.visit_count.get("StationC", 0)
            if stationc_visits == 1:  # Á¨¨‰∏ÄÊ¨°Âú®StationC
                return "StationB"  # ÈúÄË¶ÅËøîÂõûStationB
            elif stationc_visits == 2:  # Á¨¨‰∫åÊ¨°Âú®StationC  
                return "QualityCheck"  # ÂèØ‰ª•ÂéªË¥®Ê£ÄÁ´ô
        
        # Ê†áÂáÜÊÉÖÂÜµÔºöËøîÂõû‰∏ã‰∏Ä‰∏™‰ΩçÁΩÆ
        if current_index < len(route) - 1:
            return route[current_index + 1]
        
        return None  # Â∑≤ÁªèÂà∞ËææÊúÄÁªà‰ΩçÁΩÆ
    
    def get_process_completion_percentage(self) -> float:
        """Ëé∑ÂèñÂ∑•Ëâ∫ÂÆåÊàêÁôæÂàÜÊØî"""
        route = self.PROCESS_ROUTES.get(self.product_type)
        if not route or self.current_location not in route:
            return 0.0
        
        total_steps = len(route) - 1  # ÂáèÂéªËµ∑Âßã‰ΩçÁΩÆ
        current_index = route.index(self.current_location)
        return (current_index / total_steps) * 100.0
        
    def process_at_station(self, station_id: str, timestamp: float):
        """ËÆ∞ÂΩïÂú®Â∑•Á´ôÁöÑÂ§ÑÁêÜÔºà‰∏çËøõË°åÁßªÂä®Ê£ÄÊü•ÔºåÂÅáËÆæ‰∫ßÂìÅÂ∑≤ÁªèÂú®ËØ•Â∑•Á´ôÔºâ"""
        # ËÆ∞ÂΩïË∞ÉËØï‰ø°ÊÅØ
        old_count = self.visit_count.get(station_id, 0)
        
        self.processing_stations.append(station_id)
        self.add_history(timestamp, f"Processed at {station_id}")
            
        # Âä†Â∑•ËøáÁ®ãÂèØËÉΩÂºïÂÖ•Áº∫Èô∑
        if station_id.startswith("Station"):
            # ÊØèÊ¨°Âä†Â∑•ÊúâÊ¶ÇÁéáÂºïÂÖ•Â∞èÁº∫Èô∑
            defect_probability = 0.1  # 10%Ê¶ÇÁéá
            if random.random() < defect_probability:
                defect_impact = random.uniform(0.02, 0.05)  # 2-5%ÁöÑË¥®ÈáèÊçüÂ§±
                self.quality_factors["processing_defects"] += defect_impact
                self._update_quality_score()
                self.add_history(timestamp, f"Processing defect at {station_id}: -{defect_impact:.2%}")
        
        # Êõ¥Êñ∞ËÆøÈóÆËÆ°Êï∞ÔºàÈáçË¶ÅÔºöÁî®‰∫éP3‰∫ßÂìÅÁöÑÊµÅÁ®ãÊéßÂà∂Ôºâ
        self.visit_count[station_id] = self.visit_count.get(station_id, 0) + 1
        
        print(f"[{timestamp:.2f}] üìä {self.id}: {station_id} ËÆøÈóÆÊ¨°Êï∞: {old_count} ‚Üí {self.visit_count[station_id]}")
        
    def start_inspection(self, timestamp: float):
        """ÂºÄÂßãË¥®ÈáèÊ£ÄÊµã"""
        self.inspection_count += 1
        self.add_history(timestamp, f"Quality inspection started (#{self.inspection_count})")
        
    def complete_inspection(self, timestamp: float, result: QualityStatus):
        """ÂÆåÊàêË¥®ÈáèÊ£ÄÊµã"""
        self.quality_status = result
        self.add_history(timestamp, f"Quality inspection completed: {result.value}")
        
    def start_rework(self, timestamp: float, target_station: str):
        """ÂºÄÂßãËøîÂ∑•ÔºàË¥®Ê£Ä‰∏çÂêàÊ†ºÂØºËá¥Ôºâ"""
        self.rework_count += 1
        self.quality_status = QualityStatus.UNKNOWN  # ËøîÂ∑•ÂêéÈáçÊñ∞Ê£ÄÊµã
        
        # ËøîÂ∑•ÊîπÂñÑË¥®ÈáèÔºöÂè™ÂÖÅËÆ∏‰∏ÄÊ¨°ËøîÂ∑•Ôºå‰øÆÂ§ç70%ÁöÑÂä†Â∑•Áº∫Èô∑
        if self.rework_count == 1:
            actual_improvement = self.quality_factors["processing_defects"] * 0.7
        else:
            actual_improvement = 0  # ‰∏çÂÖÅËÆ∏Á¨¨‰∫åÊ¨°ËøîÂ∑•
        
        if actual_improvement > 0:
            self.quality_factors["rework_improvement"] += actual_improvement
            self.quality_factors["processing_defects"] = max(0, self.quality_factors["processing_defects"] - actual_improvement)
            self._update_quality_score()
            self.add_history(timestamp, f"Rework #{self.rework_count} -> {target_station}, quality improved by {actual_improvement:.2%}")
        else:
            self.add_history(timestamp, f"Rework #{self.rework_count} -> {target_station}, no improvement possible")
        
        self.add_history(timestamp, f"Marked for rework to {target_station}")
        
    def get_quality_summary(self) -> Dict:
        """Ëé∑ÂèñË¥®ÈáèÊëòË¶Å‰ø°ÊÅØ"""
        return {
            "id": self.id,
            "product_type": self.product_type,
            "quality_status": self.quality_status.value,
            "quality_score": round(self.quality_score, 2),
            "rework_count": self.rework_count,
            "inspection_count": self.inspection_count,
            "processing_stations": self.processing_stations.copy(),
            "can_rework": self.rework_count == 0,
            "quality_factors": self.quality_factors.copy()
        }
    
    def _update_quality_score(self):
        """Ê†πÊçÆÂêÑÁßçÂõ†Á¥†Êõ¥Êñ∞Ë¥®ÈáèÂàÜÊï∞"""
        # ËÆ°ÁÆóÊÄªË¥®ÈáèÂàÜÊï∞
        total_impact = (
            self.quality_factors["processing_defects"] +
            self.quality_factors["handling_damage"] -
            self.quality_factors["rework_improvement"]
        )
        
        # Êõ¥Êñ∞ÂΩìÂâçË¥®ÈáèÂàÜÊï∞ÔºåÁ°Æ‰øùÂú®0-1ËåÉÂõ¥ÂÜÖ
        self.quality_score = max(0.0, min(1.0, self.quality_score - total_impact))
        
    def simulate_aging(self, timestamp: float, aging_factor: float = 0.01):
        """Ê®°Êãü‰∫ßÂìÅËÄÅÂåñÔºàÂ¶ÇÂú®‰ªìÂ∫ìÁ≠âÂæÖÊó∂Ôºâ"""
        self.quality_factors["handling_damage"] += aging_factor
        self._update_quality_score()
        self.add_history(timestamp, f"Product aging: -{aging_factor:.2%}")


================================================
File: src/simulation/entities/quality_checker.py
================================================
# src/simulation/entities/quality_checker.py
import simpy
import random
from typing import Dict, Tuple, Optional
from enum import Enum

from config.schemas import DeviceStatus, StationStatus
from src.simulation.entities.station import Station
from src.simulation.entities.product import Product, QualityStatus
from src.utils.topic_manager import TopicManager

class SimpleDecision(Enum):
    """ÁÆÄÂåñÁöÑË¥®ÈáèÊ£ÄÊµãÂÜ≥Á≠ñ"""
    PASS = "pass"           # ÈÄöËøá
    SCRAP = "scrap"         # Êä•Â∫ü
    REWORK = "rework"       # ËøîÂ∑• (ÂõûÂà∞‰∏ä‰∏Ä‰∏™Â∑•Á´ô)

class QualityChecker(Station):
    """
    ÁÆÄÂåñÁâàË¥®ÈáèÊ£ÄÊµãÁ´ô - Âè™‰øùÁïôÊ†∏ÂøÉÂäüËÉΩ
    
    Ê†∏ÂøÉÈÄªËæëÔºö
    1. Âü∫‰∫é‰∫ßÂìÅË¥®ÈáèÂàÜÊï∞ÂÅöÂá∫ÁÆÄÂçïÂÜ≥Á≠ñ
    2. ÈÄöËøá/Êä•Â∫ü/ËøîÂ∑•‰∏âÁßçÁªìÊûú
    3. ÊúÄÂ∞èÂåñÈÖçÁΩÆÂèÇÊï∞
    4. Â¢ûÂä†output_bufferÔºåÊª°Êó∂ÈòªÂ°ûÂπ∂ÂëäË≠¶
    """
    
    def __init__(
        self,
        env: simpy.Environment,
        id: str,
        position: Tuple[int, int],
        buffer_size: int = 1,
        processing_times: Dict[str, Tuple[int, int]] = {},
        pass_threshold: float = 80.0,  # ÂêàÊ†ºÈòàÂÄº
        scrap_threshold: float = 60.0,  # Êä•Â∫üÈòàÂÄº
        output_buffer_capacity: int = 5,  # Êñ∞Â¢ûÔºåoutput bufferÂÆπÈáè
        mqtt_client=None,
        interacting_points: list = [],
        topic_manager: Optional[TopicManager] = None,
        line_id: Optional[str] = None
    ):
        # ÈªòËÆ§Ê£ÄÊµãÊó∂Èó¥
        if processing_times is None:
            processing_times = {
                "P1": (10, 15),
                "P2": (12, 18), 
                "P3": (10, 15)
            }
        
        # Initialize output buffer before calling super().__init__() 
        # since publish_status() is called in parent's __init__
        self.pass_threshold = pass_threshold
        self.scrap_threshold = scrap_threshold
        self.output_buffer_capacity = output_buffer_capacity
        self.output_buffer = simpy.Store(env, capacity=output_buffer_capacity)
        
        super().__init__(env, id, position, topic_manager=topic_manager, line_id=line_id, buffer_size=buffer_size, processing_times=processing_times, downstream_conveyor=None, mqtt_client=mqtt_client, interacting_points=interacting_points)
        
        # ÁÆÄÂçïÁªüËÆ°
        self.stats = {
            "inspected_count": 0,
            "total_processing_time": 0.0,
            "average_processing_time": 0.0,
            "passed_count": 0,
            "reworked_count": 0,
            "scrapped_count": 0,
            "working_time": 0.0,  # Total time spent in PROCESSING status
            "start_time": env.now  # Track when station started
        }
        
        print(f"[{self.env.now:.2f}] üîç {self.id}: Simple quality checker ready (pass‚â•{self.pass_threshold}%, scrap‚â§{self.scrap_threshold}%)")
        # The run process is already started by the parent Station class
        
    def publish_status(self, message: Optional[str] = None):
        """Publishes the current status of the station to MQTT."""
        if not self.mqtt_client or not self.mqtt_client.is_connected():
            return
            
        status_data = StationStatus(
            timestamp=self.env.now,
            source_id=self.id,
            status=self.status,
            buffer=[p.id for p in self.buffer.items],
            stats=self.stats,
            output_buffer=[p.id for p in self.output_buffer.items],
            message=message,
        )
        if self.topic_manager and self.line_id:
            topic = self.topic_manager.get_station_status_topic(self.line_id, self.id)
        else:
            from config.topics import get_station_status_topic
            topic = get_station_status_topic(self.id)
        self.mqtt_client.publish(topic, status_data.model_dump_json(), retain=False)

    def process_product(self, product: Product):
        """
        Quality check process following Station's timeout-get-put pattern.
        """
        try:
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: process_product called for {product.id}, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            # Check if the device can operate
            if not self.can_operate():
                msg = f"[{self.env.now:.2f}] ‚ö†Ô∏è  {self.id}: can not process product, device is not available"
                print(msg)
                self.publish_status(msg)
                return

            self.set_status(DeviceStatus.PROCESSING)
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: set_status(PROCESSING), buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            self.publish_status()

            # Record processing start and get processing time
            min_time, max_time = self.processing_times.get(product.product_type, (10, 15))
            processing_time = random.uniform(min_time, max_time)
            
            # Apply efficiency and fault impacts
            efficiency_factor = getattr(self.performance_metrics, 'efficiency_rate', 100.0) / 100.0
            actual_processing_time = processing_time / efficiency_factor
            
            msg = f"[{self.env.now:.2f}] üîç {self.id}: Ê£ÄÊµã‰∫ßÂìÅ‰∏≠... (È¢ÑËÆ°{actual_processing_time:.1f}s)"
            print(msg)
            self.publish_status(msg)
            
            # The actual processing work (timeout-get pattern like Station)
            yield self.env.timeout(actual_processing_time)
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: timeout finished for {product.id}, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            product = yield self.buffer.get()
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: got product {product.id} from buffer, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            product.process_at_station(self.id, self.env.now)
            
            # Update statistics upon successful completion
            self.stats["inspected_count"] += 1
            self.stats["total_processing_time"] += actual_processing_time
            self.stats["average_processing_time"] = (
                self.stats["total_processing_time"] / self.stats["inspected_count"]
            )
            
            # Perform quality inspection
            decision = self._make_simple_decision(product)
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: decision for {product.id} is {decision}, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            
            # Processing finished successfully
            msg = f"[{self.env.now:.2f}] {self.id}: {product.id} finished inspecting, actual processing time: {actual_processing_time:.1f}s"
            print(msg)
            self.publish_status(msg)
            
            # Execute decision (equivalent to transfer_product_to_next_stage)
            yield self.env.process(self._execute_quality_decision(product, decision))

        except simpy.Interrupt as e:
            print(f"[{self.env.now:.2f}] ‚ö†Ô∏è {self.id}: Inspection of product {product.id} was interrupted: {e.cause}")
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: INTERRUPT, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            if product not in self.buffer.items:
                # ‰∫ßÂìÅÂ∑≤ÂèñÂá∫ÔºåËØ¥ÊòéÊ£ÄÊµãÊó∂Èó¥Â∑≤ÁªèÂÆåÊàêÔºåÂ∫îËØ•ÁªßÁª≠ÊµÅËΩ¨
                print(f"[{self.env.now:.2f}] üöö {self.id}: ‰∫ßÂìÅ {product.id} Â∑≤Ê£ÄÊµãÂÆåÊàêÔºåÁªßÁª≠ÊµÅËΩ¨")
                decision = self._make_simple_decision(product)
                yield self.env.process(self._execute_quality_decision(product, decision))
            else:
                # ‰∫ßÂìÅËøòÂú®buffer‰∏≠ÔºåËØ¥ÊòéÂú®timeoutÊúüÈó¥Ë¢´‰∏≠Êñ≠ÔºåÁ≠âÂæÖ‰∏ãÊ¨°Â§ÑÁêÜ
                print(f"[{self.env.now:.2f}] ‚è∏Ô∏è  {self.id}: ‰∫ßÂìÅ {product.id} Ê£ÄÊµãË¢´‰∏≠Êñ≠ÔºåÁïôÂú®buffer‰∏≠")
        finally:
            print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: process_product finally for {product.id}, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
            # Clear the action handle once the process is complete or interrupted
            self.action = None

    def _execute_quality_decision(self, product: Product, decision: SimpleDecision):
        """Execute quality decision (equivalent to _transfer_product_to_next_stage)"""
        print(f"[{self.env.now:.2f}] [DEBUG] {self.id}: _execute_quality_decision for {product.id}, decision={decision}, buffer={len(self.buffer.items)}, output_buffer={len(self.output_buffer.items)}")
        
        if decision == SimpleDecision.PASS:
            self.stats["passed_count"] += 1
            msg = f"[{self.env.now:.2f}] ‚úÖ {self.id}: {product.id} passed quality inspection"
            print(msg)
            self.publish_status(msg)
            
            # Report to KPI calculator
            if hasattr(self, 'kpi_calculator') and self.kpi_calculator:
                self.kpi_calculator.complete_order_item(product.order_id, product.product_type, passed_quality=True)
            
            # Check if output buffer is full and report if needed
            if len(self.output_buffer.items) >= self.output_buffer_capacity:
                self.set_status(DeviceStatus.BLOCKED)
                msg = f"[{self.env.now:.2f}] ‚ö†Ô∏è {self.id}: output buffer is full, station is blocked"
                print(msg)
                self.publish_status(msg)
                self.report_buffer_full("output_buffer")
            # TODO: Quality Checker do not have downstream device, dont care about whether downstream can_operate, just cares about buffer full
            # Put product into output buffer (may block if full)
            yield self.output_buffer.put(product)
            msg = f"[{self.env.now:.2f}] üì¶ {self.id}: ‰∫ßÂìÅ {product.id} ÊîæÂÖ•output bufferÔºåÁ≠âÂæÖAGV/‰∫∫Â∑•Êê¨Ëøê"
            
        elif decision == SimpleDecision.SCRAP:

            # Report to KPI calculator
            if hasattr(self, 'kpi_calculator') and self.kpi_calculator:
                self.kpi_calculator.complete_order_item(product.order_id, product.product_type, passed_quality=False)
            
            yield self.env.process(self._handle_product_scrap(product, "quality_inspection_failed"))
            self.stats["scrapped_count"] += 1
            self.set_status(DeviceStatus.SCRAP)
            msg = f"[{self.env.now:.2f}] ‚ùå {self.id}: {product.id} scrapping"
            self.publish_status(msg)
            msg = f"[{self.env.now:.2f}] ‚ö†Ô∏è {self.id}: {product.id} scrapped"

        elif decision == SimpleDecision.REWORK:
            self.stats["reworked_count"] += 1
            # ËøîÂ∑•ÔºöÂõûÂà∞ÊúÄÂêé‰∏Ä‰∏™Âä†Â∑•Â∑•Á´ô
            last_station = self._get_last_processing_station(product)
            if last_station:
                # Ê£ÄÊü•output bufferÊòØÂê¶Êª°
                if len(self.output_buffer.items) >= self.output_buffer_capacity:
                    self.set_status(DeviceStatus.BLOCKED)
                    self.publish_status("output buffer is full, station is blocked")
                    self.report_buffer_full("output_buffer")
                
                # Â∞ÜËøîÂ∑•‰∫ßÂìÅÊîæÂÖ•output bufferÔºåÁ≠âÂæÖAGVËøêÈÄÅ
                yield self.output_buffer.put(product)
                msg = f"[{self.env.now:.2f}] üì¶ {self.id}: {product.id} reworked to {last_station}, put into output buffer, waiting for AGV to deliver"
                
            else:
                msg = f"[{self.env.now:.2f}] ‚ö†Ô∏è  {self.id}: can not determine rework station, product scrapped"
                yield self.env.process(self._handle_product_scrap(product, "rework_failed"))
        
        # Set status back to IDLE after the operation is complete
        self.set_status(DeviceStatus.IDLE)
        print(msg)
        self.publish_status(msg if msg else None)

    def _handle_product_scrap(self, product, reason: str):
        """Handle product scrapping due to quality issues"""
        
        # Set product status to scrapped
        product.quality_score = 0.0
        product.quality_status = QualityStatus.SCRAP
        
        # Simulate scrap handling time
        yield self.env.timeout(2.0)

    def _make_simple_decision(self, product: Product) -> SimpleDecision:
        """ÁÆÄÂåñÁöÑÂÜ≥Á≠ñÈÄªËæëÔºöÊúÄÂ§ö‰∏ÄÊ¨°ËøîÂ∑•"""
        quality_percentage = product.quality_score * 100
        
        # Â¶ÇÊûúÂ∑≤ÁªèËøîÂ∑•Ëøá‰∏ÄÊ¨°
        if product.rework_count >= 1:
            # ËøîÂ∑•Âêé‰ªçÁÑ∂‰∏çÂêàÊ†ºÔºåÁõ¥Êé•Êä•Â∫ü
            if quality_percentage < self.pass_threshold:
                return SimpleDecision.SCRAP
            else:
                return SimpleDecision.PASS
        
        # È¶ñÊ¨°Ê£ÄÊµãÂÜ≥Á≠ñ
        if quality_percentage >= self.pass_threshold:
            return SimpleDecision.PASS
        elif quality_percentage <= self.scrap_threshold:
            return SimpleDecision.SCRAP
        else:
            # ‰∏≠Èó¥Ë¥®ÈáèÔºåÂèØ‰ª•ËøîÂ∑•
            return SimpleDecision.REWORK

    def _get_last_processing_station(self, product: Product) -> str:
        """Ëé∑Âèñ‰∫ßÂìÅÊúÄÂêéÂ§ÑÁêÜÁöÑÂ∑•Á´ô (ÊéíÈô§QualityCheck)"""
        processing_stations = [s for s in product.processing_stations if s != self.id]
        return processing_stations[-1] if processing_stations else ""

    def get_simple_stats(self) -> Dict:
        """Ëé∑ÂèñÁÆÄÂåñÁöÑÁªüËÆ°‰ø°ÊÅØ"""
        total = self.stats["inspected_count"]
        if total == 0:
            return {"inspected": 0, "pass_rate": 0, "scrap_rate": 0, "rework_rate": 0}
            
        return {
            "inspected": total,
            "passed": self.stats["passed_count"],
            "scrapped": self.stats["scrapped_count"], 
            "reworked": self.stats["reworked_count"],
            "pass_rate": round(self.stats["passed_count"] / total * 100, 1),
            "scrap_rate": round(self.stats["scrapped_count"] / total * 100, 1),
            "rework_rate": round(self.stats["reworked_count"] / total * 100, 1),
            "buffer_level": self.get_buffer_level()
        }

    def reset_stats(self):
        """ÈáçÁΩÆÁªüËÆ°Êï∞ÊçÆ"""
        self.stats = {
            "inspected_count": 0,
            "total_processing_time": 0.0,
            "average_processing_time": 0.0,
            "passed_count": 0,
            "reworked_count": 0,
            "scrapped_count": 0,
            "working_time": 0.0,  # Total time spent in PROCESSING status
            "start_time": self.env.now  # Track when station started
        }
    
    def pop(self, buffer_type=None):
        """Remove and return a product from the specified buffer.
        
        Args:
            buffer_type: "buffer" for input buffer, "output_buffer" for output buffer
            
        Returns:
            The removed product
        """
        if buffer_type == "output_buffer" or buffer_type is None:
            # ‰ªé output_buffer ÂèñË¥ßÔºàÈªòËÆ§Ôºâ
            product = yield self.output_buffer.get()
            msg = f"Product {product.id} taken from {self.id} output_buffer by AGV"
        else:
            # ‰ªéËæìÂÖ• buffer ÂèñË¥ßÔºåÈúÄË¶ÅÊ£ÄÊü•ÊòØÂê¶Ê≠£Âú®Â§ÑÁêÜ
            if len(self.buffer.items) > 0 and self.current_product_id == self.buffer.items[0].id:
                raise ValueError(f"Product {self.current_product_id} is currently being processed and cannot be taken")
            
            product = yield self.buffer.get()
            msg = f"Product {product.id} taken from {self.id} input buffer by AGV"
        
        print(f"[{self.env.now:.2f}] üì§ {self.id}: {msg}")
        self.publish_status(msg)
        return product
    
    def add_product_to_outputbuffer(self, product: Product):
        """Add a product to its output buffer (used by AGV for delivery)"""
        yield self.output_buffer.put(product)
        print(f"[{self.env.now:.2f}] üì¶ {self.id}: ËøêÂá∫‰∫ßÂìÅ {product.id} Âà∞output buffer")
        return True


================================================
File: src/simulation/entities/station.py
================================================
# simulation/entities/station.py
import simpy
import random
from typing import Dict, Tuple, Optional, Callable

from config.schemas import DeviceStatus, StationStatus
from src.simulation.entities.base import Device
from src.simulation.entities.product import Product
from src.utils.topic_manager import TopicManager
from config.topics import get_station_status_topic

class Station(Device):
    """
    Represents a manufacturing station in the factory.

    Stations have a buffer to hold products and take time to process them.
    Default input buffer capacity is 1 (single-piece flow).
    
    Attributes:
        buffer (simpy.Store): A buffer to hold incoming products.
        buffer_size (int): The maximum capacity of the bufferÔºàdefault 1Ôºâ„ÄÇ
        processing_times (Dict[str, Tuple[int, int]]): A dictionary mapping product types
            to a tuple of (min_time, max_time) for processing.
        product_transfer_callback (Callable): Callback function to transfer products to next station
        downstream_conveyor (Conveyor): The conveyor downstream from this station

        # For fault system to record the current product for resume processing
        current_product_id (str): The ID of the current product being processed.
        current_product_start_time (float): The time when the current product started processing.
        current_product_total_time (float): The total time required to process the current product.
        current_product_elapsed_time (float): The elapsed time before the current product was interrupted.
    """
    
    def __init__(
        self,
        env: simpy.Environment,
        id: str,
        position: Tuple[int, int],
        buffer_size: int = 1,
        processing_times: Dict[str, Tuple[int, int]] = {},
        downstream_conveyor=None,
        mqtt_client=None,
        interacting_points: list = [],
        kpi_calculator=None,  # Injected dependency
        topic_manager: Optional[TopicManager] = None,
        line_id: Optional[str] = None
    ):
        super().__init__(env, id, position, device_type="station", mqtt_client=mqtt_client, interacting_points=interacting_points)
        self.topic_manager = topic_manager
        self.line_id = line_id
        self.buffer_size = buffer_size
        self.buffer = simpy.Store(env, capacity=buffer_size)
        self.processing_times = processing_times
        
        # # Â∑•Á´ôÁâπÂÆöÂ±ûÊÄßÂàùÂßãÂåñ
        # self._specific_attributes.update({
        #     "precision_level": random.uniform(95.0, 100.0),  # Âä†Â∑•Á≤æÂ∫¶Ê∞¥Âπ≥
        #     "tool_wear_level": random.uniform(0.0, 20.0),    # ÂàÄÂÖ∑Á£®ÊçüÁ®ãÂ∫¶
        #     "lubricant_level": random.uniform(80.0, 100.0)   # Ê∂¶ÊªëÊ≤πÊ∞¥Âπ≥
        # })
        
        # ÁªüËÆ°Êï∞ÊçÆ
        self.stats = {
            "products_processed": 0,
            "total_processing_time": 0.0,
            "average_processing_time": 0.0,
            "working_time": 0.0,  # Total time spent in PROCESSING status
            "start_time": env.now  # Track when station started
        }
        
        self.downstream_conveyor = downstream_conveyor
        self.kpi_calculator = kpi_calculator
        self.last_status_change_time = env.now
        # ‰∫ßÂìÅÂ§ÑÁêÜÊó∂Èó¥Ë∑üË∏™ÔºàÁ´ôÁÇπ‰∏ÄÊ¨°Âè™Â§ÑÁêÜ‰∏Ä‰∏™‰∫ßÂìÅÔºâ
        self.current_product_id = None  # ÂΩìÂâçÊ≠£Âú®Â§ÑÁêÜÁöÑ‰∫ßÂìÅID
        self.current_product_start_time = None  # ÂΩìÂâç‰∫ßÂìÅÂºÄÂßãÂ§ÑÁêÜÁöÑÊó∂Èó¥
        self.current_product_total_time = None  # ÂΩìÂâç‰∫ßÂìÅÈúÄË¶ÅÁöÑÊÄªÂ§ÑÁêÜÊó∂Èó¥
        self.current_product_elapsed_time = None  # ‰∏≠Êñ≠ÂâçÂ∑≤ÁªèÂ§ÑÁêÜÁöÑÁ¥ØËÆ°Êó∂Èó¥
        
        # Start the main operational process for the station
        self.env.process(self.run())
        
        # Publish initial status
        self.publish_status("Station initialized")

    def set_status(self, new_status: DeviceStatus, message: Optional[str] = None):
        """Overrides the base method to publish status on change."""
        if self.status == new_status:
            return
        
        # Track working time for KPI
        if self.status == DeviceStatus.PROCESSING:
            processing_duration = self.env.now - self.last_status_change_time
            self.stats["working_time"] += processing_duration
            
            # Update KPI calculator with device utilization
            if self.kpi_calculator:
                self.kpi_calculator.add_energy_cost(self.id, self.line_id, processing_duration)
                self.kpi_calculator.update_device_utilization(self.id, self.line_id, self.env.now - self.stats["start_time"])
        
        self.last_status_change_time = self.env.now
        super().set_status(new_status, message)

    def publish_status(self, message: Optional[str] = None):
        """Publishes the current status of the station to MQTT."""
        if not self.mqtt_client or not self.mqtt_client.is_connected():
            return
            
        status_data = StationStatus(
            timestamp=self.env.now,
            source_id=self.id,
            status=self.status,
            message=message,
            buffer=[p.id for p in self.buffer.items],
            stats=self.stats,
            output_buffer=[]  # ÊôÆÈÄöÂ∑•Á´ôÊ≤°Êúâ output_buffer
        )
        if self.topic_manager and self.line_id:
            topic = self.topic_manager.get_station_status_topic(self.line_id, self.id)
        else:
            topic = get_station_status_topic(self.id)
        self.mqtt_client.publish(topic, status_data.model_dump_json(), retain=False)

    def run(self):
        """The main operational loop for the station."""
        while True:
            try:
                # Á≠âÂæÖËÆæÂ§áÂèØÊìç‰Ωú‰∏îbufferÊúâ‰∫ßÂìÅ
                yield self.env.process(self._wait_for_ready_state())
                
                # Â¶ÇÊûúËÉΩÂà∞ËøôÈáåÔºåËØ¥ÊòéËÆæÂ§áÂèØÊìç‰Ωú‰∏îÊúâ‰∫ßÂìÅ
                if len(self.buffer.items) > 0:
                    product = self.buffer.items[0]
                    self.action = self.env.process(self.process_product(product))
                    yield self.action
                    
            except simpy.Interrupt:
                # Ë¢´‰∏≠Êñ≠ÔºàÈÄöÂ∏∏ÊòØÊïÖÈöúÔºâÔºåÁªßÁª≠Âæ™ÁéØ
                continue
    
    def _wait_for_ready_state(self):
        """Á≠âÂæÖËÆæÂ§áÂ§Ñ‰∫éÂèØÊìç‰ΩúÁä∂ÊÄÅ‰∏îbufferÊúâ‰∫ßÂìÅ"""
        while True:
            # Â¶ÇÊûúbuffer‰∏∫Á©∫ÔºåÁ≠âÂæÖ
            if len(self.buffer.items) == 0:
                yield self.env.timeout(0.1)
                continue

            # Â¶ÇÊûúËÆæÂ§á‰∏çÂèØÊìç‰ΩúÔºåÁ≠âÂæÖ
            if not self.can_operate():
                yield self.env.timeout(1)
                continue

            # ËÆæÂ§áÂèØÊìç‰Ωú‰∏îÊúâ‰∫ßÂìÅÔºåËøîÂõû
            return

    def process_product(self, product: Product):
        """
        Simulates the entire lifecycle of processing a single product,
        from waiting for it to processing and transferring it.
        Includes robust error handling for interruptions.
        """
        print(f"[{self.env.now:.2f}] [DEBUG] Station {self.id}: process_product started for {product.id}, buffer={len(self.buffer.items)}/{self.buffer.capacity}")
        try:
            # Check if the device can operate
            if not self.can_operate():
                msg = f"[{self.env.now:.2f}] ‚ö†Ô∏è  {self.id}: can not process product, device is not available"
                print(msg)
                self.publish_status(msg)
                return

            self.set_status(DeviceStatus.PROCESSING)
            self.publish_status()

            # Record processing start and get processing time
            min_time, max_time = self.processing_times.get(product.product_type, (10, 20))
            processing_time = random.uniform(min_time, max_time)
            
            # Â§ÑÁêÜ‰∏≠Êñ≠ÊÅ¢Â§çÁöÑÈÄªËæë
            if (self.current_product_id == product.id and 
                self.current_product_elapsed_time is not None and
                self.current_product_total_time is not None):
                # ÊÅ¢Â§çÂ§ÑÁêÜÔºö‰ΩøÁî®‰πãÂâçËÆ∞ÂΩïÁöÑÂ∑≤Â§ÑÁêÜÊó∂Èó¥
                elapsed_time = self.current_product_elapsed_time
                remaining_time = max(0, self.current_product_total_time - elapsed_time)
                msg = f"[{self.env.now:.2f}] {self.id}: {product.id} resume processing, elapsed {elapsed_time:.1f}s, remaining {remaining_time:.1f}s"
                print(msg)
                self.publish_status(msg)
                # ÈáçÊñ∞ËÆ∞ÂΩïÂºÄÂßãÊó∂Èó¥Ôºå‰ΩÜ‰øùÁïôÁ¥ØËÆ°Êó∂Èó¥ÂíåÊÄªÊó∂Èó¥
                self.current_product_start_time = self.env.now
            else:
                # Á¨¨‰∏ÄÊ¨°ÂºÄÂßãÂ§ÑÁêÜ
                self.current_product_id = product.id
                self.current_product_start_time = self.env.now
                self.current_product_total_time = processing_time
                self.current_product_elapsed_time = 0  # ÂàùÂßãÂåñÁ¥ØËÆ°Êó∂Èó¥
                remaining_time = processing_time
                msg = f"[{self.env.now:.2f}] {self.id}: {product.id} start processing, need {processing_time:.1f}s"
                print(msg)
                self.publish_status(msg)
                
                # Mark production start for KPI tracking (only for StationA)
                if self.id == "StationA" and self.kpi_calculator:
                    self.kpi_calculator.mark_production_start(product)
            
            # The actual processing work
            yield self.env.timeout(remaining_time)
            product = yield self.buffer.get()
            product.process_at_station(self.id, self.env.now)

            # Update statistics upon successful completion
            self.stats["products_processed"] += 1
            self.stats["total_processing_time"] += processing_time
            self.stats["average_processing_time"] = (
                self.stats["total_processing_time"] / self.stats["products_processed"]
            )
            
            # Processing finished successfully
            msg = f"[{self.env.now:.2f}] {self.id}: {product.id} finished processing, actual processing time {processing_time:.1f}s"
            print(msg)
            self.publish_status(msg)
            
            # Trigger moving the product to the next stage
            yield self.env.process(self._transfer_product_to_next_stage(product))

        except simpy.Interrupt as e:
            message = f"Processing of product {product.id} was interrupted: {e.cause}"
            print(f"[{self.env.now:.2f}] ‚ö†Ô∏è {self.id}: {message}")
            
            # ËÆ∞ÂΩï‰∏≠Êñ≠Êó∂Â∑≤ÁªèÂ§ÑÁêÜÁöÑÊó∂Èó¥
            if self.current_product_start_time is not None:
                elapsed_before_interrupt = self.env.now - self.current_product_start_time
                self.current_product_elapsed_time = (self.current_product_elapsed_time or 0) + elapsed_before_interrupt
                print(f"[{self.env.now:.2f}] üíæ {self.id}: ‰∫ßÂìÅ {product.id} ‰∏≠Êñ≠ÂâçÂ∑≤Â§ÑÁêÜ {elapsed_before_interrupt:.1f}sÔºåÁ¥ØËÆ° {self.current_product_elapsed_time:.1f}s")
                # Ê∏ÖÁêÜÂºÄÂßãÊó∂Èó¥Ôºå‰ΩÜ‰øùÁïôÂÖ∂‰ªñËÆ∞ÂΩï
                self.current_product_start_time = None
            
            if product not in self.buffer.items:
                # ‰∫ßÂìÅÂ∑≤ÂèñÂá∫ÔºåËØ¥ÊòéÂ§ÑÁêÜÊó∂Èó¥Â∑≤ÁªèÂÆåÊàêÔºåÂ∫îËØ•ÁªßÁª≠ÊµÅËΩ¨Ôºå‰ΩÜÈúÄË¶ÅÁ≠âÂæÖËÆæÂ§áÂèØÊìç‰ΩúÈò≤Ê≠¢Ë¶ÜÁõñFaultÁä∂ÊÄÅ
                print(f"[{self.env.now:.2f}] üöö {self.id}: ‰∫ßÂìÅ {product.id} Â∑≤Â§ÑÁêÜÂÆåÊàêÔºåÁªßÁª≠ÊµÅËΩ¨Âà∞‰∏ãÊ∏∏")
                while not self.can_operate():
                    yield self.env.timeout(1)
                yield self.env.process(self._transfer_product_to_next_stage(product))
                # Ê∏ÖÁêÜÊâÄÊúâÊó∂Èó¥ËÆ∞ÂΩï
                self.current_product_id = None
                self.current_product_start_time = None
                self.current_product_total_time = None
                self.current_product_elapsed_time = None
            else:
                # ‰∫ßÂìÅËøòÂú®buffer‰∏≠ÔºåËØ¥ÊòéÂú®timeoutÊúüÈó¥Ë¢´‰∏≠Êñ≠ÔºåÁ≠âÂæÖ‰∏ãÊ¨°Â§ÑÁêÜ
                print(f"[{self.env.now:.2f}] ‚è∏Ô∏è  {self.id}: ‰∫ßÂìÅ {product.id} Â§ÑÁêÜË¢´‰∏≠Êñ≠ÔºåÁïôÂú®buffer‰∏≠")
        finally:
            # Clear the action handle once the process is complete or interrupted
            self.action = None
            # Â¶ÇÊûú‰∫ßÂìÅÊàêÂäüÂÆåÊàêÂ§ÑÁêÜÂπ∂ËΩ¨ÁßªÔºåÊ∏ÖÁêÜÊó∂Èó¥ËÆ∞ÂΩï
            if self.current_product_id == product.id and product not in self.buffer.items:
                self.current_product_id = None
                self.current_product_start_time = None
                self.current_product_total_time = None
                self.current_product_elapsed_time = None
        print(f"[{self.env.now:.2f}] [DEBUG] Station {self.id}: process_product finished for {product.id}, buffer={len(self.buffer.items)}/{self.buffer.capacity}")

    def _transfer_product_to_next_stage(self, product):
        """Transfer the processed product to the next station or conveyor."""

        if self.downstream_conveyor is None:
            # No downstream, end of process
            return
        
        if self.downstream_conveyor.is_full() or not self.downstream_conveyor.can_operate():
            self.set_status(DeviceStatus.BLOCKED)
            self.publish_status("downstream conveyor is full or run into some issue, station is blocked")

        # TODO: while len(self.downstream_conveyor.buffer.items) >0 //ÂèñÂÜ≥‰∫é‰∏ãÊ∏∏Â†µÂ°û‰ΩÜÊòØÊ≤°‰∏úË•øÊó∂Ë¶Å‰∏çË¶ÅÊîæ1‰∏™Ôºà‰πãÂâçÊúâÁ©∫‰ΩçÂ∞±‰ºöÊîæÔºâ
        while not self.downstream_conveyor.can_operate() or self.downstream_conveyor.is_full():
            yield self.env.timeout(0.1)

        yield self.downstream_conveyor.push(product)
        
        # Set status back to IDLE after the push operation is complete
        self.set_status(DeviceStatus.IDLE)
        self.publish_status()
        return

    def pop(self):
        """Remove and return the first product from the station's buffer.
        Ensures that the product being processed cannot be taken.
        """
        # Ê£ÄÊü•Á¨¨‰∏Ä‰∏™‰∫ßÂìÅÊòØÂê¶Ê≠£Âú®Ë¢´Â§ÑÁêÜ
        if len(self.buffer.items) > 0 and self.current_product_id == self.buffer.items[0].id:
            raise ValueError(f"Product {self.current_product_id} is currently being processed and cannot be taken")
        
        # ÂèñÂá∫Á¨¨‰∏Ä‰∏™‰∫ßÂìÅ
        product = yield self.buffer.get()
        print(f"[{self.env.now:.2f}] [DEBUG] Station {self.id}: pop {product.id}, buffer={len(self.buffer.items)}/{self.buffer.capacity}")
        
        # ÂèëÂ∏ÉÁä∂ÊÄÅÊõ¥Êñ∞
        msg = f"Product {product.id} taken from {self.id} by AGV"
        print(f"[{self.env.now:.2f}] üì§ {self.id}: {msg}")
        self.publish_status(msg)
        return product

    def add_product_to_buffer(self, product: Product):
        """Add a product to the station's buffer"""
        success = False

        try:
            yield self.buffer.put(product)
            msg = f"[{self.env.now:.2f}] üì• {self.id}: Product {product.id} added to buffer."
            success = True
        except simpy.Interrupt:
            msg = f"[{self.env.now:.2f}] ‚ö†Ô∏è {self.id}: add_product_to_buffer interrupted."
            success = False

        print(msg)
        self.publish_status(msg)
        return success

    def get_buffer_level(self) -> int:
        """Ëé∑ÂèñÂΩìÂâçÁºìÂÜ≤Âå∫‰∫ßÂìÅÊï∞Èáè"""
        return len(self.buffer.items)

    def is_full(self):
        return len(self.buffer.items) >= self.buffer_size
    
    def is_empty(self):
        return len(self.buffer.items) == 0
    
    def get_processing_stats(self) -> Dict:
        """Ëé∑ÂèñÂ∑•Á´ôÂ§ÑÁêÜÁªüËÆ°‰ø°ÊÅØ"""
        return {
            **self.stats,
            "buffer_level": self.get_buffer_level(),
            "buffer_utilization": self.get_buffer_level() / self.buffer_size,
            "can_operate": self.can_operate()
        }

    def reset_stats(self):
        """ÈáçÁΩÆÁªüËÆ°Êï∞ÊçÆ"""
        self.stats = {
            "products_processed": 0,
            "total_processing_time": 0.0,
            "average_processing_time": 0.0
        }
    
    def recover(self):
        """Custom recovery logic for the station."""
        # Ê∏ÖÁêÜ‰∏çÂú®buffer‰∏≠ÁöÑ‰∫ßÂìÅÁöÑÊó∂Èó¥ËÆ∞ÂΩï
        if self.current_product_id:
            products_in_buffer = {p.id for p in self.buffer.items}
            if self.current_product_id not in products_in_buffer:
                print(f"[{self.env.now:.2f}] üóëÔ∏è Station {self.id}: Ê∏ÖÁêÜËøáÊúü‰∫ßÂìÅ {self.current_product_id} ÁöÑÊó∂Èó¥ËÆ∞ÂΩï")
                self.current_product_id = None
                self.current_product_start_time = None
                self.current_product_total_time = None
                self.current_product_elapsed_time = None
        
        # Âè™ÊúâÂΩìËÆæÂ§áÂ§Ñ‰∫éFAULTÁä∂ÊÄÅÊó∂ÊâçÊÅ¢Â§ç
        if self.status == DeviceStatus.FAULT:
            self.set_status(DeviceStatus.IDLE)
            msg = f"[{self.env.now:.2f}] ‚úÖ Station {self.id} is recovered."
            print(msg)
            self.publish_status(msg)
        else:
            # Â¶ÇÊûúËÆæÂ§á‰∏çÊòØFAULTÁä∂ÊÄÅÔºåÂè™ÊâìÂç∞ÊÅ¢Â§çÂ∞ùËØïÁöÑ‰ø°ÊÅØ
            msg = f"[{self.env.now:.2f}] ‚ÑπÔ∏è Station {self.id}: Recovery attempted, but status is {self.status.value}, not changing."
            print(msg)




================================================
File: src/simulation/entities/warehouse.py
================================================
# simulation/entities/warehouse.py
import simpy
import random
from typing import Dict, Tuple, Optional

from src.simulation.entities.base import Device
from src.simulation.entities.product import Product
from config.schemas import WarehouseStatus
from config.topics import get_warehouse_status_topic
from src.utils.topic_manager import TopicManager

class BaseWarehouse(Device):
    """Base class for all warehouse types, inheriting from Device."""

    def __init__(
        self,
        env: simpy.Environment,
        id: str,
        position: Tuple[int, int],
        mqtt_client=None,
        interacting_points: list = [],
        topic_manager: Optional[TopicManager] = None,
        line_id: Optional[str] = None,
        **kwargs # Absorb other config values
    ):
        super().__init__(env, id, position, device_type="warehouse", mqtt_client=mqtt_client)
        self.buffer = simpy.Store(env)
        self.interacting_points = interacting_points
        self.stats = {}  # To be overridden by subclasses
        self.topic_manager = topic_manager
        self.line_id = line_id

    def publish_status(self, message: str = "Warehouse is ready"):
        """Publishes the current status of the warehouse to MQTT."""
        if not self.mqtt_client or not self.mqtt_client.is_connected():
            return
        status_data = WarehouseStatus(
            timestamp=self.env.now,
            source_id=self.id,
            message=message,
            buffer=[p.id for p in self.buffer.items],
            stats=self.stats
        )
        if self.topic_manager:
            topic = self.topic_manager.get_warehouse_status_topic(self.id)
        else:
            topic = get_warehouse_status_topic(self.id)
        self.mqtt_client.publish(topic, status_data.model_dump_json(), retain=False)

    def get_buffer_level(self) -> int:
        """Return the current number of items in the buffer."""
        return len(self.buffer.items)
    
    def pop(self, product_id: Optional[str] = None):
        """
        Remove and return a product from the warehouse buffer.
        If product_id is specified, remove the product with that id.
        Otherwise, remove the first product in the buffer.
        """
        if product_id:
            # Try to find and remove the product with the specified id
            for idx, p in enumerate(self.buffer.items):
                if p.id == product_id:
                    product = self.buffer.items.pop(idx)
                    print(f"[{self.env.now:.2f}] üì§ {self.id}: Product {product.id} taken from warehouse buffer.")
                    break
            else:
                # If not found, raise an error
                raise ValueError(f"Product with id {product_id} not found in warehouse buffer.")
        else:
            product = yield self.buffer.get()
            print(f"[{self.env.now:.2f}] üì§ {self.id}: Default Product taken from warehouse buffer.")

        # ÂèëÂ∏ÉÁä∂ÊÄÅÊõ¥Êñ∞
        msg = f"Product {product.id} taken from {self.id} by AGV"
        print(f"[{self.env.now:.2f}] üì§ {self.id}: {msg}")
        self.publish_status(msg)
        return product

    def run(self):
        """Warehouses don't process products, just idle loop."""
        while True:
            yield self.env.timeout(60)  # Check every minute

class RawMaterial(BaseWarehouse):
    """Raw material warehouse - the starting point of the production line"""

    def __init__(
        self,
        env: simpy.Environment,
        mqtt_client=None,
        kpi_calculator=None,
        **config
    ):
        super().__init__(env=env, mqtt_client=mqtt_client, **config)
        self.device_type = "raw_material"  # Override device type
        self.kpi_calculator = kpi_calculator
        self.stats = {
            "total_materials_supplied": 0,
            "product_type_summary": {"P1": 0, "P2": 0, "P3": 0}
        }
        print(f"[{self.env.now:.2f}] üè≠ {self.id}: Raw material warehouse is ready")
        self.publish_status("Raw material warehouse is ready")

    def create_raw_material(self, product_type: str, order_id: str) -> Product:
        """Create raw material product"""
        product = Product(product_type, order_id)
        self.stats["total_materials_supplied"] += 1
        self.stats["product_type_summary"][product_type] += 1
        product.add_history(self.env.now, f"Raw material created at {self.id}")
        print(f"[{self.env.now:.2f}] üîß {self.id}: Create raw material {product.id} (type: {product_type})")
        self.buffer.put(product)
        self.publish_status(f"Supply raw material {product.id} (type: {product_type}) since order {order_id} is created")
        return product

    def pop(self, product_id: Optional[str] = None):
        """
        Override parent's pop method to add material cost calculation.
        Material cost is added when product is taken from raw material warehouse.
        """
        # First get the product using parent's pop method
        product = yield from super().pop(product_id)
        
        # Add material cost to KPI when product is taken
        if self.kpi_calculator and hasattr(product, 'product_type'):
            material_cost = self.kpi_calculator.cost_parameters['material_cost_per_product'].get(
                product.product_type, 10.0  # Default to P1 cost if not found
            )
            self.kpi_calculator.stats.material_costs += material_cost
            
            # Also update the order tracking if it exists
            if hasattr(product, 'order_id') and product.order_id in self.kpi_calculator.active_orders:
                order_tracking = self.kpi_calculator.active_orders[product.order_id]
                order_tracking.total_cost += material_cost
            
            print(f"[{self.env.now:.2f}] üí∞ {self.id}: Added material cost ${material_cost:.2f} for {product.product_type}")
            
            # Trigger KPI update
            self.kpi_calculator._check_and_publish_kpi_update()
        
        return product

    def is_full(self) -> bool:
        # return self.get_buffer_level() >= self.buffer_size
        return False

class Warehouse(BaseWarehouse):
    """Finished product warehouse - the ending point of the production line"""

    def __init__(
        self,
        env: simpy.Environment,
        mqtt_client=None,
        **config
    ):
        super().__init__(env=env, mqtt_client=mqtt_client, **config)
        self.stats = {
            "total_products_received": 0,
            "product_type_summary": {"P1": 0, "P2": 0, "P3": 0},
        }
        print(f"[{self.env.now:.2f}] üè™ {self.id}: Finished product warehouse is ready")
        self.publish_status("Warehouse is ready")

    def add_product_to_buffer(self, product: Product):
        """AGV put product to warehouse"""
        yield self.buffer.put(product)
        self.publish_status(f"Store finished product {product.id} (type: {product.product_type})")
        self.stats["total_products_received"] += 1
        self.stats["product_type_summary"][product.product_type] += 1
        product.add_history(self.env.now, f"Stored in warehouse {self.id}")
        print(f"[{self.env.now:.2f}] üì¶ {self.id}: Store finished product {product.id} (type: {product.product_type})")
        return True
    
    def is_full(self) -> bool:
        # return self.get_buffer_level() >= self.buffer_size
        return False



================================================
File: src/utils/config_loader.py
================================================
"""
Configuration loader for SUPCON Factory Simulation
Loads configuration from YAML files and provides typed access to configuration data.
"""

import yaml
from pathlib import Path
from typing import Dict, Any, Optional

class ConfigLoader:
    """simplified config loader - load yaml file to dict"""
    
    def __init__(self, config_dir: str = "config"):
        self.config_dir = Path(config_dir)
    
    def load_factory_layout(self, config_file_name: str = "factory_layout.yml") -> Dict[str, Any]:
        """load factory layout from yaml file"""
        config_file = self.config_dir / config_file_name
        
        if not config_file.exists():
            raise FileNotFoundError(f"Configuration file not found: {config_file}")
        
        with open(config_file, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        
        # # simple validation for required fields
        # required_sections = ['stations', 'agvs', 'conveyors', 'warehouses']
        # for section in required_sections:
        #     if section not in config:
        #         raise ValueError(f"Missing required section: {section}")
        
        return config

# global config loader instance
_config_loader: Optional[ConfigLoader] = None

def get_config_loader() -> ConfigLoader:
    """get global config loader instance"""
    global _config_loader
    if _config_loader is None:
        _config_loader = ConfigLoader()
    return _config_loader

def load_factory_config(config_file_name: str = "factory_layout.yml") -> Dict[str, Any]:
    """convenient function - load factory config"""
    return get_config_loader().load_factory_layout(config_file_name)


================================================
File: src/utils/mqtt_client.py
================================================
# utils/mqtt_client.py
import logging
import paho.mqtt.client as mqtt
from typing import Callable, Optional
from pydantic import BaseModel

# Configure logger
logger = logging.getLogger(__name__)

class MQTTClient:
    """
    A robust wrapper for the paho-mqtt client providing easy-to-use
    methods for connecting, publishing, and subscribing.
    """

    def __init__(self, host: str, port: int, client_id: str = ""):
        self._host = host
        self._port = port
        # NOTE: The client_id is passed as the first argument for compatibility.
        self._client = mqtt.Client(client_id=client_id)
            
        self._client.on_connect = self._on_connect
        self._client.on_disconnect = self._on_disconnect
        self._client.on_message = self._on_message
        self._message_callbacks = {}

    def _on_connect(self, client, userdata, flags, reason_code, properties=None):
        if reason_code == 0:
            logger.info(f"Successfully connected to MQTT Broker at {self._host}:{self._port}")
        else:
            logger.error(f"Failed to connect to MQTT Broker, reason code: {reason_code}")

    def _on_disconnect(self, client, userdata, reason_code, properties=None):
        logger.warning(f"Disconnected from MQTT Broker with reason code: {reason_code}. Reconnecting...")

    def _on_message(self, client, userdata, msg):
        """
        Internal callback to route messages to the appropriate topic-specific callback.
        """
        logger.debug(f"Received message on topic {msg.topic}")
        # Iterate over subscribed topics and check for a match
        for topic_filter, callback in self._message_callbacks.items():
            if mqtt.topic_matches_sub(topic_filter, msg.topic):
                callback(msg.topic, msg.payload)
                break
        else:
            logger.warning(f"No callback registered for message on topic {msg.topic}")

    def connect(self):
        """
        Connects to the MQTT broker and starts the network loop in a separate thread.
        """
        try:
            logger.info(f"Connecting to MQTT Broker at {self._host}:{self._port}...")
            self._client.connect(self._host, self._port, 60)
            self._client.loop_start()
        except Exception as e:
            logger.error(f"Error connecting to MQTT Broker: {e}")
            raise

    def disconnect(self):
        """
        Stops the network loop and disconnects from the MQTT broker.
        """
        logger.info("Disconnecting from MQTT Broker.")
        self._client.loop_stop()
        self._client.disconnect()

    def subscribe(self, topic: str, callback: Callable[[str, bytes], None], qos: int = 0):
        """
        Subscribes to a topic and registers a callback for incoming messages.

        Args:
            topic (str): The topic to subscribe to (can include wildcards).
            callback (Callable): A function to call when a message is received.
                                 The callback should accept (topic, payload).
            qos (int): The Quality of Service level for the subscription.
        """
        if not callable(callback):
            raise TypeError("Callback must be a callable function")
            
        logger.info(f"Subscribing to topic: {topic}")
        self._message_callbacks[topic] = callback
        self._client.subscribe(topic, qos)

    def publish(self, topic: str, payload: str | BaseModel, qos: int = 1, retain: bool = False):
        """
        Publishes a message to a topic.

        Args:
            topic (str): The topic to publish to.
            payload (str | BaseModel): The message payload. If it's a Pydantic BaseModel,
                                       it will be automatically converted to a JSON string.
            qos (int): The Quality of Service level for the message.
            retain (bool): Whether the message should be retained by the broker.
        """
        if isinstance(payload, BaseModel):
            message = payload.model_dump_json()
        elif isinstance(payload, str):
            message = payload
        else:
            message = str(payload)
            # raise TypeError("Payload must be a string or a Pydantic BaseModel")

        logger.debug(f"Publishing to topic '{topic}': {message}")
        result = self._client.publish(topic, message, qos, retain)
        if result.rc != mqtt.MQTT_ERR_SUCCESS:
            logger.error(f"Failed to publish to topic {topic}: {mqtt.error_string(result.rc)}") 

    def is_connected(self):
        return self._client.is_connected()


================================================
File: src/utils/safe_output.py
================================================
"""
Safe output utilities to handle BrokenPipeError when using pipes
"""
import sys

def safe_print(*args, **kwargs):
    """
    Safe print function that handles BrokenPipeError when output is piped
    """
    try:
        print(*args, **kwargs)
    except BrokenPipeError:
        # When piped to head/tail, ignore broken pipe errors
        sys.stderr.close()
    except KeyboardInterrupt:
        sys.exit(1) 


================================================
File: src/utils/topic_manager.py
================================================
# src/utils/topic_manager.py
import os
from typing import Dict, Optional

class TopicManager:
    """
    Manages the generation of all MQTT topics for the simulation.
    It ensures a consistent topic structure based on a root name.
    """
    def __init__(self, player_name: str):
        """
        Initializes the TopicManager with a root topic name.
        Args:
            player_name: The root name for all topics, typically the player's or team's name.
        """
        if not player_name or not isinstance(player_name, str) or "/" in player_name:
            raise ValueError("Player name cannot be empty or contain '/'")
        self.root = player_name
        print(f"‚úÖ TopicManager initialized with root topic: '{self.root}'")

    def get_station_status_topic(self, line_id: str, device_id: str) -> str:
        """Generates topic for device status updates."""
        # device_id from Line class is already line_x_device_y, so we can just use it
        return f"{self.root}/{line_id}/station/{device_id}/status"

    def get_conveyor_status_topic(self, line_id: str, device_id: str) -> str:
        """Generates topic for device status updates."""
        # device_id from Line class is already line_x_device_y, so we can just use it
        return f"{self.root}/{line_id}/conveyor/{device_id}/status"

    def get_warehouse_status_topic(self, device_id: str) -> str:
        """Generates topic for device status updates."""
        # device_id from Line class is already line_x_device_y, so we can just use it
        return f"{self.root}/warehouse/{device_id}/status"

    def get_agv_status_topic(self, line_id: str, agv_id: str) -> str:
        """Generates topic for AGV status updates."""
        return f"{self.root}/{line_id}/agv/{agv_id}/status"

    def get_order_topic(self) -> str:
        """Generates topic for new order announcements."""
        return f"{self.root}/orders/status"

    def get_fault_alert_topic(self, line_id: str) -> str:
        """Generates topic for fault alerts."""
        return f"{self.root}/{line_id}/alerts"
        
    def get_kpi_topic(self) -> str:
        """Generates topic for factory-wide KPI updates."""
        return f"{self.root}/kpi/status"
    
    def get_result_topic(self) -> str:
        """Generates topic for factory-wide result updates."""
        return f"{self.root}/result/status"

    def get_agent_command_topic_wildcard(self) -> str:
        """Generates a wildcard topic for agent commands for all lines."""
        return f"{self.root}/command/+"

    def get_agent_command_topic(self, line_id: str) -> str:
        """Generates the specific command topic for a given line."""
        return f"{self.root}/command/{line_id}"

    def parse_agent_command_topic(self, topic: str) -> Optional[Dict[str, str]]:
        """
        Parses an agent command topic to extract line_id.
        Expected format: {root}/command/{line_id}
        """
        parts = topic.split('/')
        if len(parts) == 3 and parts[0] == self.root and parts[1] == "command":
            return {
                "line_id": parts[2]
            }
        return None

    def get_agent_response_topic(self, line_id: Optional[str]) -> str:
        """Generates the response topic for agent commands."""
        if line_id:
            return f"{self.root}/response/{line_id}"
        else:
            return f"{self.root}/response/general"





================================================
File: unity/index.html
================================================
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity WebGL Player | SimPyUnity</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
  </head>
  <body>
    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas" width=1980 height=1080 tabindex="-1"></canvas>
      <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
          <div id="unity-progress-bar-full"></div>
        </div>
      </div>
      <div id="unity-warning"> </div>
      <div id="unity-footer">
        <div id="unity-webgl-logo"></div>
        <div id="unity-fullscreen-button"></div>
        <div id="unity-build-title">SimPyUnity</div>
      </div>
    </div>
    <script>

      var container = document.querySelector("#unity-container");
      var canvas = document.querySelector("#unity-canvas");
      var loadingBar = document.querySelector("#unity-loading-bar");
      var progressBarFull = document.querySelector("#unity-progress-bar-full");
      var fullscreenButton = document.querySelector("#unity-fullscreen-button");
      var warningBanner = document.querySelector("#unity-warning");

      // Shows a temporary message banner/ribbon for a few seconds, or
      // a permanent error message on top of the canvas if type=='error'.
      // If type=='warning', a yellow highlight color is used.
      // Modify or remove this function to customize the visually presented
      // way that non-critical warnings and error messages are presented to the
      // user.
      function unityShowBanner(msg, type) {
        function updateBannerVisibility() {
          warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
        }
        var div = document.createElement('div');
        div.innerHTML = msg;
        warningBanner.appendChild(div);
        if (type == 'error') div.style = 'background: red; padding: 10px;';
        else {
          if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
          setTimeout(function() {
            warningBanner.removeChild(div);
            updateBannerVisibility();
          }, 5000);
        }
        updateBannerVisibility();
      }

      var buildUrl = "Build";
      var loaderUrl = buildUrl + "/SimPy.loader.js";
      var config = {
        dataUrl: buildUrl + "/SimPy.data.unityweb",
        frameworkUrl: buildUrl + "/SimPy.framework.js.unityweb",
        codeUrl: buildUrl + "/SimPy.wasm.unityweb",
        streamingAssetsUrl: "StreamingAssets",
        companyName: "DefaultCompany",
        productName: "SimPyUnity",
        productVersion: "0.1.0",
        showBanner: unityShowBanner,
      };

      // By default, Unity keeps WebGL canvas render target size matched with
      // the DOM size of the canvas element (scaled by window.devicePixelRatio)
      // Set this to false if you want to decouple this synchronization from
      // happening inside the engine, and you would instead like to size up
      // the canvas DOM size and WebGL render target sizes yourself.
      // config.matchWebGLToCanvasSize = false;

      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        // Mobile device style: fill the whole browser client area with the game canvas:

        var meta = document.createElement('meta');
        meta.name = 'viewport';
        meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        document.getElementsByTagName('head')[0].appendChild(meta);
        container.className = "unity-mobile";
        canvas.className = "unity-mobile";

        // To lower canvas resolution on mobile devices to gain some
        // performance, uncomment the following line:
        // config.devicePixelRatio = 1;


      } else {
        // Desktop style: Render the game canvas in a window that can be maximized to fullscreen:

        canvas.style.width = "1440px";
        canvas.style.height = "900px";
      }

      loadingBar.style.display = "block";

      var script = document.createElement("script");
      script.src = loaderUrl;
      script.onload = () => {
        createUnityInstance(canvas, config, (progress) => {
          progressBarFull.style.width = 100 * progress + "%";
              }).then((unityInstance) => {
                loadingBar.style.display = "none";
                fullscreenButton.onclick = () => {
                  unityInstance.SetFullscreen(1);
                };
              }).catch((message) => {
                alert(message);
              });
            };

      document.body.appendChild(script);

    </script>
  </body>
</html>



================================================
File: unity/Build/SimPy.data.unityweb
================================================
[Non-text file]


================================================
File: unity/Build/SimPy.framework.js.unityweb
================================================
[Non-text file]


================================================
File: unity/Build/SimPy.loader.js
================================================
function createUnityInstance(t,n,d){function c(e,t){if(!c.aborted&&n.showBanner)return"error"==t&&(c.aborted=!0),n.showBanner(e,t);switch(t){case"error":console.error(e);break;case"warning":console.warn(e);break;default:console.log(e)}}function r(e){var t=e.reason||e.error,n=t?t.toString():e.message||e.reason||"",r=t&&t.stack?t.stack.toString():"";(n+="\n"+(r=r.startsWith(n)?r.substring(n.length):r).trim())&&f.stackTraceRegExp&&f.stackTraceRegExp.test(n)&&E(n,e.filename||t&&(t.fileName||t.sourceURL)||"",e.lineno||t&&(t.lineNumber||t.line)||0)}function e(e,t,n){var r=e[t];void 0!==r&&r||(console.warn('Config option "'+t+'" is missing or empty. Falling back to default value: "'+n+'". Consider updating your WebGL template to include the missing config option.'),e[t]=n)}d=d||function(){};var o,f={canvas:t,webglContextAttributes:{preserveDrawingBuffer:!1,powerPreference:2},cacheControl:function(e){return e==f.dataUrl||e.match(/\.bundle/)?"must-revalidate":"no-store"},streamingAssetsUrl:"StreamingAssets",downloadProgress:{},deinitializers:[],intervals:{},setInterval:function(e,t){e=window.setInterval(e,t);return this.intervals[e]=!0,e},clearInterval:function(e){delete this.intervals[e],window.clearInterval(e)},preRun:[],postRun:[],print:function(e){console.log(e)},printErr:function(e){console.error(e),"string"==typeof e&&-1!=e.indexOf("wasm streaming compile failed")&&(-1!=e.toLowerCase().indexOf("mime")?c('HTTP Response Header "Content-Type" configured incorrectly on the server for file '+f.codeUrl+' , should be "application/wasm". Startup time performance will suffer.',"warning"):c('WebAssembly streaming compilation failed! This can happen for example if "Content-Encoding" HTTP header is incorrectly enabled on the server for file '+f.codeUrl+", but the file is not pre-compressed on disk (or vice versa). Check the Network tab in browser Devtools to debug server header configuration.","warning"))},locateFile:function(e){return e},disabledCanvasEvents:["contextmenu","dragstart"]};for(o in e(n,"companyName","Unity"),e(n,"productName","WebGL Player"),e(n,"productVersion","1.0"),n)f[o]=n[o];f.streamingAssetsUrl=new URL(f.streamingAssetsUrl,document.URL).href;var i=f.disabledCanvasEvents.slice();function a(e){e.preventDefault()}i.forEach(function(e){t.addEventListener(e,a)}),window.addEventListener("error",r),window.addEventListener("unhandledrejection",r);var s="",u="";function l(e){document.webkitCurrentFullScreenElement===t?t.style.width&&(s=t.style.width,u=t.style.height,t.style.width="100%",t.style.height="100%"):s&&(t.style.width=s,t.style.height=u,u=s="")}document.addEventListener("webkitfullscreenchange",l),f.deinitializers.push(function(){for(var e in f.disableAccessToMediaDevices(),i.forEach(function(e){t.removeEventListener(e,a)}),window.removeEventListener("error",r),window.removeEventListener("unhandledrejection",r),document.removeEventListener("webkitfullscreenchange",l),f.intervals)window.clearInterval(e);f.intervals={}}),f.QuitCleanup=function(){for(var e=0;e<f.deinitializers.length;e++)f.deinitializers[e]();f.deinitializers=[],"function"==typeof f.onQuit&&f.onQuit()};var h,p,w,m,b,v,y,g,x,U={Module:f,SetFullscreen:function(){if(f.SetFullscreen)return f.SetFullscreen.apply(f,arguments);f.print("Failed to set Fullscreen mode: Player not loaded yet.")},SendMessage:function(){if(f.SendMessage)return f.SendMessage.apply(f,arguments);f.print("Failed to execute SendMessage: Player not loaded yet.")},Quit:function(){return new Promise(function(e,t){f.shouldQuit=!0,f.onQuit=e})},GetMemoryInfo:function(){var e=f._getMemInfo();return{totalWASMHeapSize:f.HEAPU32[e>>2],usedWASMHeapSize:f.HEAPU32[1+(e>>2)],totalJSHeapSize:f.HEAPF64[1+(e>>3)],usedJSHeapSize:f.HEAPF64[2+(e>>3)]}}};function E(e,t,n){-1==e.indexOf("fullscreen error")&&(f.startupErrorHandler?f.startupErrorHandler(e,t,n):f.errorHandler&&f.errorHandler(e,t,n)||(console.log("Invoking error handler due to\n"+e),"function"==typeof dump&&dump("Invoking error handler due to\n"+e),E.didShowErrorMessage||(-1!=(e="An error occurred running the Unity content on this page. See your browser JavaScript console for more info. The error was:\n"+e).indexOf("DISABLE_EXCEPTION_CATCHING")?e="An exception has occurred, but exception handling has been disabled in this build. If you are the developer of this content, enable exceptions in your project WebGL player settings to be able to catch the exception or see the stack trace.":-1!=e.indexOf("Cannot enlarge memory arrays")?e="Out of memory. If you are the developer of this content, try allocating more memory to your WebGL build in the WebGL player settings.":-1==e.indexOf("Invalid array buffer length")&&-1==e.indexOf("Invalid typed array length")&&-1==e.indexOf("out of memory")&&-1==e.indexOf("could not allocate memory")||(e="The browser could not allocate enough memory for the WebGL content. If you are the developer of this content, try allocating less memory to your WebGL build in the WebGL player settings."),alert(e),E.didShowErrorMessage=!0)))}function W(e,t){if("symbolsUrl"!=e){var n=f.downloadProgress[e],r=(n=n||(f.downloadProgress[e]={started:!1,finished:!1,lengthComputable:!1,total:0,loaded:0}),"object"!=typeof t||"progress"!=t.type&&"load"!=t.type||(n.started||(n.started=!0,n.lengthComputable=t.lengthComputable),n.total=t.total,n.loaded=t.loaded,"load"==t.type&&(n.finished=!0)),0),o=0,i=0,a=0,s=0;for(e in f.downloadProgress){if(!(n=f.downloadProgress[e]).started)return;i++,n.lengthComputable?(r+=n.loaded,o+=n.total,a++):n.finished||s++}d(.9*(i?(i-s-(o?a*(o-r)/o:0))/i:0))}}function O(){var e=this;this.isConnected=this.connect().then(function(){return e.cleanUpCache()}),this.isConnected.catch(function(e){e="Error when initializing cache: "+e,console.log("[UnityCache] "+e)})}function k(e){console.log("[UnityCache] "+e)}function B(e){return B.link=B.link||document.createElement("a"),B.link.href=e,B.link.href}f.SystemInfo=function(){var e,t,n,r,o=navigator.userAgent+" ",i=[["Firefox","Firefox"],["OPR","Opera"],["Edg","Edge"],["SamsungBrowser","Samsung Browser"],["Trident","Internet Explorer"],["MSIE","Internet Explorer"],["Chrome","Chrome"],["CriOS","Chrome on iOS Safari"],["FxiOS","Firefox on iOS Safari"],["Safari","Safari"]];function a(e,t,n){return(e=RegExp(e,"i").exec(t))&&e[n]}for(var s=0;s<i.length;++s)if(t=a(i[s][0]+"[/ ](.*?)[ \\)]",o,1)){e=i[s][1];break}"Safari"==e&&(t=a("Version/(.*?) ",o,1)),"Internet Explorer"==e&&(t=a("rv:(.*?)\\)? ",o,1)||t);for(var d=[["Windows (.*?)[;)]","Windows"],["Android ([0-9_.]+)","Android"],["iPhone OS ([0-9_.]+)","iPhoneOS"],["iPad.*? OS ([0-9_.]+)","iPadOS"],["FreeBSD( )","FreeBSD"],["OpenBSD( )","OpenBSD"],["Linux|X11()","Linux"],["Mac OS X ([0-9_\\.]+)","MacOS"],["bot|google|baidu|bing|msn|teoma|slurp|yandex","Search Bot"]],c=0;c<d.length;++c)if(f=a(d[c][0],o,1)){n=d[c][1],f=f.replace(/_/g,".");break}var u,f={"NT 5.0":"2000","NT 5.1":"XP","NT 5.2":"Server 2003","NT 6.0":"Vista","NT 6.1":"7","NT 6.2":"8","NT 6.3":"8.1","NT 10.0":"10"}[f]||f,l=((l=document.createElement("canvas"))&&(u=(h=l.getContext("webgl2"))?2:0,h||(h=l&&l.getContext("webgl"))&&(u=1),h&&(r=h.getExtension("WEBGL_debug_renderer_info")&&h.getParameter(37446)||h.getParameter(7937))),"undefined"!=typeof SharedArrayBuffer),h="object"==typeof WebAssembly&&"function"==typeof WebAssembly.compile;return{width:screen.width,height:screen.height,userAgent:o.trim(),browser:e||"Unknown browser",browserVersion:t||"Unknown version",mobile:/Mobile|Android|iP(ad|hone)/.test(navigator.appVersion),os:n||"Unknown OS",osVersion:f||"Unknown OS Version",gpu:r||"Unknown GPU",language:navigator.userLanguage||navigator.language,hasWebGL:u,hasCursorLock:!!document.body.requestPointerLock,hasFullscreen:!!document.body.requestFullscreen||!!document.body.webkitRequestFullscreen,hasThreads:l,hasWasm:h,hasWasmThreads:!1}}(),f.abortHandler=function(e){return E(e,"",0),!0},Error.stackTraceLimit=Math.max(Error.stackTraceLimit||0,50),f.readBodyWithProgress=function(i,a,s){var e=i.body?i.body.getReader():void 0,d=void 0!==i.headers.get("Content-Length"),c=function(e,t){if(!t)return 0;var t=e.headers.get("Content-Encoding"),n=parseInt(e.headers.get("Content-Length"));switch(t){case"br":return Math.round(5*n);case"gzip":return Math.round(4*n);default:return n}}(i,d),u=new Uint8Array(c),f=[],l=0,h=0;return d||console.warn("[UnityCache] Response is served without Content-Length header. Please reconfigure server to include valid Content-Length for better download performance."),function o(){return void 0===e?i.arrayBuffer().then(function(e){var t=new Uint8Array(e);return a({type:"progress",response:i,total:e.length,loaded:0,lengthComputable:d,chunk:s?t:null}),t}):e.read().then(function(e){if(e.done){if(l===c)return u;if(l<c)return u.slice(0,l);for(var t=new Uint8Array(l),n=(t.set(u,0),h),r=0;r<f.length;++r)t.set(f[r],n),n+=f[r].length;return t}return l+e.value.length<=u.length?(u.set(e.value,l),h=l+e.value.length):f.push(e.value),l+=e.value.length,a({type:"progress",response:i,total:Math.max(c,l),loaded:l,lengthComputable:d,chunk:s?e.value:null}),o()})}().then(function(e){return a({type:"load",response:i,total:e.length,loaded:e.length,lengthComputable:d,chunk:null}),i.parsedBody=e,i})},f.fetchWithProgress=function(e,t){var n=function(){};return t&&t.onProgress&&(n=t.onProgress),fetch(e,t).then(function(e){return f.readBodyWithProgress(e,n,t.enableStreamingDownload)})},f.UnityCache=(h={name:"UnityCache",version:4},p={name:"RequestMetaDataStore",version:1},w="RequestStore",m="WebAssembly",b=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,v=null,O.getInstance=function(){return v=v||new O},O.destroyInstance=function(){return v?v.close().then(function(){v=null}):Promise.resolve()},O.prototype.clearCache=function(){var r=this;return this.isConnected.then(function(){return r.execute(p.name,"clear",[])}).then(function(){return r.cache.keys()}).then(function e(t){var n;return 0===t.length?Promise.resolve():(n=t.pop(),r.cache.delete(n).then(function(){return e(t)}))})},O.UnityCacheDatabase=h,O.RequestMetaDataStore=p,O.MaximumCacheSize=1073741824,O.prototype.loadRequest=function(e){var t=this;return t.isConnected.then(function(){return Promise.all([t.cache.match(e),t.loadRequestMetaData(e)])}).then(function(e){if(void 0!==e[0]&&void 0!==e[1])return{response:e[0],metaData:e[1]}})},O.prototype.loadRequestMetaData=function(e){e="string"==typeof e?e:e.url;return this.execute(p.name,"get",[e])},O.prototype.updateRequestMetaData=function(e){return this.execute(p.name,"put",[e])},O.prototype.storeRequest=function(e,t){var n=this;return n.isConnected.then(function(){return n.cache.put(e,t)})},O.prototype.close=function(){return this.isConnected.then(function(){this.database&&(this.database.close(),this.database=null),this.cache&&(this.cache=null)}.bind(this))},O.prototype.connect=function(){var o=this;return void 0===b?Promise.reject(new Error("Could not connect to cache: IndexedDB is not supported.")):void 0===window.caches?Promise.reject(new Error("Could not connect to cache: Cache API is not supported.")):new Promise(function(t,n){try{function r(){o.openDBTimeout&&(clearTimeout(o.openDBTimeout),o.openDBTimeout=null)}o.openDBTimeout=setTimeout(function(){void 0===o.database&&n(new Error("Could not connect to cache: Database timeout."))},2e4);var e=b.open(h.name,h.version);e.onupgradeneeded=o.upgradeDatabase.bind(o),e.onsuccess=function(e){r(),o.database=e.target.result,t()},e.onerror=function(e){r(),o.database=null,n(new Error("Could not connect to database."))}}catch(e){r(),o.database=null,o.cache=null,n(new Error("Could not connect to cache: Could not connect to database."))}}).then(function(){var e=h.name+"_"+f.companyName+"_"+f.productName;return caches.open(e)}).then(function(e){o.cache=e})},O.prototype.upgradeDatabase=function(e){var t,e=e.target.result;e.objectStoreNames.contains(p.name)||(t=e.createObjectStore(p.name,{keyPath:"url"}),["accessedAt","updatedAt"].forEach(function(e){t.createIndex(e,e)})),e.objectStoreNames.contains(w)&&e.deleteObjectStore(w),e.objectStoreNames.contains(m)&&e.deleteObjectStore(m)},O.prototype.execute=function(i,a,s){return this.isConnected.then(function(){return new Promise(function(t,n){try{var e,r,o;null===this.database?n(new Error("indexedDB access denied")):(e=-1!=["put","delete","clear"].indexOf(a)?"readwrite":"readonly",r=this.database.transaction([i],e).objectStore(i),"openKeyCursor"==a&&(r=r.index(s[0]),s=s.slice(1)),(o=r[a].apply(r,s)).onsuccess=function(e){t(e.target.result)},o.onerror=function(e){n(e)})}catch(e){n(e)}}.bind(this))}.bind(this))},O.prototype.getMetaDataEntries=function(){var r=this,o=0,i=[];return new Promise(function(t,n){var e=r.database.transaction([p.name],"readonly").objectStore(p.name).openCursor();e.onsuccess=function(e){e=e.target.result;e?(o+=e.value.size,i.push(e.value),e.continue()):t({metaDataEntries:i,cacheSize:o})},e.onerror=function(e){n(e)}})},O.prototype.cleanUpCache=function(){var a=this;return this.getMetaDataEntries().then(function(e){for(var t=e.metaDataEntries,n=e.cacheSize,r=[],o=[],i=0;i<t.length;++i)t[i].version==f.productVersion?o.push(t[i]):(r.push(t[i]),n-=t[i].size);o.sort(function(e,t){return e.accessedAt-t.accessedAt});for(i=0;i<o.length&&!(n<O.MaximumCacheSize);++i)r.push(o[i]),n-=o[i].size;return function e(){var t;return 0===r.length?Promise.resolve():(t=r.pop(),a.cache.delete(t.url).then(function(e){if(e)return r=t.url,new Promise(function(e,t){var n=a.database.transaction([p.name],"readwrite");n.objectStore(p.name).delete(r),n.oncomplete=e,n.onerror=t});var r}).then(e))}()})},O),f.cachedFetch=(y=f.UnityCache,g=f.fetchWithProgress,x=f.readBodyWithProgress,function(o,i){var e,t,a=y.getInstance(),s=B("string"==typeof o?o:o.url),d={enabled:(e=s,(!(t=i)||!t.method||"GET"===t.method)&&((!t||-1!=["must-revalidate","immutable"].indexOf(t.control))&&!!e.match("^https?://")))};function c(n,r){return fetch(n,r).then(function(e){var t;return!d.enabled||d.revalidated?e:304===e.status?(d.revalidated=!0,a.updateRequestMetaData(d.metaData).then(function(){k("'"+d.metaData.url+"' successfully revalidated and served from the indexedDB cache")}).catch(function(e){k("'"+d.metaData.url+"' successfully revalidated but not stored in the indexedDB cache due to the error: "+e)}),x(d.response,r.onProgress,r.enableStreamingDownload)):200==e.status?(d.response=e,d.metaData.updatedAt=d.metaData.accessedAt,d.revalidated=!0,t=e.clone(),x(e,r.onProgress,r.enableStreamingDownload).then(function(e){return d.metaData.size=e.parsedBody.length,Promise.all([a.storeRequest(n,t),a.updateRequestMetaData(d.metaData)]).then(function(){k("'"+s+"' successfully downloaded and stored in the indexedDB cache")}).catch(function(e){k("'"+s+"' successfully downloaded but not stored in the indexedDB cache due to the error: "+e)}),e})):(k("'"+s+"' request failed with status: "+e.status+" "+e.statusText),x(e,r.onProgress,r.enableStreamingDownload))})}return i&&(d.control=i.control,d.companyName=i.companyName,d.productName=i.productName,d.productVersion=i.productVersion),d.revalidated=!1,d.metaData={url:s,accessedAt:Date.now(),version:d.productVersion},d.response=null,d.enabled?a.loadRequest(s).then(function(e){var n,r,t;return e?(n=e.response,r=e.metaData,d.response=n,d.metaData.size=r.size,d.metaData.updatedAt=r.updatedAt,"immutable"==d.control?(d.revalidated=!0,a.updateRequestMetaData(r).then(function(){k("'"+d.metaData.url+"' served from the indexedDB cache without revalidation")}),x(n,i.onProgress,i.enableStreamingDownload)):(e=s,(t=window.location.href.match(/^[a-z]+:\/\/[^\/]+/))&&!e.lastIndexOf(t[0],0)||!n.headers.get("Last-Modified")&&!n.headers.get("ETag")?(e=(i=i||{}).headers||{},i.headers=e,n.headers.get("Last-Modified")?(e["If-Modified-Since"]=n.headers.get("Last-Modified"),e["Cache-Control"]="no-cache"):n.headers.get("ETag")&&(e["If-None-Match"]=n.headers.get("ETag"),e["Cache-Control"]="no-cache"),c(o,i)):fetch(s,{method:"HEAD"}).then(function(t){return d.revalidated=["Last-Modified","ETag"].every(function(e){return!n.headers.get(e)||n.headers.get(e)==t.headers.get(e)}),d.revalidated?(a.updateRequestMetaData(r).then(function(){k("'"+d.metaData.url+"' successfully revalidated and served from the indexedDB cache")}),x(d.response,i.onProgress,i.enableStreamingDownload)):c(o,i)}))):c(o,i)}).catch(function(e){return k("Failed to load '"+d.metaData.url+"' from indexedDB cache due to the error: "+e),g(o,i)}):g(o,i)});var P={br:{require:function(e){var t,n={"decompress.js":function(e,t,n){t.exports=e("./dec/decode").BrotliDecompressBuffer},"dec/bit_reader.js":function(e,t,n){const r=8224,o=new Uint32Array([0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215]);function i(e){this.buf_=new Uint8Array(r),this.input_=e,this.reset()}i.READ_SIZE=4096,i.IBUF_MASK=8191,i.prototype.reset=function(){this.buf_ptr_=0,this.val_=0,this.pos_=0,this.bit_pos_=0,this.bit_end_pos_=0,this.eos_=0,this.readMoreInput();for(var e=0;e<4;e++)this.val_|=this.buf_[this.pos_]<<8*e,++this.pos_;return 0<this.bit_end_pos_},i.prototype.readMoreInput=function(){if(!(256<this.bit_end_pos_))if(this.eos_){if(this.bit_pos_>this.bit_end_pos_)throw new Error("Unexpected end of input "+this.bit_pos_+" "+this.bit_end_pos_)}else{var e=this.buf_ptr_,t=this.input_.read(this.buf_,e,4096);if(t<0)throw new Error("Unexpected end of input");if(t<4096){this.eos_=1;for(var n=0;n<32;n++)this.buf_[e+t+n]=0}if(0===e){for(n=0;n<32;n++)this.buf_[8192+n]=this.buf_[n];this.buf_ptr_=4096}else this.buf_ptr_=0;this.bit_end_pos_+=t<<3}},i.prototype.fillBitWindow=function(){for(;8<=this.bit_pos_;)this.val_>>>=8,this.val_|=this.buf_[8191&this.pos_]<<24,++this.pos_,this.bit_pos_=this.bit_pos_-8>>>0,this.bit_end_pos_=this.bit_end_pos_-8>>>0},i.prototype.readBits=function(e){32-this.bit_pos_<e&&this.fillBitWindow();var t=this.val_>>>this.bit_pos_&o[e];return this.bit_pos_+=e,t},t.exports=i},"dec/context.js":function(e,t,n){n.lookup=new Uint8Array([0,0,0,0,0,0,0,0,0,4,4,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,12,16,12,12,20,12,16,24,28,12,12,32,12,36,12,44,44,44,44,44,44,44,44,44,44,32,32,24,40,28,12,12,48,52,52,52,48,52,52,52,48,52,52,52,52,52,48,52,52,52,52,52,48,52,52,52,52,52,24,12,28,12,12,12,56,60,60,60,56,60,60,60,56,60,60,60,60,60,56,60,60,60,60,60,56,60,60,60,60,60,24,12,28,12,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,56,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,26,26,26,26,27,27,27,27,28,28,28,28,29,29,29,29,30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,33,34,34,34,34,35,35,35,35,36,36,36,36,37,37,37,37,38,38,38,38,39,39,39,39,40,40,40,40,41,41,41,41,42,42,42,42,43,43,43,43,44,44,44,44,45,45,45,45,46,46,46,46,47,47,47,47,48,48,48,48,49,49,49,49,50,50,50,50,51,51,51,51,52,52,52,52,53,53,53,53,54,54,54,54,55,55,55,55,56,56,56,56,57,57,57,57,58,58,58,58,59,59,59,59,60,60,60,60,61,61,61,61,62,62,62,62,63,63,63,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),n.lookupOffsets=new Uint16Array([1024,1536,1280,1536,0,256,768,512])},"dec/decode.js":function(e,n,t){var r=e("./streams").BrotliInput,o=e("./streams").BrotliOutput,he=e("./bit_reader"),pe=e("./dictionary"),we=e("./huffman").HuffmanCode,V=e("./huffman").BrotliBuildHuffmanTable,me=e("./context"),be=e("./prefix"),ve=e("./transform");const A=8,q=16,ye=256,ge=704,xe=26,Ue=6,Ee=2,H=8,i=255,We=1080,D=18,F=new Uint8Array([1,2,3,4,0,5,17,6,16,7,8,9,10,11,12,13,14,15]),Oe=16,ke=new Uint8Array([3,2,1,0,3,3,3,3,3,3,2,2,2,2,2,2]),De=new Int8Array([0,0,0,0,-1,1,-2,2,-3,3,-1,1,-2,2,-3,3]),d=new Uint16Array([256,402,436,468,500,534,566,598,630,662,694,726,758,790,822,854,886,920,952,984,1016,1048,1080]);function Be(e){var t;return 0===e.readBits(1)?16:0<(t=e.readBits(3))?17+t:0<(t=e.readBits(3))?8+t:17}function Pe(e){var t;return e.readBits(1)?0===(t=e.readBits(3))?1:e.readBits(t)+(1<<t):0}function c(){this.meta_block_length=0,this.input_end=0,this.is_uncompressed=0,this.is_metadata=!1}function Ne(e){var t,n,r,o=new c;if(o.input_end=e.readBits(1),!o.input_end||!e.readBits(1)){if(7===(t=e.readBits(2)+4)){if(o.is_metadata=!0,0!==e.readBits(1))throw new Error("Invalid reserved bit");if(0===(n=e.readBits(2)))return o;for(r=0;r<n;r++){var i=e.readBits(8);if(r+1===n&&1<n&&0===i)throw new Error("Invalid size byte");o.meta_block_length|=i<<8*r}}else for(r=0;r<t;++r){var a=e.readBits(4);if(r+1===t&&4<t&&0===a)throw new Error("Invalid size nibble");o.meta_block_length|=a<<4*r}++o.meta_block_length,o.input_end||o.is_metadata||(o.is_uncompressed=e.readBits(1))}return o}function Re(e,t,n){var r;return n.fillBitWindow(),0<(r=e[t+=n.val_>>>n.bit_pos_&i].bits-H)&&(n.bit_pos_+=H,t=(t+=e[t].value)+(n.val_>>>n.bit_pos_&(1<<r)-1)),n.bit_pos_+=e[t].bits,e[t].value}function Me(e,t,n,r){var o=new Uint8Array(e);if(r.readMoreInput(),1===(m=r.readBits(2))){for(var i=e-1,a=0,s=new Int32Array(4),d=r.readBits(2)+1;i;)i>>=1,++a;for(h=0;h<d;++h)s[h]=r.readBits(a)%e,o[s[h]]=2;switch(d){case o[s[0]]=1:break;case 3:if(s[0]===s[1]||s[0]===s[2]||s[1]===s[2])throw new Error("[ReadHuffmanCode] invalid symbols");break;case 2:if(s[0]===s[1])throw new Error("[ReadHuffmanCode] invalid symbols");o[s[1]]=1;break;case 4:if(s[0]===s[1]||s[0]===s[2]||s[0]===s[3]||s[1]===s[2]||s[1]===s[3]||s[2]===s[3])throw new Error("[ReadHuffmanCode] invalid symbols");r.readBits(1)?(o[s[2]]=3,o[s[3]]=3):o[s[0]]=2}}else{for(var c=new Uint8Array(D),u=32,f=0,l=[new we(2,0),new we(2,4),new we(2,3),new we(3,2),new we(2,0),new we(2,4),new we(2,3),new we(4,1),new we(2,0),new we(2,4),new we(2,3),new we(3,2),new we(2,0),new we(2,4),new we(2,3),new we(4,5)],h=m;h<D&&0<u;++h){var p=F[h],w=0;r.fillBitWindow(),w+=r.val_>>>r.bit_pos_&15,r.bit_pos_+=l[w].bits,w=l[w].value,0!==(c[p]=w)&&(u-=32>>w,++f)}if(1!==f&&0!==u)throw new Error("[ReadHuffmanCode] invalid num_codes or space");for(var m=c,b=e,v=o,y=r,g=0,x=A,U=0,E=0,W=32768,O=[],k=0;k<32;k++)O.push(new we(0,0));for(V(O,0,5,m,D);g<b&&0<W;){var B=0;if(y.readMoreInput(),y.fillBitWindow(),B+=y.val_>>>y.bit_pos_&31,y.bit_pos_+=O[B].bits,(B=255&O[B].value)<q)(U=0)!=(v[g++]=B)&&(W-=32768>>(x=B));else{var P,N=B-14,R=0;if(E!==(R=B===q?x:R)&&(U=0,E=R),0<(B=U)&&(U=U-2<<N),b<g+(P=(U+=y.readBits(N)+3)-B))throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");for(var M=0;M<P;M++)v[g+M]=E;g+=P,0!==E&&(W-=P<<15-E)}}if(0!==W)throw new Error("[ReadHuffmanCodeLengths] space = "+W);for(;g<b;g++)v[g]=0}if(0===(m=V(t,n,H,o,e)))throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");return m}function Ve(e,t,n){return e=Re(e,t,n),t=be.kBlockLengthPrefixCode[e].nbits,be.kBlockLengthPrefixCode[e].offset+n.readBits(t)}function Ae(e,t){this.alphabet_size=e,this.num_htrees=t,this.codes=new Array(t+t*d[e+31>>>5]),this.htrees=new Uint32Array(t)}function qe(e,t){var n,r,o,i={num_htrees:null,context_map:null},a=0,s=(t.readMoreInput(),i.num_htrees=Pe(t)+1),d=i.context_map=new Uint8Array(e);if(!(s<=1)){for(t.readBits(1)&&(a=t.readBits(4)+1),n=[],r=0;r<We;r++)n[r]=new we(0,0);for(Me(s+a,n,0,t),r=0;r<e;)if(t.readMoreInput(),0===(o=Re(n,0,t)))d[r]=0,++r;else if(o<=a)for(var c=1+(1<<o)+t.readBits(o);--c;){if(e<=r)throw new Error("[DecodeContextMap] i >= context_map_size");d[r]=0,++r}else d[r]=o-a,++r;if(t.readBits(1)){for(var u=d,f=e,l=new Uint8Array(256),h=0;h<256;++h)l[h]=h;for(h=0;h<f;++h){var p=u[h];if(u[h]=l[p],p){for(var w=m=void 0,m=l,b=m[p],w=p;w;--w)m[w]=m[w-1];m[0]=b}}}}return i}function He(e,t,n,r,o,i,a){var s=2*n,d=n;e<=(a=0===(t=Re(t,n*We,a))?o[s+(1&i[d])]:1===t?o[s+(i[d]-1&1)]+1:t-2)&&(a-=e),r[n]=a,o[s+(1&i[d])]=a,++i[d]}function a(e){return e=new r(e),Be(e=new he(e)),Ne(e).meta_block_length}function s(D,e){for(var t=0,F=0,L=0,T=[16,15,11,4],S=0,n=0,r=0,o=[new Ae(0,0),new Ae(0,0),new Ae(0,0)],Y=128+he.READ_SIZE,i=new he(D),C=(1<<(D=Be(i)))-16,a=1<<D,s=a-1,d=new Uint8Array(a+Y+pe.maxDictionaryWordLength),I=a,c=[],u=[],f=0;f<3*We;f++)c[f]=new we(0,0),u[f]=new we(0,0);for(;!F;){for(var l,z,G,Z,h,K,X,p=0,w=[1<<28,1<<28,1<<28],m=[0],b=[1,1,1],j=[0,1,0,1,0,1],J=[0],Q=null,_=null,$=null,ee=0,te=0,v=0;v<3;++v)o[v].codes=null,o[v].htrees=null;if(i.readMoreInput(),t+(p=(g=Ne(i)).meta_block_length)>e.buffer.length&&((X=new Uint8Array(t+p)).set(e.buffer),e.buffer=X),F=g.input_end,X=g.is_uncompressed,g.is_metadata)for(g=void 0,g=(W=i).bit_pos_+7&-8,W.readBits(g-W.bit_pos_);0<p;--p)i.readMoreInput(),i.readBits(8);else if(0!==p)if(X){i.bit_pos_=i.bit_pos_+7&-8;var y,g,x=y=P=B=O=W=E=g=U=ne=void 0,ne=e,U=p,E=d,W=s,O=i,k=W+1,B=(g=t)&W,P=O.pos_&he.IBUF_MASK;if(U<8||O.bit_pos_+(U<<3)<O.bit_end_pos_)for(;0<U--;)O.readMoreInput(),E[B++]=O.readBits(8),B===k&&(ne.write(E,k),B=0);else{if(O.bit_end_pos_<32)throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");for(;O.bit_pos_<32;)E[B]=O.val_>>>O.bit_pos_,O.bit_pos_+=8,++B,--U;if(P+(y=O.bit_end_pos_-O.bit_pos_>>3)>he.IBUF_MASK){for(var re=he.IBUF_MASK+1-P,x=0;x<re;x++)E[B+x]=O.buf_[P+x];y-=re,B+=re,U-=re,P=0}for(x=0;x<y;x++)E[B+x]=O.buf_[P+x];if(U-=y,k<=(B+=y))for(ne.write(E,k),B-=k,x=0;x<B;x++)E[x]=E[k+x];for(;k<=B+U;){if(O.input_.read(E,B,y=k-B)<y)throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");ne.write(E,k),U-=y,B=0}if(O.input_.read(E,B,U)<U)throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");O.reset()}t+=p}else{for(v=0;v<3;++v)b[v]=Pe(i)+1,2<=b[v]&&(Me(b[v]+2,c,v*We,i),Me(xe,u,v*We,i),w[v]=Ve(u,v*We,i),J[v]=1);for(i.readMoreInput(),G=(1<<(l=i.readBits(2)))-1,g=(z=Oe+(i.readBits(4)<<l))+(48<<l),Q=new Uint8Array(b[0]),v=0;v<b[0];++v)i.readMoreInput(),Q[v]=i.readBits(2)<<1;var oe,N,R,M,ie,V,ae=qe(b[0]<<Ue,i),se=ae.num_htrees,de=ae.context_map,ce=(ae=qe(b[2]<<Ee,i)).num_htrees,ue=ae.context_map;for(o[0]=new Ae(ye,se),o[1]=new Ae(ge,b[1]),o[2]=new Ae(g,ce),v=0;v<3;++v)o[v].decode(i);for(h=Q[m[$=_=0]],ee=me.lookupOffsets[h],te=me.lookupOffsets[h+1],K=o[1].htrees[0];0<p;){for(i.readMoreInput(),0===w[1]&&(He(b[1],c,1,m,j,J,i),w[1]=Ve(u,We,i),K=o[1].htrees[m[1]]),--w[1],V=2<=(A=(H=Re(o[1].codes,K,i))>>6)?(A-=2,-1):0,q=be.kInsertRangeLut[A]+(H>>3&7),A=be.kCopyRangeLut[A]+(7&H),oe=be.kInsertLengthPrefixCode[q].offset+i.readBits(be.kInsertLengthPrefixCode[q].nbits),N=be.kCopyLengthPrefixCode[A].offset+i.readBits(be.kCopyLengthPrefixCode[A].nbits),n=d[t-1&s],r=d[t-2&s],M=0;M<oe;++M)i.readMoreInput(),0===w[0]&&(He(b[0],c,0,m,j,J,i),w[0]=Ve(u,0,i),_=m[0]<<Ue,h=Q[m[0]],ee=me.lookupOffsets[h],te=me.lookupOffsets[h+1]),Z=de[_+(me.lookup[ee+n]|me.lookup[te+r])],--w[0],r=n,n=Re(o[0].codes,o[0].htrees[Z],i),d[t&s]=n,(t&s)==s&&e.write(d,a),++t;if((p-=oe)<=0)break;if(V<0&&(i.readMoreInput(),0===w[2]&&(He(b[2],c,2,m,j,J,i),w[2]=Ve(u,2*We,i),$=m[2]<<Ee),--w[2],H=ue[$+(255&(4<N?3:N-2))],z<=(V=Re(o[2].codes,o[2].htrees[H],i))&&(q=(V-=z)&G,V=z+((fe=(2+(1&(V>>=l))<<(A=1+(V>>1)))-4)+i.readBits(A)<<l)+q)),H=T,A=S,(R=H=(q=V)<Oe?H[A=A+ke[q]&3]+De[q]:q-Oe+1)<0)throw new Error("[BrotliDecompress] invalid distance");if(ie=t&s,(L=t<C&&L!==C?t:C)<R){if(!(N>=pe.minDictionaryWordLength&&N<=pe.maxDictionaryWordLength))throw new Error("Invalid backward reference. pos: "+t+" distance: "+R+" len: "+N+" bytes left: "+p);var fe=pe.offsetsByLength[N],A=R-L-1,q=pe.sizeBitsByLength[N],H=A>>q;if(fe+=(A&(1<<q)-1)*N,!(H<ve.kNumTransforms))throw new Error("Invalid backward reference. pos: "+t+" distance: "+R+" len: "+N+" bytes left: "+p);if(t+=A=ve.transformDictionaryWord(d,ie,fe,N,H),p-=A,I<=(ie+=A)){e.write(d,a);for(var le=0;le<ie-I;le++)d[le]=d[I+le]}}else{if(0<V&&(T[3&S]=R,++S),p<N)throw new Error("Invalid backward reference. pos: "+t+" distance: "+R+" len: "+N+" bytes left: "+p);for(M=0;M<N;++M)d[t&s]=d[t-R&s],(t&s)==s&&e.write(d,a),++t,--p}n=d[t-1&s],r=d[t-2&s]}t&=1073741823}}e.write(d,t&s)}Ae.prototype.decode=function(e){for(var t=0,n=0;n<this.num_htrees;++n)this.htrees[n]=t,t+=Me(this.alphabet_size,this.codes,t,e)},t.BrotliDecompressedSize=a,t.BrotliDecompressBuffer=function(e,t){var n=new r(e),e=(null==t&&(t=a(e)),new Uint8Array(t));return s(n,t=new o(e)),t.pos<t.buffer.length&&(t.buffer=t.buffer.subarray(0,t.pos)),t.buffer},t.BrotliDecompress=s,pe.init()},"dec/dictionary.js":function(e,t,n){var r=e("./dictionary-browser");n.init=function(){n.dictionary=r.init()},n.offsetsByLength=new Uint32Array([0,0,0,0,0,4096,9216,21504,35840,44032,53248,63488,74752,87040,93696,100864,104704,106752,108928,113536,115968,118528,119872,121280,122016]),n.sizeBitsByLength=new Uint8Array([0,0,0,0,10,10,11,11,10,10,10,10,10,9,9,8,7,7,8,7,7,6,6,5,5]),n.minDictionaryWordLength=4,n.maxDictionaryWordLength=24},"dec/dictionary.bin.js":function(e,t,n){t.exports="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"},"dec/dictionary-browser.js":function(e,t,n){var r=e("base64-js");n.init=function(){return(0,e("./decode").BrotliDecompressBuffer)(r.toByteArray(e("./dictionary.bin.js")))}},"dec/huffman.js":function(e,t,n){function v(e,t){this.bits=e,this.value=t}n.HuffmanCode=v;function y(e,t){for(var n=1<<t-1;e&n;)n>>=1;return(e&n-1)+n}function g(e,t,n,r,o){for(;e[t+(r-=n)]=new v(o.bits,o.value),0<r;);}n.BrotliBuildHuffmanTable=function(e,t,n,r,o){for(var i,a,s,d,c,u,f,l,h=t,p=new Int32Array(16),w=new Int32Array(16),m=new Int32Array(o),b=0;b<o;b++)p[r[b]]++;for(w[1]=0,i=1;i<15;i++)w[i+1]=w[i]+p[i];for(b=0;b<o;b++)0!==r[b]&&(m[w[r[b]]++]=b);if(l=f=1<<n,1===w[15])for(a=0;a<l;++a)e[t+a]=new v(0,65535&m[0]);else{for(b=a=0,i=1,s=2;i<=n;++i,s<<=1)for(;0<p[i];--p[i])g(e,t+a,s,f,new v(255&i,65535&m[b++])),a=y(a,i);for(c=l-1,d=-1,i=n+1,s=2;i<=15;++i,s<<=1)for(;0<p[i];--p[i])(a&c)!==d&&(t+=f,l+=f=1<<(u=function(e,t,n){for(var r=1<<t-n;t<15&&!((r-=e[t])<=0);)++t,r<<=1;return t-n}(p,i,n)),e[h+(d=a&c)]=new v(u+n&255,t-h-d&65535)),g(e,t+(a>>n),s,f,new v(i-n&255,65535&m[b++])),a=y(a,i)}return l}},"dec/prefix.js":function(e,t,n){function r(e,t){this.offset=e,this.nbits=t}n.kBlockLengthPrefixCode=[new r(1,2),new r(5,2),new r(9,2),new r(13,2),new r(17,3),new r(25,3),new r(33,3),new r(41,3),new r(49,4),new r(65,4),new r(81,4),new r(97,4),new r(113,5),new r(145,5),new r(177,5),new r(209,5),new r(241,6),new r(305,6),new r(369,7),new r(497,8),new r(753,9),new r(1265,10),new r(2289,11),new r(4337,12),new r(8433,13),new r(16625,24)],n.kInsertLengthPrefixCode=[new r(0,0),new r(1,0),new r(2,0),new r(3,0),new r(4,0),new r(5,0),new r(6,1),new r(8,1),new r(10,2),new r(14,2),new r(18,3),new r(26,3),new r(34,4),new r(50,4),new r(66,5),new r(98,5),new r(130,6),new r(194,7),new r(322,8),new r(578,9),new r(1090,10),new r(2114,12),new r(6210,14),new r(22594,24)],n.kCopyLengthPrefixCode=[new r(2,0),new r(3,0),new r(4,0),new r(5,0),new r(6,0),new r(7,0),new r(8,0),new r(9,0),new r(10,1),new r(12,1),new r(14,2),new r(18,2),new r(22,3),new r(30,3),new r(38,4),new r(54,4),new r(70,5),new r(102,5),new r(134,6),new r(198,7),new r(326,8),new r(582,9),new r(1094,10),new r(2118,24)],n.kInsertRangeLut=[0,0,8,8,0,16,8,16,16],n.kCopyRangeLut=[0,8,0,8,16,0,16,8,16]},"dec/streams.js":function(e,t,n){function r(e){this.buffer=e,this.pos=0}function o(e){this.buffer=e,this.pos=0}r.prototype.read=function(e,t,n){this.pos+n>this.buffer.length&&(n=this.buffer.length-this.pos);for(var r=0;r<n;r++)e[t+r]=this.buffer[this.pos+r];return this.pos+=n,n},n.BrotliInput=r,o.prototype.write=function(e,t){if(this.pos+t>this.buffer.length)throw new Error("Output buffer is not large enough");return this.buffer.set(e.subarray(0,t),this.pos),this.pos+=t,t},n.BrotliOutput=o},"dec/transform.js":function(e,t,n){var p=e("./dictionary");function r(e,t,n){this.prefix=new Uint8Array(e.length),this.transform=t,this.suffix=new Uint8Array(n.length);for(var r=0;r<e.length;r++)this.prefix[r]=e.charCodeAt(r);for(r=0;r<n.length;r++)this.suffix[r]=n.charCodeAt(r)}var w=[new r("",0,""),new r("",0," "),new r(" ",0," "),new r("",12,""),new r("",10," "),new r("",0," the "),new r(" ",0,""),new r("s ",0," "),new r("",0," of "),new r("",10,""),new r("",0," and "),new r("",13,""),new r("",1,""),new r(", ",0," "),new r("",0,", "),new r(" ",10," "),new r("",0," in "),new r("",0," to "),new r("e ",0," "),new r("",0,'"'),new r("",0,"."),new r("",0,'">'),new r("",0,"\n"),new r("",3,""),new r("",0,"]"),new r("",0," for "),new r("",14,""),new r("",2,""),new r("",0," a "),new r("",0," that "),new r(" ",10,""),new r("",0,". "),new r(".",0,""),new r(" ",0,", "),new r("",15,""),new r("",0," with "),new r("",0,"'"),new r("",0," from "),new r("",0," by "),new r("",16,""),new r("",17,""),new r(" the ",0,""),new r("",4,""),new r("",0,". The "),new r("",11,""),new r("",0," on "),new r("",0," as "),new r("",0," is "),new r("",7,""),new r("",1,"ing "),new r("",0,"\n\t"),new r("",0,":"),new r(" ",0,". "),new r("",0,"ed "),new r("",20,""),new r("",18,""),new r("",6,""),new r("",0,"("),new r("",10,", "),new r("",8,""),new r("",0," at "),new r("",0,"ly "),new r(" the ",0," of "),new r("",5,""),new r("",9,""),new r(" ",10,", "),new r("",10,'"'),new r(".",0,"("),new r("",11," "),new r("",10,'">'),new r("",0,'="'),new r(" ",0,"."),new r(".com/",0,""),new r(" the ",0," of the "),new r("",10,"'"),new r("",0,". This "),new r("",0,","),new r(".",0," "),new r("",10,"("),new r("",10,"."),new r("",0," not "),new r(" ",0,'="'),new r("",0,"er "),new r(" ",11," "),new r("",0,"al "),new r(" ",11,""),new r("",0,"='"),new r("",11,'"'),new r("",10,". "),new r(" ",0,"("),new r("",0,"ful "),new r(" ",10,". "),new r("",0,"ive "),new r("",0,"less "),new r("",11,"'"),new r("",0,"est "),new r(" ",10,"."),new r("",11,'">'),new r(" ",0,"='"),new r("",10,","),new r("",0,"ize "),new r("",11,"."),new r("\xc2\xa0",0,""),new r(" ",0,","),new r("",10,'="'),new r("",11,'="'),new r("",0,"ous "),new r("",11,", "),new r("",10,"='"),new r(" ",10,","),new r(" ",11,'="'),new r(" ",11,", "),new r("",11,","),new r("",11,"("),new r("",11,". "),new r(" ",11,"."),new r("",11,"='"),new r(" ",11,". "),new r(" ",10,'="'),new r(" ",11,"='"),new r(" ",10,"='")];function m(e,t){return e[t]<192?(97<=e[t]&&e[t]<=122&&(e[t]^=32),1):e[t]<224?(e[t+1]^=32,2):(e[t+2]^=5,3)}n.kTransforms=w,n.kNumTransforms=w.length,n.transformDictionaryWord=function(e,t,n,r,o){for(var i,a=w[o].prefix,s=w[o].suffix,d=(o=w[o].transform)<12?0:o-11,c=0,u=t,f=(r<d&&(d=r),0);f<a.length;)e[t++]=a[f++];for(n+=d,r-=d,o<=9&&(r-=o),c=0;c<r;c++)e[t++]=p.dictionary[n+c];if(i=t-r,10===o)m(e,i);else if(11===o)for(;0<r;){var l=m(e,i);i+=l,r-=l}for(var h=0;h<s.length;)e[t++]=s[h++];return t-u}},"node_modules/base64-js/index.js":function(e,t,n){"use strict";n.byteLength=function(e){return 3*e.length/4-f(e)},n.toByteArray=function(e){for(var t,n,r,o,i=e.length,a=(r=f(e),o=new u(3*i/4-r),t=0<r?i-4:i,0),s=0;s<t;s+=4)n=c[e.charCodeAt(s)]<<18|c[e.charCodeAt(s+1)]<<12|c[e.charCodeAt(s+2)]<<6|c[e.charCodeAt(s+3)],o[a++]=n>>16&255,o[a++]=n>>8&255,o[a++]=255&n;return 2===r?(n=c[e.charCodeAt(s)]<<2|c[e.charCodeAt(s+1)]>>4,o[a++]=255&n):1===r&&(n=c[e.charCodeAt(s)]<<10|c[e.charCodeAt(s+1)]<<4|c[e.charCodeAt(s+2)]>>2,o[a++]=n>>8&255,o[a++]=255&n),o},n.fromByteArray=function(e){for(var t,n=e.length,r=n%3,o="",i=[],a=0,s=n-r;a<s;a+=16383)i.push(function(e,t){for(var n,r=[],o=a;o<t;o+=3)n=(e[o]<<16)+(e[o+1]<<8)+e[o+2],r.push(d[n>>18&63]+d[n>>12&63]+d[n>>6&63]+d[63&n]);return r.join("")}(e,s<a+16383?s:a+16383));return 1==r?(t=e[n-1],o=(o+=d[t>>2])+d[t<<4&63]+"=="):2==r&&(t=(e[n-2]<<8)+e[n-1],o=(o=(o+=d[t>>10])+d[t>>4&63])+d[t<<2&63]+"="),i.push(o),i.join("")};for(var d=[],c=[],u="undefined"!=typeof Uint8Array?Uint8Array:Array,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=0,i=r.length;o<i;++o)d[o]=r[o],c[r.charCodeAt(o)]=o;function f(e){var t=e.length;if(0<t%4)throw new Error("Invalid string. Length must be a multiple of 4");return"="===e[t-2]?2:"="===e[t-1]?1:0}c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63}};for(t in n)n[t].folder=t.substring(0,t.lastIndexOf("/")+1);function r(e,t){var n=t.match(/^\//)?null:e?t.match(/^\.\.?\//)?o(e.folder+t):i(e,t):o(t);if(n)return n.exports||(n.parent=e,n(r.bind(null,n),n,n.exports={})),n.exports;throw"module not found: "+t}var o=function(e){var t=[];return(e=e.split("/").every(function(e){return".."==e?t.pop():"."==e||""==e||t.push(e)})?t.join("/"):null)?n[e]||n[e+".js"]||n[e+"/index.js"]:null},i=function(e,t){return e?o(e.folder+"node_modules/"+t)||i(e.parent,t):null};return r(null,e)},decompress:function(e){this.exports||(this.exports=this.require("decompress.js"));try{return this.exports(e)}catch(e){}},hasUnityMarker:function(e){var t="UnityWeb Compressed Content (brotli)";if(!e.length)return!1;var n=1&e[0]?14&e[0]?4:7:1,r=e[0]&(1<<n)-1,o=1+(Math.log(t.length-1)/Math.log(2)>>3);if(commentOffset=1+n+2+1+2+(o<<3)+7>>3,17==r||commentOffset>e.length)return!1;for(var i=r+(6+(o<<4)+(t.length-1<<6)<<n),a=0;a<commentOffset;a++,i>>>=8)if(e[a]!=(255&i))return!1;return String.fromCharCode.apply(null,e.subarray(commentOffset,commentOffset+t.length))==t}}};function N(n){W(n);var e=f.cacheControl(f[n]),t=f.companyName&&f.productName?f.cachedFetch:f.fetchWithProgress,r=f[n],r=/file:\/\//.exec(r)?"same-origin":void 0;return t(f[n],{method:"GET",companyName:f.companyName,productName:f.productName,productVersion:f.productVersion,control:e,mode:r,onProgress:function(e){W(n,e)}}).then(function(e){return a=e.parsedBody,s=f[n],new Promise(function(e,t){try{for(var n in P){var r,o,i;if(P[n].hasUnityMarker(a))return s&&console.log('You can reduce startup time if you configure your web server to add "Content-Encoding: '+n+'" response header when serving "'+s+'" file.'),(r=P[n]).worker||(o=URL.createObjectURL(new Blob(["this.require = ",r.require.toString(),"; this.decompress = ",r.decompress.toString(),"; this.onmessage = ",function(e){e={id:e.data.id,decompressed:this.decompress(e.data.compressed)};postMessage(e,e.decompressed?[e.decompressed.buffer]:[])}.toString(),"; postMessage({ ready: true });"],{type:"application/javascript"})),r.worker=new Worker(o),r.worker.onmessage=function(e){e.data.ready?URL.revokeObjectURL(o):(this.callbacks[e.data.id](e.data.decompressed),delete this.callbacks[e.data.id])},r.worker.callbacks={},r.worker.nextCallbackId=0),i=r.worker.nextCallbackId++,r.worker.callbacks[i]=e,void r.worker.postMessage({id:i,compressed:a},[a.buffer])}e(a)}catch(e){t(e)}});var a,s}).catch(function(e){var t="Failed to download file "+f[n];"file:"==location.protocol?c(t+". Loading web pages via a file:// URL without a web server is not supported by this browser. Please use a local development web server to host Unity content, or use the Unity Build and Run option.","error"):console.error(t)})}function R(){Promise.all([N("frameworkUrl").then(function(e){var s=URL.createObjectURL(new Blob([e],{type:"application/javascript"}));return new Promise(function(i,e){var a=document.createElement("script");a.src=s,a.onload=function(){if("undefined"==typeof unityFramework||!unityFramework){var e,t=[["br","br"],["gz","gzip"]];for(e in t){var n,r=t[e];if(f.frameworkUrl.endsWith("."+r[0]))return n="Unable to parse "+f.frameworkUrl+"!","file:"==location.protocol?void c(n+" Loading pre-compressed (brotli or gzip) content via a file:// URL without a web server is not supported by this browser. Please use a local development web server to host compressed Unity content, or use the Unity Build and Run option.","error"):(n+=' This can happen if build compression was enabled but web server hosting the content was misconfigured to not serve the file with HTTP Response Header "Content-Encoding: '+r[1]+'" present. Check browser Console and Devtools Network tab to debug.',"br"==r[0]&&"http:"==location.protocol&&(r=-1!=["localhost","127.0.0.1"].indexOf(location.hostname)?"":"Migrate your server to use HTTPS.",n=/Firefox/.test(navigator.userAgent)?"Unable to parse "+f.frameworkUrl+'!<br>If using custom web server, verify that web server is sending .br files with HTTP Response Header "Content-Encoding: br". Brotli compression may not be supported in Firefox over HTTP connections. '+r+' See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1670675">https://bugzilla.mozilla.org/show_bug.cgi?id=1670675</a> for more information.':"Unable to parse "+f.frameworkUrl+'!<br>If using custom web server, verify that web server is sending .br files with HTTP Response Header "Content-Encoding: br". Brotli compression may not be supported over HTTP connections. Migrate your server to use HTTPS.'),void c(n,"error"))}c("Unable to parse "+f.frameworkUrl+"! The file is corrupt, or compression was misconfigured? (check Content-Encoding HTTP Response Header on web server)","error")}var o=unityFramework;unityFramework=null,a.onload=null,URL.revokeObjectURL(s),i(o)},a.onerror=function(e){c("Unable to load file "+f.frameworkUrl+"! Check that the file exists on the remote server. (also check browser Console and Devtools Network tab to debug)","error")},document.body.appendChild(a),f.deinitializers.push(function(){document.body.removeChild(a)})})}),N("codeUrl")]).then(function(e){f.wasmBinary=e[1],e[0](f)});var e=N("dataUrl");f.preRun.push(function(){f.addRunDependency("dataUrl"),e.then(function(e){var t=new DataView(e.buffer,e.byteOffset,e.byteLength),n=0,r="UnityWebData1.0\0";if(!String.fromCharCode.apply(null,e.subarray(n,n+r.length))==r)throw"unknown data format";var o=t.getUint32(n+=r.length,!0);for(n+=4;n<o;){var i=t.getUint32(n,!0),a=(n+=4,t.getUint32(n,!0)),s=(n+=4,t.getUint32(n,!0)),d=(n+=4,String.fromCharCode.apply(null,e.subarray(n,n+s)));n+=s;for(var c=0,u=d.indexOf("/",c)+1;0<u;c=u,u=d.indexOf("/",c)+1)f.FS_createPath(d.substring(0,c),d.substring(c,u-1),!0,!0);f.FS_createDataFile(d,null,e.subarray(i,i+a),!0,!0,!0)}f.removeRunDependency("dataUrl")})})}return new Promise(function(e,t){var n;f.SystemInfo.hasWebGL?1==f.SystemInfo.hasWebGL?(n='Your browser does not support graphics API "WebGL 2" which is required for this content.',"Safari"==f.SystemInfo.browser&&parseInt(f.SystemInfo.browserVersion)<15&&(f.SystemInfo.mobile||1<navigator.maxTouchPoints?n+="\nUpgrade to iOS 15 or later.":n+="\nUpgrade to Safari 15 or later."),t(n)):f.SystemInfo.hasWasm?(f.startupErrorHandler=t,d(0),f.postRun.push(function(){d(1),delete f.startupErrorHandler,e(U)}),R()):t("Your browser does not support WebAssembly."):t("Your browser does not support WebGL.")})}


================================================
File: unity/Build/SimPy.wasm.unityweb
================================================
[Non-text file]


================================================
File: unity/StreamingAssets/MQTTBroker.json
================================================
{
  "tcp": {
    "port": 1883,
    "host": "supos-ce-instance4.supos.app",
    "client_id": "simpy_mqtt_docker_mqtt_client",
    "username": "",
    "password": "",
    "keep_alive": 60,
    "mqtt_version": 5,
    "connect_timeout": 30,
    "auto_reconnect": true,
    "reconnect_delay": 5,
    "subscribe_broker_topic": ""
  },
  "ws": {
    "port": 8083,
    "host": "supos-ce-instance4.supos.app",
    "client_id": "simpy_mqtt_docker_mqtt_client_ws",
    "username": "",
    "password": "",
    "keep_alive": 60,
    "mqtt_version": 5,
    "connect_timeout": 30,
    "auto_reconnect": true,
    "reconnect_delay": 5,
    "subscribe_broker_topic": ""
  },
  "wss": {
    "port": 8084,
    "host": "supos-ce-instance4.supos.app",
    "client_id": "marks_mqtt_wss_test",
    "username": "",
    "password": "",
    "keep_alive": 60,
    "mqtt_version": 5,
    "connect_timeout": 30,
    "auto_reconnect": true,
    "reconnect_delay": 5,
    "subscribe_broker_topic": ""
  },

  "common_topic": {
    "Root_Topic_Head": "marks"
  },
  "connect_mode": { "wss": true }
}



================================================
File: unity/TemplateData/style.css
================================================
body { padding: 0; margin: 0 }
#unity-container { position: absolute }
#unity-container.unity-desktop { left: 50%; top: 50%; transform: translate(-50%, -50%) }
#unity-container.unity-mobile { position: fixed; width: 100%; height: 100% }
#unity-canvas { background: #231F20 }
.unity-mobile #unity-canvas { width: 100%; height: 100% }
#unity-loading-bar { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); display: none }
#unity-logo { width: 154px; height: 130px; background: url('unity-logo-dark.png') no-repeat center }
#unity-progress-bar-empty { width: 141px; height: 18px; margin-top: 10px; margin-left: 6.5px; background: url('progress-bar-empty-dark.png') no-repeat center }
#unity-progress-bar-full { width: 0%; height: 18px; margin-top: 10px; background: url('progress-bar-full-dark.png') no-repeat center }
#unity-footer { position: relative }
.unity-mobile #unity-footer { display: none }
#unity-webgl-logo { float:left; width: 204px; height: 38px; background: url('webgl-logo.png') no-repeat center }
#unity-build-title { float: right; margin-right: 10px; line-height: 38px; font-family: arial; font-size: 18px }
#unity-fullscreen-button { cursor:pointer; float: right; width: 38px; height: 38px; background: url('fullscreen-button.png') no-repeat center }
#unity-warning { position: absolute; left: 50%; top: 5%; transform: translate(-50%); background: white; padding: 10px; display: none }


